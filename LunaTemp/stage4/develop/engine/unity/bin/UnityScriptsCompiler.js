if ( TRACE ) { TRACE( JSON.parse( '["DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor","DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor","DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor","DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor","DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor","DG.Tweening.DOTweenModuleAudio#DOFade","DG.Tweening.DOTweenModuleAudio#DOPitch","DG.Tweening.DOTweenModuleAudio#DOSetFloat","DG.Tweening.DOTweenModuleAudio#DOComplete","DG.Tweening.DOTweenModuleAudio#DOKill","DG.Tweening.DOTweenModuleAudio#DOFlip","DG.Tweening.DOTweenModuleAudio#DOGoto","DG.Tweening.DOTweenModuleAudio#DOPause","DG.Tweening.DOTweenModuleAudio#DOPlay","DG.Tweening.DOTweenModuleAudio#DOPlayBackwards","DG.Tweening.DOTweenModuleAudio#DOPlayForward","DG.Tweening.DOTweenModuleAudio#DORestart","DG.Tweening.DOTweenModuleAudio#DORewind","DG.Tweening.DOTweenModuleAudio#DOSmoothRewind","DG.Tweening.DOTweenModuleAudio#DOTogglePause","DG.Tweening.DOTweenModulePhysics#DOMove","DG.Tweening.DOTweenModulePhysics#DOMoveX","DG.Tweening.DOTweenModulePhysics#DOMoveY","DG.Tweening.DOTweenModulePhysics#DOMoveZ","DG.Tweening.DOTweenModulePhysics#DORotate","DG.Tweening.DOTweenModulePhysics#DOLookAt","DG.Tweening.DOTweenModulePhysics#DOJump","DG.Tweening.DOTweenModulePhysics#DOPath","DG.Tweening.DOTweenModulePhysics#DOPath$1","DG.Tweening.DOTweenModulePhysics#DOLocalPath","DG.Tweening.DOTweenModulePhysics#DOLocalPath$1","DG.Tweening.DOTweenModulePhysics2D#DOMove","DG.Tweening.DOTweenModulePhysics2D#DOMoveX","DG.Tweening.DOTweenModulePhysics2D#DOMoveY","DG.Tweening.DOTweenModulePhysics2D#DORotate","DG.Tweening.DOTweenModulePhysics2D#DOJump","DG.Tweening.DOTweenModulePhysics2D#DOPath","DG.Tweening.DOTweenModulePhysics2D#DOPath$1","DG.Tweening.DOTweenModulePhysics2D#DOLocalPath","DG.Tweening.DOTweenModulePhysics2D#DOLocalPath$1","DG.Tweening.DOTweenModuleSprite#DOColor","DG.Tweening.DOTweenModuleSprite#DOFade","DG.Tweening.DOTweenModuleSprite#DOGradientColor","DG.Tweening.DOTweenModuleSprite#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOFade","DG.Tweening.DOTweenModuleUI#DOFade$1","DG.Tweening.DOTweenModuleUI#DOFade$2","DG.Tweening.DOTweenModuleUI#DOFade$3","DG.Tweening.DOTweenModuleUI#DOFade$4","DG.Tweening.DOTweenModuleUI#DOColor","DG.Tweening.DOTweenModuleUI#DOColor$1","DG.Tweening.DOTweenModuleUI#DOColor$2","DG.Tweening.DOTweenModuleUI#DOColor$3","DG.Tweening.DOTweenModuleUI#DOFillAmount","DG.Tweening.DOTweenModuleUI#DOGradientColor","DG.Tweening.DOTweenModuleUI#DOFlexibleSize","DG.Tweening.DOTweenModuleUI#DOMinSize","DG.Tweening.DOTweenModuleUI#DOPreferredSize","DG.Tweening.DOTweenModuleUI#DOScale","DG.Tweening.DOTweenModuleUI#DOAnchorPos","DG.Tweening.DOTweenModuleUI#DOAnchorPosX","DG.Tweening.DOTweenModuleUI#DOAnchorPosY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3D","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ","DG.Tweening.DOTweenModuleUI#DOAnchorMax","DG.Tweening.DOTweenModuleUI#DOAnchorMin","DG.Tweening.DOTweenModuleUI#DOPivot","DG.Tweening.DOTweenModuleUI#DOPivotX","DG.Tweening.DOTweenModuleUI#DOPivotY","DG.Tweening.DOTweenModuleUI#DOSizeDelta","DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1","DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos","DG.Tweening.DOTweenModuleUI#DONormalizedPos","DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOValue","DG.Tweening.DOTweenModuleUI#DOCounter","DG.Tweening.DOTweenModuleUI#DOText","DG.Tweening.DOTweenModuleUI#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOBlendableColor$1","DG.Tweening.DOTweenModuleUI#DOBlendableColor$2","DG.Tweening.DOTweenModuleUI#DOShapeCircle","DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1","DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion","DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind","DG.Tweening.DOTweenModuleUnityVersion#WaitForKill","DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops","DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition","DG.Tweening.DOTweenModuleUnityVersion#WaitForStart","DG.Tweening.DOTweenModuleUnityVersion#DOOffset","DG.Tweening.DOTweenModuleUnityVersion#DOTiling","DG.Tweening.DOTweenModuleUtils#Init","DG.Tweening.DOTweenModuleUtils#Preserver","DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody","DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween","Do.AudioManager#init","Do.AudioManager#Sound#get","Do.AudioManager#Sound#set","Do.AudioManager#Music#get","Do.AudioManager#Music#set","Do.AudioManager#Vibration#get","Do.AudioManager#Vibration#set","Do.AudioManager#init","Do.AudioManager#Awake","Do.AudioManager#InitBoolean","Do.AudioManager#InitSource","Do.AudioManager#Update","Do.AudioManager#SetMusicMute","Do.AudioManager#SetSoundMute","Do.AudioManager#Play","Do.AudioManager#Play$1","Do.AudioManager#PlayCache","Do.AudioManager#StopMusic","Do.AudioManager#StopSound","Do.AudioManager#StopAll","Do.AudioSound#init","LunaManager#OnPlayButtonClick","LunaManager#OnEnable","LunaManager#OnDisable","LunaManager#ResumeGameplay","LunaManager#PauseGameplay","Spine.BoneMatrix#CalculateSetupWorld","Spine.BoneMatrix#GetInheritedInternal","Spine.BoneMatrix#getDefaultValue","Spine.BoneMatrix#$ctor2","Spine.BoneMatrix#$ctor1","Spine.BoneMatrix#ctor","Spine.BoneMatrix#TransformMatrix","Spine.BoneMatrix#getHashCode","Spine.BoneMatrix#equals","Spine.BoneMatrix#$clone","Spine.SpineSkeletonExtensions#IsWeighted","Spine.SpineSkeletonExtensions#InheritsRotation","Spine.SpineSkeletonExtensions#InheritsScale","Spine.Unity.ActivateBasedOnFlipDirection#init","Spine.Unity.ActivateBasedOnFlipDirection#Start","Spine.Unity.ActivateBasedOnFlipDirection#FixedUpdate","Spine.Unity.ActivateBasedOnFlipDirection#HandleFlip","Spine.Unity.ActivateBasedOnFlipDirection#ResetJointPositions","Spine.Unity.ActivateBasedOnFlipDirection#CompensateMovementAfterFlipX","Spine.Unity.AnimationTools.TimelineExtensions#Evaluate","Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$1","Spine.Unity.AnimationTools.TimelineExtensions#FindTranslateTimelineForBone","Spine.Unity.AnimationTools.TimelineExtensions#FindTimelineForBone","Spine.Unity.AttachmentTools.AtlasUtilities#init","Spine.Unity.AttachmentTools.AtlasUtilities#Init","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$2","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$3","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$1","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$4","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$2","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$3","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$1","Spine.Unity.AttachmentTools.AtlasUtilities#ToSpineAtlasPage","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin$1","Spine.Unity.AttachmentTools.AtlasUtilities#ToSprite","Spine.Unity.AttachmentTools.AtlasUtilities#ClearCache","Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture","Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetClone","Spine.Unity.AttachmentTools.AtlasUtilities#CopyTexture","Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureApplyPMA","Spine.Unity.AttachmentTools.AtlasUtilities#IsRenderable","Spine.Unity.AttachmentTools.AtlasUtilities#SpineUnityFlipRect","Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect","Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetSpineAtlasRect","Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToTextureRect","Spine.Unity.AttachmentTools.AtlasUtilities#TextureRectToUVRect","Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToAtlasRegion","Spine.Unity.AttachmentTools.AtlasUtilities#GetMainTexture","Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture","Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureAttributesFrom","Spine.Unity.AttachmentTools.AtlasUtilities#InverseLerp","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getDefaultValue","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$ctor1","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#ctor","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getHashCode","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#equals","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$clone","Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone$1","Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRegion","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRegion$2","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRegion$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$2","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRotation","Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#get","Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#set","Spine.Unity.BlendModeMaterials#init","Spine.Unity.BlendModeMaterials#BlendModeForMaterial","Spine.Unity.BlendModeMaterials#ApplyMaterials","Spine.Unity.BlendModeMaterials#CloneAtlasRegionWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#init","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#CloneAtlasRegionWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#GetAtlasPageWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#Dispose","Spine.Unity.BoneFollower#SkeletonRenderer#get","Spine.Unity.BoneFollower#SkeletonRenderer#set","Spine.Unity.BoneFollower#init","Spine.Unity.BoneFollower#SetBone","Spine.Unity.BoneFollower#Awake","Spine.Unity.BoneFollower#HandleRebuildRenderer","Spine.Unity.BoneFollower#Initialize","Spine.Unity.BoneFollower#OnDestroy","Spine.Unity.BoneFollower#LateUpdate","Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#get","Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#set","Spine.Unity.BoneFollowerGraphic#init","Spine.Unity.BoneFollowerGraphic#SetBone","Spine.Unity.BoneFollowerGraphic#Awake","Spine.Unity.BoneFollowerGraphic#Initialize","Spine.Unity.BoneFollowerGraphic#LateUpdate","Spine.Unity.BoundingBoxFollower#init","Spine.Unity.BoundingBoxFollower#Slot#get","Spine.Unity.BoundingBoxFollower#CurrentAttachment#get","Spine.Unity.BoundingBoxFollower#CurrentAttachmentName#get","Spine.Unity.BoundingBoxFollower#CurrentCollider#get","Spine.Unity.BoundingBoxFollower#IsTrigger#get","Spine.Unity.BoundingBoxFollower#init","Spine.Unity.BoundingBoxFollower#Start","Spine.Unity.BoundingBoxFollower#OnEnable","Spine.Unity.BoundingBoxFollower#HandleRebuild","Spine.Unity.BoundingBoxFollower#Initialize","Spine.Unity.BoundingBoxFollower#AddCollidersForSkin","Spine.Unity.BoundingBoxFollower#OnDisable","Spine.Unity.BoundingBoxFollower#ClearState","Spine.Unity.BoundingBoxFollower#DisposeExcessCollidersAfter","Spine.Unity.BoundingBoxFollower#LateUpdate","Spine.Unity.BoundingBoxFollower#MatchAttachment","Spine.Unity.BoundingBoxFollowerGraphic#init","Spine.Unity.BoundingBoxFollowerGraphic#Slot#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachment#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachmentName#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentCollider#get","Spine.Unity.BoundingBoxFollowerGraphic#IsTrigger#get","Spine.Unity.BoundingBoxFollowerGraphic#init","Spine.Unity.BoundingBoxFollowerGraphic#Start","Spine.Unity.BoundingBoxFollowerGraphic#OnEnable","Spine.Unity.BoundingBoxFollowerGraphic#HandleRebuild","Spine.Unity.BoundingBoxFollowerGraphic#Initialize","Spine.Unity.BoundingBoxFollowerGraphic#AddCollidersForSkin","Spine.Unity.BoundingBoxFollowerGraphic#OnDisable","Spine.Unity.BoundingBoxFollowerGraphic#ClearState","Spine.Unity.BoundingBoxFollowerGraphic#DisposeExcessCollidersAfter","Spine.Unity.BoundingBoxFollowerGraphic#LateUpdate","Spine.Unity.BoundingBoxFollowerGraphic#MatchAttachment","Spine.Unity.DoubleBuffered$1#init","Spine.Unity.DoubleBuffered$1#GetCurrent","Spine.Unity.DoubleBuffered$1#GetNext","Spine.Unity.EventDataReferenceAsset#init","Spine.Unity.EventDataReferenceAsset#op_Implicit","Spine.Unity.EventDataReferenceAsset#EventData#get","Spine.Unity.EventDataReferenceAsset#Initialize","Spine.Unity.ISpineComponentExtensions#IsNullOrDestroyed","Spine.Unity.MaterialsTextureLoader#ctor","Spine.Unity.MaterialsTextureLoader#Load","Spine.Unity.MaterialsTextureLoader#Unload","Spine.Unity.MeshGenerator#init","Spine.Unity.MeshGenerator#GenerateSingleSubmeshInstruction","Spine.Unity.MeshGenerator#RequiresMultipleSubmeshesByDrawOrder","Spine.Unity.MeshGenerator#GenerateSkeletonRendererInstruction","Spine.Unity.MeshGenerator#TryReplaceMaterials","Spine.Unity.MeshGenerator#SolveTangents2DEnsureSize","Spine.Unity.MeshGenerator#SolveTangents2DTriangles","Spine.Unity.MeshGenerator#SolveTangents2DBuffer","Spine.Unity.MeshGenerator#FillMeshLocal$1","Spine.Unity.MeshGenerator#FillMeshLocal","Spine.Unity.MeshGenerator#VertexCount#get","Spine.Unity.MeshGenerator#Buffers#get","Spine.Unity.MeshGenerator#init","Spine.Unity.MeshGenerator#ctor","Spine.Unity.MeshGenerator#SubmeshIndexCount","Spine.Unity.MeshGenerator#Begin","Spine.Unity.MeshGenerator#AddSubmesh","Spine.Unity.MeshGenerator#BuildMesh","Spine.Unity.MeshGenerator#BuildMeshWithArrays","Spine.Unity.MeshGenerator#ScaleVertexData","Spine.Unity.MeshGenerator#GetMeshBounds","Spine.Unity.MeshGenerator#AddAttachmentTintBlack","Spine.Unity.MeshGenerator#FillVertexData","Spine.Unity.MeshGenerator#FillLateVertexData","Spine.Unity.MeshGenerator#FillTriangles","Spine.Unity.MeshGenerator#EnsureVertexCapacity","Spine.Unity.MeshGenerator#TrimExcess","Spine.Unity.MeshGenerator.Settings#Default#get","Spine.Unity.MeshGenerator.Settings#getDefaultValue","Spine.Unity.MeshGenerator.Settings#ctor","Spine.Unity.MeshGenerator.Settings#getHashCode","Spine.Unity.MeshGenerator.Settings#equals","Spine.Unity.MeshGenerator.Settings#$clone","Spine.Unity.MeshGeneratorBuffers#getDefaultValue","Spine.Unity.MeshGeneratorBuffers#ctor","Spine.Unity.MeshGeneratorBuffers#getHashCode","Spine.Unity.MeshGeneratorBuffers#equals","Spine.Unity.MeshGeneratorBuffers#$clone","Spine.Unity.MeshRendererBuffers#init","Spine.Unity.MeshRendererBuffers#Initialize","Spine.Unity.MeshRendererBuffers#GetUpdatedSharedMaterialsArray","Spine.Unity.MeshRendererBuffers#MaterialsChangedInLastUpdate","Spine.Unity.MeshRendererBuffers#UpdateSharedMaterials","Spine.Unity.MeshRendererBuffers#GetNextMesh","Spine.Unity.MeshRendererBuffers#Clear","Spine.Unity.MeshRendererBuffers#Dispose","Spine.Unity.MeshRendererBuffers.SmartMesh#init","Spine.Unity.MeshRendererBuffers.SmartMesh#Clear","Spine.Unity.MeshRendererBuffers.SmartMesh#Dispose","Spine.Unity.NoOpTextureLoader#Load","Spine.Unity.NoOpTextureLoader#Unload","Spine.Unity.RegionlessAttachmentLoader#EmptyRegion#get","Spine.Unity.RegionlessAttachmentLoader#NewRegionAttachment","Spine.Unity.RegionlessAttachmentLoader#NewMeshAttachment","Spine.Unity.RegionlessAttachmentLoader#NewBoundingBoxAttachment","Spine.Unity.RegionlessAttachmentLoader#NewPathAttachment","Spine.Unity.RegionlessAttachmentLoader#NewPointAttachment","Spine.Unity.RegionlessAttachmentLoader#NewClippingAttachment","Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance","Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance$1","Spine.Unity.SkeletonDataAsset#ReadSkeletonData","Spine.Unity.SkeletonDataAsset#ReadSkeletonData$1","Spine.Unity.SkeletonDataAsset#IsLoaded#get","Spine.Unity.SkeletonDataAsset#init","Spine.Unity.SkeletonDataAsset#Reset","Spine.Unity.SkeletonDataAsset#Clear","Spine.Unity.SkeletonDataAsset#GetAnimationStateData","Spine.Unity.SkeletonDataAsset#GetSkeletonData","Spine.Unity.SkeletonDataAsset#InitializeWithData","Spine.Unity.SkeletonDataAsset#FillStateData","Spine.Unity.SkeletonDataAsset#GetAtlasArray","Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo#DescriptionString","Spine.Unity.SkeletonExtensions#init","Spine.Unity.SkeletonExtensions#GetColor$2","Spine.Unity.SkeletonExtensions#GetColor$1","Spine.Unity.SkeletonExtensions#GetColor","Spine.Unity.SkeletonExtensions#GetColor$3","Spine.Unity.SkeletonExtensions#GetColorTintBlack","Spine.Unity.SkeletonExtensions#SetColor$4","Spine.Unity.SkeletonExtensions#SetColor$5","Spine.Unity.SkeletonExtensions#SetColor$6","Spine.Unity.SkeletonExtensions#SetColor$7","Spine.Unity.SkeletonExtensions#SetColor$2","Spine.Unity.SkeletonExtensions#SetColor$3","Spine.Unity.SkeletonExtensions#SetColor","Spine.Unity.SkeletonExtensions#SetColor$1","Spine.Unity.SkeletonExtensions#SetLocalScale","Spine.Unity.SkeletonExtensions#GetMatrix4x4","Spine.Unity.SkeletonExtensions#SetLocalPosition","Spine.Unity.SkeletonExtensions#SetLocalPosition$1","Spine.Unity.SkeletonExtensions#GetLocalPosition","Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition","Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition$1","Spine.Unity.SkeletonExtensions#GetWorldPosition","Spine.Unity.SkeletonExtensions#GetWorldPosition$1","Spine.Unity.SkeletonExtensions#GetWorldPosition$3","Spine.Unity.SkeletonExtensions#GetWorldPosition$2","Spine.Unity.SkeletonExtensions#GetQuaternion","Spine.Unity.SkeletonExtensions#GetLocalQuaternion","Spine.Unity.SkeletonExtensions#GetLocalScale","Spine.Unity.SkeletonExtensions#GetWorldToLocalMatrix","Spine.Unity.SkeletonExtensions#WorldToLocal","Spine.Unity.SkeletonExtensions#SetPositionSkeletonSpace","Spine.Unity.SkeletonExtensions#GetMaterial","Spine.Unity.SkeletonExtensions#GetLocalVertices","Spine.Unity.SkeletonExtensions#GetWorldVertices","Spine.Unity.SkeletonGraphicCustomMaterials#init","Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomMaterialOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomMaterialOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomTextureOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomTextureOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#OnEnable","Spine.Unity.SkeletonGraphicCustomMaterials#OnDisable","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#inherits","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getDefaultValue","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#ctor","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#equalsT","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getHashCode","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#$clone","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#inherits","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getDefaultValue","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#ctor","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#equalsT","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getHashCode","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#$clone","Spine.Unity.SkeletonMecanim.MecanimTranslator#init","Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime$1","Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#Animator#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerCount#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerNames#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#init","Spine.Unity.SkeletonMecanim.MecanimTranslator#addOnClipApplied","Spine.Unity.SkeletonMecanim.MecanimTranslator#removeOnClipApplied","Spine.Unity.SkeletonMecanim.MecanimTranslator#Initialize","Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyInterruptionAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator#OnClipAppliedCallback","Spine.Unity.SkeletonMecanim.MecanimTranslator#Apply","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetActiveAnimationAndTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#InitClipInfosForLayers","Spine.Unity.SkeletonMecanim.MecanimTranslator#ClearClipInfosForLayers","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetMixMode","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetStateUpdatesFromAnimator","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorClipInfos","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorStateInfos","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#equals2","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#getHashCode2","Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#equals2","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#getHashCode2","Spine.Unity.SkeletonRootMotionBase#UsesRigidbody#get","Spine.Unity.SkeletonRootMotionBase#AdditionalScale#get","Spine.Unity.SkeletonRootMotionBase#init","Spine.Unity.SkeletonRootMotionBase#Reset","Spine.Unity.SkeletonRootMotionBase#Start","Spine.Unity.SkeletonRootMotionBase#FixedUpdate","Spine.Unity.SkeletonRootMotionBase#OnDisable","Spine.Unity.SkeletonRootMotionBase#FindRigidbodyComponent","Spine.Unity.SkeletonRootMotionBase#SetRootMotionBone","Spine.Unity.SkeletonRootMotionBase#AdjustRootMotionToDistance","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion$1","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionInfo","Spine.Unity.SkeletonRootMotionBase#GetTimelineMovementDelta","Spine.Unity.SkeletonRootMotionBase#GetTimelineMovementDelta$1","Spine.Unity.SkeletonRootMotionBase#GatherTopLevelBones","Spine.Unity.SkeletonRootMotionBase#HandleUpdateLocal","Spine.Unity.SkeletonRootMotionBase#ApplyRootMotion","Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion","Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion$1","Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceMovementDelta","Spine.Unity.SkeletonRootMotionBase#SetEffectiveBoneOffsetsTo","Spine.Unity.SkeletonRootMotionBase#ClearEffectiveBoneOffsets","Spine.Unity.SkeletonPartsRenderer#NewPartsRendererGameObject","Spine.Unity.SkeletonPartsRenderer#MeshGenerator#get","Spine.Unity.SkeletonPartsRenderer#MeshRenderer#get","Spine.Unity.SkeletonPartsRenderer#MeshFilter#get","Spine.Unity.SkeletonPartsRenderer#init","Spine.Unity.SkeletonPartsRenderer#LazyIntialize","Spine.Unity.SkeletonPartsRenderer#ClearMesh","Spine.Unity.SkeletonPartsRenderer#RenderParts","Spine.Unity.SkeletonPartsRenderer#SetPropertyBlock","Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#AnyMaterialCreated#get","Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#init","Spine.Unity.SkeletonRendererCustomMaterials#init","Spine.Unity.SkeletonRendererCustomMaterials#SetCustomSlotMaterials","Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomSlotMaterials","Spine.Unity.SkeletonRendererCustomMaterials#SetCustomMaterialOverrides","Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomMaterialOverrides","Spine.Unity.SkeletonRendererCustomMaterials#OnEnable","Spine.Unity.SkeletonRendererCustomMaterials#OnDisable","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#inherits","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getDefaultValue","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#ctor","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#equalsT","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getHashCode","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#$clone","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#inherits","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getDefaultValue","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#ctor","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#equalsT","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getHashCode","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#$clone","Spine.Unity.SkeletonRendererInstruction#GeometryNotEqual","Spine.Unity.SkeletonRendererInstruction#init","Spine.Unity.SkeletonRendererInstruction#Clear","Spine.Unity.SkeletonRendererInstruction#Dispose","Spine.Unity.SkeletonRendererInstruction#SetWithSubset","Spine.Unity.SkeletonRendererInstruction#Set","Spine.Unity.SkeletonRenderSeparator#init","Spine.Unity.SkeletonRenderSeparator#AddToSkeletonRenderer","Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#get","Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#set","Spine.Unity.SkeletonRenderSeparator#init","Spine.Unity.SkeletonRenderSeparator#AddPartsRenderer","Spine.Unity.SkeletonRenderSeparator#OnEnable","Spine.Unity.SkeletonRenderSeparator#OnDisable","Spine.Unity.SkeletonRenderSeparator#HandleRender","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getDefaultValue","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#init","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#ctor","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getHashCode","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#equals","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#$clone","Spine.Unity.SkeletonSubmeshGraphic#SetMaterialDirty","Spine.Unity.SkeletonSubmeshGraphic#SetVerticesDirty","Spine.Unity.SkeletonSubmeshGraphic#OnPopulateMesh","Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject","Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject$1","Spine.Unity.SkeletonUtility#AddBoundingBoxAsComponent","Spine.Unity.SkeletonUtility#SetColliderPointsLocal","Spine.Unity.SkeletonUtility#GetBoundingBoxBounds","Spine.Unity.SkeletonUtility#AddBoneRigidbody2D","Spine.Unity.SkeletonUtility#SkeletonComponent#get","Spine.Unity.SkeletonUtility#Skeleton#get","Spine.Unity.SkeletonUtility#IsValid#get","Spine.Unity.SkeletonUtility#PositionScale#get","Spine.Unity.SkeletonUtility#init","Spine.Unity.SkeletonUtility#Update","Spine.Unity.SkeletonUtility#ResubscribeEvents","Spine.Unity.SkeletonUtility#OnEnable","Spine.Unity.SkeletonUtility#Start","Spine.Unity.SkeletonUtility#OnDisable","Spine.Unity.SkeletonUtility#HandleRendererReset$1","Spine.Unity.SkeletonUtility#HandleRendererReset","Spine.Unity.SkeletonUtility#RegisterBone","Spine.Unity.SkeletonUtility#UnregisterBone","Spine.Unity.SkeletonUtility#RegisterConstraint","Spine.Unity.SkeletonUtility#UnregisterConstraint","Spine.Unity.SkeletonUtility#CollectBones","Spine.Unity.SkeletonUtility#UpdateLocal","Spine.Unity.SkeletonUtility#UpdateWorld","Spine.Unity.SkeletonUtility#UpdateComplete","Spine.Unity.SkeletonUtility#UpdateAllBones","Spine.Unity.SkeletonUtility#GetBoneRoot","Spine.Unity.SkeletonUtility#SpawnRoot","Spine.Unity.SkeletonUtility#SpawnHierarchy","Spine.Unity.SkeletonUtility#SpawnBoneRecursively","Spine.Unity.SkeletonUtility#SpawnBone","Spine.Unity.SkeletonUtilityBone#BoneTransformModeIncompatible","Spine.Unity.SkeletonUtilityBone#IncompatibleTransformMode#get","Spine.Unity.SkeletonUtilityBone#init","Spine.Unity.SkeletonUtilityBone#Reset","Spine.Unity.SkeletonUtilityBone#OnEnable","Spine.Unity.SkeletonUtilityBone#HandleOnReset","Spine.Unity.SkeletonUtilityBone#OnDisable","Spine.Unity.SkeletonUtilityBone#DoUpdate","Spine.Unity.SkeletonUtilityBone#AddBoundingBox","Spine.Unity.SkeletonUtilityConstraint#OnEnable","Spine.Unity.SkeletonUtilityConstraint#OnDisable","Spine.Unity.SpineAttributeBase#init","Spine.Unity.SpineAtlasRegion#ctor","Spine.Unity.SpineAttachment.Hierarchy#getDefaultValue","Spine.Unity.SpineAttachment.Hierarchy#$ctor1","Spine.Unity.SpineAttachment.Hierarchy#ctor","Spine.Unity.SpineAttachment.Hierarchy#getHashCode","Spine.Unity.SpineAttachment.Hierarchy#equals","Spine.Unity.SpineAttachment.Hierarchy#$clone","Spine.Unity.SpineMesh#init","Spine.Unity.SpineMesh#NewSkeletonMesh","Spine.Unity.SubmeshInstruction#getDefaultValue","Spine.Unity.SubmeshInstruction#SlotCount#get","Spine.Unity.SubmeshInstruction#ctor","Spine.Unity.SubmeshInstruction#toString","Spine.Unity.SubmeshInstruction#getHashCode","Spine.Unity.SubmeshInstruction#equals","Spine.Unity.SubmeshInstruction#$clone","Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#get","Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#set","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$Current#get","Spine.Unity.WaitForSpineEvent#init","Spine.Unity.WaitForSpineEvent#ctor","Spine.Unity.WaitForSpineEvent#$ctor2","Spine.Unity.WaitForSpineEvent#$ctor1","Spine.Unity.WaitForSpineEvent#$ctor3","Spine.Unity.WaitForSpineEvent#Subscribe","Spine.Unity.WaitForSpineEvent#SubscribeByName","Spine.Unity.WaitForSpineEvent#HandleAnimationStateEventByName","Spine.Unity.WaitForSpineEvent#HandleAnimationStateEvent","Spine.Unity.WaitForSpineEvent#NowWaitFor","Spine.Unity.WaitForSpineEvent#NowWaitFor$1","Spine.Unity.WaitForSpineEvent#Clear","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$moveNext","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$reset","Spine.Unity.BlendModeMaterialsAsset#ApplyMaterials","Spine.Unity.BlendModeMaterialsAsset#init","Spine.Unity.BlendModeMaterialsAsset#Apply","Spine.Unity.SkeletonMecanimRootMotion#init","Spine.Unity.SkeletonMecanimRootMotion#SkeletonMecanim#get","Spine.Unity.SkeletonMecanimRootMotion#init","Spine.Unity.SkeletonMecanimRootMotion#GetRemainingRootMotion","Spine.Unity.SkeletonMecanimRootMotion#GetRootMotionInfo","Spine.Unity.SkeletonMecanimRootMotion#Reset","Spine.Unity.SkeletonMecanimRootMotion#Start","Spine.Unity.SkeletonMecanimRootMotion#OnClipApplied","Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsMovementDelta","Spine.Unity.SkeletonRootMotion#init","Spine.Unity.SkeletonRootMotion#AdditionalScale#get","Spine.Unity.SkeletonRootMotion#init","Spine.Unity.SkeletonRootMotion#GetRemainingRootMotion","Spine.Unity.SkeletonRootMotion#GetRootMotionInfo","Spine.Unity.SkeletonRootMotion#Reset","Spine.Unity.SkeletonRootMotion#Start","Spine.Unity.SkeletonRootMotion#CalculateAnimationsMovementDelta","Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta","Spine.Unity.SpineAnimation#ctor","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$1","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$2","Spine.Unity.SpineAtlasAsset#IsLoaded#get","Spine.Unity.SpineAtlasAsset#Materials#get","Spine.Unity.SpineAtlasAsset#MaterialCount#get","Spine.Unity.SpineAtlasAsset#PrimaryMaterial#get","Spine.Unity.SpineAtlasAsset#Reset","Spine.Unity.SpineAtlasAsset#Clear","Spine.Unity.SpineAtlasAsset#GetAtlas","Spine.Unity.SpineAtlasAsset#GenerateMesh","Spine.Unity.SpineAttachment#getHierarchy","Spine.Unity.SpineAttachment#getAttachment","Spine.Unity.SpineAttachment#getAttachment$1","Spine.Unity.SpineAttachment#init","Spine.Unity.SpineAttachment#ctor","Spine.Unity.SpineBone#getBone","Spine.Unity.SpineBone#getBoneData","Spine.Unity.SpineBone#ctor","Spine.Unity.SpineEvent#init","Spine.Unity.SpineEvent#ctor","Spine.Unity.SpineIkConstraint#ctor","Spine.Unity.SpinePathConstraint#ctor","Spine.Unity.SpineSkin#init","Spine.Unity.SpineSkin#ctor","Spine.Unity.SpineSlot#init","Spine.Unity.SpineSlot#ctor","Spine.Unity.SpineSpriteAtlasAsset#CreateRuntimeInstance","Spine.Unity.SpineSpriteAtlasAsset#AccessPackedTexture","Spine.Unity.SpineSpriteAtlasAsset#AccessPackedSprites","Spine.Unity.SpineSpriteAtlasAsset#IsLoaded#get","Spine.Unity.SpineSpriteAtlasAsset#Materials#get","Spine.Unity.SpineSpriteAtlasAsset#MaterialCount#get","Spine.Unity.SpineSpriteAtlasAsset#PrimaryMaterial#get","Spine.Unity.SpineSpriteAtlasAsset#Reset","Spine.Unity.SpineSpriteAtlasAsset#Clear","Spine.Unity.SpineSpriteAtlasAsset#GetAtlas","Spine.Unity.SpineSpriteAtlasAsset#AssignRegionsFromSavedRegions","Spine.Unity.SpineSpriteAtlasAsset#LoadAtlas","Spine.Unity.SpineTransformConstraint#ctor","Spine.Unity.AnimationReferenceAsset#init","Spine.Unity.AnimationReferenceAsset#op_Implicit","Spine.Unity.AnimationReferenceAsset#SkeletonDataAsset#get","Spine.Unity.AnimationReferenceAsset#Animation#get","Spine.Unity.AnimationReferenceAsset#Clear","Spine.Unity.AnimationReferenceAsset#Initialize","Spine.Unity.PointFollower#SkeletonRenderer#get","Spine.Unity.PointFollower#SkeletonComponent#get","Spine.Unity.PointFollower#IsValid#get","Spine.Unity.PointFollower#init","Spine.Unity.PointFollower#Initialize","Spine.Unity.PointFollower#HandleRebuildRenderer","Spine.Unity.PointFollower#UpdateReferences","Spine.Unity.PointFollower#OnDestroy","Spine.Unity.PointFollower#LateUpdate","Spine.Unity.SkeletonRenderer#init","Spine.Unity.SkeletonRenderer#NewSpineGameObject","Spine.Unity.SkeletonRenderer#AddSpineComponent","Spine.Unity.SkeletonRenderer#UpdateMode#get","Spine.Unity.SkeletonRenderer#UpdateMode#set","Spine.Unity.SkeletonRenderer#CustomMaterialOverride#get","Spine.Unity.SkeletonRenderer#CustomSlotMaterials#get","Spine.Unity.SkeletonRenderer#Skeleton#get","Spine.Unity.SkeletonRenderer#SkeletonDataAsset#get","Spine.Unity.SkeletonRenderer#init","Spine.Unity.SkeletonRenderer#addGenerateMeshOverride","Spine.Unity.SkeletonRenderer#removeGenerateMeshOverride","Spine.Unity.SkeletonRenderer#SetMeshSettings","Spine.Unity.SkeletonRenderer#Awake","Spine.Unity.SkeletonRenderer#OnDisable","Spine.Unity.SkeletonRenderer#OnDestroy","Spine.Unity.SkeletonRenderer#ClearState","Spine.Unity.SkeletonRenderer#EnsureMeshGeneratorCapacity","Spine.Unity.SkeletonRenderer#Initialize","Spine.Unity.SkeletonRenderer#LateUpdate","Spine.Unity.SkeletonRenderer#LateUpdateMesh","Spine.Unity.SkeletonRenderer#OnBecameVisible","Spine.Unity.SkeletonRenderer#OnBecameInvisible","Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots$1","Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots","Spine.Unity.SkeletonRenderer#ReapplySeparatorSlotNames","Spine.Unity.SkeletonRenderer#AssignSpriteMaskMaterials","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsInsideMask","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsOutsideMask","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsForMaskType","Spine.Unity.SkeletonRenderer#SetMaterialSettingsToFixDrawOrder","Spine.Unity.SkeletonGraphic#init","Spine.Unity.SkeletonGraphic#NewSkeletonGraphicGameObject","Spine.Unity.SkeletonGraphic#AddSkeletonGraphicComponent","Spine.Unity.SkeletonGraphic#SkeletonDataAsset#get","Spine.Unity.SkeletonGraphic#UpdateMode#get","Spine.Unity.SkeletonGraphic#UpdateMode#set","Spine.Unity.SkeletonGraphic#SeparatorParts#get","Spine.Unity.SkeletonGraphic#CustomTextureOverride#get","Spine.Unity.SkeletonGraphic#CustomMaterialOverride#get","Spine.Unity.SkeletonGraphic#OverrideTexture#get","Spine.Unity.SkeletonGraphic#OverrideTexture#set","Spine.Unity.SkeletonGraphic#mainTexture#get","Spine.Unity.SkeletonGraphic#Skeleton#get","Spine.Unity.SkeletonGraphic#Skeleton#set","Spine.Unity.SkeletonGraphic#SkeletonData#get","Spine.Unity.SkeletonGraphic#IsValid#get","Spine.Unity.SkeletonGraphic#AnimationState#get","Spine.Unity.SkeletonGraphic#MeshGenerator#get","Spine.Unity.SkeletonGraphic#init","Spine.Unity.SkeletonGraphic#Awake","Spine.Unity.SkeletonGraphic#OnDestroy","Spine.Unity.SkeletonGraphic#Rebuild","Spine.Unity.SkeletonGraphic#OnDisable","Spine.Unity.SkeletonGraphic#Update","Spine.Unity.SkeletonGraphic#Update$1","Spine.Unity.SkeletonGraphic#SyncSubmeshGraphicsWithCanvasRenderers","Spine.Unity.SkeletonGraphic#UpdateAnimationStatus","Spine.Unity.SkeletonGraphic#ApplyAnimation","Spine.Unity.SkeletonGraphic#LateUpdate","Spine.Unity.SkeletonGraphic#OnCullStateChanged","Spine.Unity.SkeletonGraphic#OnBecameVisible","Spine.Unity.SkeletonGraphic#OnBecameInvisible","Spine.Unity.SkeletonGraphic#ReapplySeparatorSlotNames","Spine.Unity.SkeletonGraphic#GetLastMesh","Spine.Unity.SkeletonGraphic#MatchRectTransformWithBounds","Spine.Unity.SkeletonGraphic#MatchRectTransformSingleRenderer","Spine.Unity.SkeletonGraphic#MatchRectTransformMultipleRenderers","Spine.Unity.SkeletonGraphic#SetRectTransformBounds","Spine.Unity.SkeletonGraphic#Clear","Spine.Unity.SkeletonGraphic#TrimRenderers","Spine.Unity.SkeletonGraphic#Initialize","Spine.Unity.SkeletonGraphic#UpdateMesh","Spine.Unity.SkeletonGraphic#HasMultipleSubmeshInstructions","Spine.Unity.SkeletonGraphic#InitMeshBuffers","Spine.Unity.SkeletonGraphic#DisposeMeshBuffers","Spine.Unity.SkeletonGraphic#UpdateMeshSingleCanvasRenderer","Spine.Unity.SkeletonGraphic#UpdateMeshMultipleCanvasRenderers","Spine.Unity.SkeletonGraphic#EnsureCanvasRendererCount","Spine.Unity.SkeletonGraphic#DisableUnusedCanvasRenderers","Spine.Unity.SkeletonGraphic#EnsureMeshesCount","Spine.Unity.SkeletonGraphic#DestroyMeshes","Spine.Unity.SkeletonGraphic#EnsureSeparatorPartCount","Spine.Unity.SkeletonGraphic#UpdateSeparatorPartParents","Spine.Unity.SkeletonAnimation#AddToGameObject","Spine.Unity.SkeletonAnimation#NewSkeletonAnimationGameObject","Spine.Unity.SkeletonAnimation#AnimationState#get","Spine.Unity.SkeletonAnimation#AnimationName#get","Spine.Unity.SkeletonAnimation#AnimationName#set","Spine.Unity.SkeletonAnimation#init","Spine.Unity.SkeletonAnimation#addBeforeApply","Spine.Unity.SkeletonAnimation#removeBeforeApply","Spine.Unity.SkeletonAnimation#addUpdateLocal","Spine.Unity.SkeletonAnimation#removeUpdateLocal","Spine.Unity.SkeletonAnimation#addUpdateWorld","Spine.Unity.SkeletonAnimation#removeUpdateWorld","Spine.Unity.SkeletonAnimation#addUpdateComplete","Spine.Unity.SkeletonAnimation#removeUpdateComplete","Spine.Unity.SkeletonAnimation#ClearState","Spine.Unity.SkeletonAnimation#Initialize","Spine.Unity.SkeletonAnimation#Update$1","Spine.Unity.SkeletonAnimation#Update","Spine.Unity.SkeletonAnimation#UpdateAnimationStatus","Spine.Unity.SkeletonAnimation#ApplyAnimation","Spine.Unity.SkeletonAnimation#LateUpdate","Spine.Unity.SkeletonAnimation#OnBecameVisible","Spine.Unity.SkeletonMecanim#Translator#get","Spine.Unity.SkeletonMecanim#init","Spine.Unity.SkeletonMecanim#addBeforeApply","Spine.Unity.SkeletonMecanim#removeBeforeApply","Spine.Unity.SkeletonMecanim#addUpdateLocal","Spine.Unity.SkeletonMecanim#removeUpdateLocal","Spine.Unity.SkeletonMecanim#addUpdateWorld","Spine.Unity.SkeletonMecanim#removeUpdateWorld","Spine.Unity.SkeletonMecanim#addUpdateComplete","Spine.Unity.SkeletonMecanim#removeUpdateComplete","Spine.Unity.SkeletonMecanim#Initialize","Spine.Unity.SkeletonMecanim#Update","Spine.Unity.SkeletonMecanim#ApplyAnimation","Spine.Unity.SkeletonMecanim#LateUpdate","Spine.Unity.SkeletonMecanim#OnBecameVisible"]' ) ); }
/**
 * @version 1.0.9320.33395
 * @copyright anton
 * @compiler Bridge.NET 17.9.42-luna
 */
Bridge.assembly("UnityScriptsCompiler", function ($asm, globals) {
    "use strict";

    /*DG.Tweening.DOTweenCYInstruction start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction");
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get", this ); }

                    return this.t.active && !DG.Tweening.TweenExtensions.IsComplete(this.t);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null,
            elapsedLoops: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get", this ); }

                    return this.t.active && DG.Tweening.TweenExtensions.CompletedLoops(this.t) < this.elapsedLoops;
                }
            }
        },
        ctors: {
            ctor: function (tween, elapsedLoops) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.elapsedLoops = elapsedLoops;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForKill", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get", this ); }

                    return this.t.active;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForPosition", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null,
            position: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get", this ); }

                    return this.t.active && this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) < this.position;
                }
            }
        },
        ctors: {
            ctor: function (tween, position) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.position = position;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForRewind", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get", this ); }

                    return this.t.active && (!this.t.playedOnce || this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) > 0);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForStart", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get", this ); }

                    return this.t.active && !this.t.playedOnce;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleAudio start.*/
    Bridge.define("DG.Tweening.DOTweenModuleAudio", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleAudio.DOFade:static start.*/
                /**
                 * Tweens an AudioSource's volume to the given value.
                 Also stores the AudioSource as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.AudioSource}           target      
                 * @param   {number}                            endValue    The end value to reach (0 to 1)
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOFade", this ); }

                    if (endValue < 0) {
                        endValue = 0;
                    } else {
                        if (endValue > 1) {
                            endValue = 1;
                        }
                    }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.volume;
                    }, function (x) {
                        target.volume = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPitch:static start.*/
                /**
                 * Tweens an AudioSource's pitch to the given value.
                 Also stores the AudioSource as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.AudioSource}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPitch: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPitch", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.pitch;
                    }, function (x) {
                        target.pitch = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPitch:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOSetFloat:static start.*/
                /**
                 * Tweens an AudioMixer's exposed float to the given value.
                 Also stores the AudioMixer as the tween's target so it can be used for filtered operations.
                 Note that you need to manually expose a float in an AudioMixerGroup in order to be able to tween it from an AudioMixer.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}      target       
                 * @param   {string}                            floatName    Name given to the exposed float to set
                 * @param   {number}                            endValue     The end value to reach
                 * @param   {number}                            duration     The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOSetFloat: function (target, floatName, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOSetFloat", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        var currVal = { };
                        target.GetFloat(floatName, currVal);
                        return currVal.v;
                    }, function (x) {
                        target.SetFloat(floatName, x);
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOSetFloat:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOComplete:static start.*/
                /**
                 * Completes all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens completed
                 (meaning the tweens that don't have infinite loops and were not already complete)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target           
                 * @param   {boolean}                         withCallbacks    For Sequences only: if TRUE also internal Sequence callbacks will be fired,
                 otherwise they will be ignored
                 * @return  {number}
                 */
                DOComplete: function (target, withCallbacks) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOComplete", this ); }

                    if (withCallbacks === void 0) { withCallbacks = false; }
                    return DG.Tweening.DOTween.Complete(target, withCallbacks);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOComplete:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOKill:static start.*/
                /**
                 * Kills all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens killed.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target      
                 * @param   {boolean}                         complete    If TRUE completes the tween before killing it
                 * @return  {number}
                 */
                DOKill: function (target, complete) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOKill", this ); }

                    if (complete === void 0) { complete = false; }
                    return DG.Tweening.DOTween.Kill(target, complete);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOKill:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOFlip:static start.*/
                /**
                 * Flips the direction (backwards if it was going forward or viceversa) of all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens flipped.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOFlip: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOFlip", this ); }

                    return DG.Tweening.DOTween.Flip(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOFlip:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOGoto:static start.*/
                /**
                 * Sends to the given position all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens involved.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target     
                 * @param   {number}                          to         Time position to reach
                 (if higher than the whole tween duration the tween will simply reach its end)
                 * @param   {boolean}                         andPlay    If TRUE will play the tween after reaching the given position, otherwise it will pause it
                 * @return  {number}
                 */
                DOGoto: function (target, to, andPlay) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOGoto", this ); }

                    if (andPlay === void 0) { andPlay = false; }
                    return DG.Tweening.DOTween.Goto(target, to, andPlay);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOGoto:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPause:static start.*/
                /**
                 * Pauses all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens paused.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPause: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPause", this ); }

                    return DG.Tweening.DOTween.Pause(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPause:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlay:static start.*/
                /**
                 * Plays all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlay: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlay", this ); }

                    return DG.Tweening.DOTween.Play(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlay:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlayBackwards:static start.*/
                /**
                 * Plays backwards all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlayBackwards: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlayBackwards", this ); }

                    return DG.Tweening.DOTween.PlayBackwards(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlayBackwards:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlayForward:static start.*/
                /**
                 * Plays forward all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlayForward: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlayForward", this ); }

                    return DG.Tweening.DOTween.PlayForward(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlayForward:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DORestart:static start.*/
                /**
                 * Restarts all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens restarted.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DORestart: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DORestart", this ); }

                    return DG.Tweening.DOTween.Restart(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DORestart:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DORewind:static start.*/
                /**
                 * Rewinds all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens rewinded.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DORewind: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DORewind", this ); }

                    return DG.Tweening.DOTween.Rewind(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DORewind:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOSmoothRewind:static start.*/
                /**
                 * Smoothly rewinds all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens rewinded.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOSmoothRewind: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOSmoothRewind", this ); }

                    return DG.Tweening.DOTween.SmoothRewind(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOSmoothRewind:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOTogglePause:static start.*/
                /**
                 * Toggles the paused state (plays if it was paused, pauses if it was playing) of all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens involved.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOTogglePause: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOTogglePause", this ); }

                    return DG.Tweening.DOTween.TogglePause(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOTogglePause:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleAudio end.*/

    /*DG.Tweening.DOTweenModulePhysics start.*/
    Bridge.define("DG.Tweening.DOTweenModulePhysics", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModulePhysics.DOMove:static start.*/
                /**
                 * Tweens a Rigidbody's position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMove: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMove", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMove:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveX:static start.*/
                /**
                 * Tweens a Rigidbody's X position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveX:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveY:static start.*/
                /**
                 * Tweens a Rigidbody's Y position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveY:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveZ:static start.*/
                /**
                 * Tweens a Rigidbody's Z position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveZ:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DORotate:static start.*/
                /**
                 * Tweens a Rigidbody's rotation to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {DG.Tweening.RotateMode}            mode        Rotation mode
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DORotate: function (target, endValue, duration, mode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DORotate", this ); }

                    if (mode === void 0) { mode = 0; }
                    var t = DG.Tweening.DOTween.To$9(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), t, target);
                    t.plugOptions.rotateMode = mode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DORotate:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLookAt:static start.*/
                /**
                 * Tweens a Rigidbody's rotation so that it will look towards the given position.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target            
                 * @param   {UnityEngine.Vector3}               towards           The position to look at
                 * @param   {number}                            duration          The duration of the tween
                 * @param   {DG.Tweening.AxisConstraint}        axisConstraint    Eventual axis constraint for the rotation
                 * @param   {?UnityEngine.Vector3}              up                The vector that defines in which direction up is (default: Vector3.up)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLookAt: function (target, towards, duration, axisConstraint, up) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLookAt", this ); }

                    if (axisConstraint === void 0) { axisConstraint = 0; }
                    if (up === void 0) { up = null; }
                    var t = DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.DOTween.To$9(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), towards.$clone(), duration), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetLookAt);
                    t.plugOptions.axisConstraint = axisConstraint;
                    t.plugOptions.up = (pc.Vec3.equals( up, null )) ? pc.Vec3.UP.clone() : System.Nullable.getValue(up);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLookAt:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOJump:static start.*/
                /**
                 * Tweens a Rigidbody's position to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}    target       
                 * @param   {UnityEngine.Vector3}      endValue     The end value to reach
                 * @param   {number}                   jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                   numJumps     Total number of jumps
                 * @param   {number}                   duration     The duration of the tween
                 * @param   {boolean}                  snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJump: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOJump", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, jumpPower, 0 ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.position.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( endValue.x, 0, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, 0, endValue.z ), duration), DG.Tweening.AxisConstraint.Z, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Tween, yTween, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = target.position.$clone();
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedPercentage(yTween), DG.Tweening.Ease.OutQuad);
                        target.MovePosition(pos);
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOJump:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOPath:static start.*/
                /**
                 * Tweens a Rigidbody's position through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations.
                 <p>NOTE: to tween a rigidbody correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target        
                 * @param   {Array.<UnityEngine.Vector3>}       path          The waypoints to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path (useless in case of Linear paths): higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOPath$1:static start.*/
                DOPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), path, duration), target);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOPath$1:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath:static start.*/
                /**
                 * Tweens a Rigidbody's localPosition through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations
                 <p>NOTE: to tween a rigidbody correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOLocalPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target        
                 * @param   {Array.<UnityEngine.Vector3>}       path          The waypoint to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path: higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLocalPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath$1:static start.*/
                DOLocalPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLocalPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, path, duration), target);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath$1:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModulePhysics end.*/

    /*DG.Tweening.DOTweenModulePhysics2D start.*/
    Bridge.define("DG.Tweening.DOTweenModulePhysics2D", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModulePhysics2D.DOMove:static start.*/
                /**
                 * Tweens a Rigidbody2D's position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMove: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMove", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMove:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveX:static start.*/
                /**
                 * Tweens a Rigidbody2D's X position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMoveX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveX:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveY:static start.*/
                /**
                 * Tweens a Rigidbody2D's Y position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMoveY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveY:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DORotate:static start.*/
                /**
                 * Tweens a Rigidbody2D's rotation to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DORotate: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DORotate", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DORotate:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOJump:static start.*/
                /**
                 * Tweens a Rigidbody2D's position to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations.
                 <p>IMPORTANT: a rigidbody2D can't be animated in a jump arc using MovePosition, so the tween will directly set the position</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}    target       
                 * @param   {UnityEngine.Vector2}        endValue     The end value to reach
                 * @param   {number}                     jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                     numJumps     Total number of jumps
                 * @param   {number}                     duration     The duration of the tween
                 * @param   {boolean}                    snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJump: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOJump", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec2( 0, jumpPower ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.position.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec2( endValue.x, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Tween, yTween, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = UnityEngine.Vector3.FromVector2(target.position.$clone());
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedPercentage(yTween), DG.Tweening.Ease.OutQuad);
                        target.MovePosition$1(pos);
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOJump:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOPath:static start.*/
                /**
                 * Tweens a Rigidbody2D's position through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations.
                 <p>NOTE: to tween a Rigidbody2D correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target        
                 * @param   {Array.<UnityEngine.Vector2>}       path          The waypoints to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path (useless in case of Linear paths): higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var len = path.length;
                    var path3D = System.Array.init(len, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        path3D[i] = UnityEngine.Vector3.FromVector2(path[i].$clone());
                    }
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return UnityEngine.Vector3.FromVector2(target.position);
                    }, function (x) {
                        target.MovePosition$1(x);
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path3D, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOPath$1:static start.*/
                DOPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return UnityEngine.Vector3.FromVector2(target.position);
                    }, function (x) {
                        target.MovePosition$1(x);
                    }, path, duration), target);

                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOPath$1:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath:static start.*/
                /**
                 * Tweens a Rigidbody2D's localPosition through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 <p>NOTE: to tween a Rigidbody2D correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOLocalPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target        
                 * @param   {Array.<UnityEngine.Vector2>}       path          The waypoint to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path: higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOLocalPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var len = path.length;
                    var path3D = System.Array.init(len, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        path3D[i] = UnityEngine.Vector3.FromVector2(path[i].$clone());
                    }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition$1(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path3D, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath$1:static start.*/
                DOLocalPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOLocalPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition$1(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, path, duration), target);

                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath$1:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModulePhysics2D end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    Bridge.define("DG.Tweening.DOTweenModuleSprite", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color to the given value.
                 Also stores the spriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}        target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOFade:static start.*/
                /**
                 * Tweens a Material's alpha color to the given value.
                 Also stores the spriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}        target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOFade", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}    target      
                 * @param   {pc.ColorGradient}              gradient    The gradient to use
                 * @param   {number}                        duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleSprite.DOColor(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the SpriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}    target      
                 * @param   {UnityEngine.Color}             endValue    The value to tween to
                 * @param   {number}                        duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI.DOFade:static start.*/
                /**
                 * Tweens a CanvasGroup's alpha color to the given value.
                 Also stores the canvasGroup as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.CanvasGroup}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.alpha;
                    }, function (x) {
                        target.alpha = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static start.*/
                /**
                 * Tweens an Graphic's alpha color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}            target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$1", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static start.*/
                /**
                 * Tweens an Image's alpha color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$2", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static start.*/
                /**
                 * Tweens a Outline's effectColor alpha to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$3", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.effectColor;
                    }, function (x) {
                        target.effectColor = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$4:static start.*/
                /**
                 * Tweens a Text's alpha color to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$4: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$4", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$4:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor:static start.*/
                /**
                 * Tweens an Graphic's color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}            target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static start.*/
                /**
                 * Tweens an Image's color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$1", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static start.*/
                /**
                 * Tweens a Outline's effectColor to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$2", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.effectColor;
                    }, function (x) {
                        target.effectColor = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$3:static start.*/
                /**
                 * Tweens a Text's color to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$3", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static start.*/
                /**
                 * Tweens an Image's fillAmount to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {number}                            endValue    The end value to reach (0 to 1)
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFillAmount: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFillAmount", this ); }

                    if (endValue > 1) {
                        endValue = 1;
                    } else {
                        if (endValue < 0) {
                            endValue = 0;
                        }
                    }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.fillAmount;
                    }, function (x) {
                        target.fillAmount = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static start.*/
                /**
                 * Tweens an Image's colors using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleUI.DOColor$1(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static start.*/
                /**
                 * Tweens an LayoutElement's flexibleWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFlexibleSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFlexibleSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.flexibleWidth, target.flexibleHeight );
                    }, function (x) {
                        target.flexibleWidth = x.x;
                        target.flexibleHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static start.*/
                /**
                 * Tweens an LayoutElement's minWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMinSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOMinSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.minWidth, target.minHeight );
                    }, function (x) {
                        target.minWidth = x.x;
                        target.minHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static start.*/
                /**
                 * Tweens an LayoutElement's preferredWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPreferredSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPreferredSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.preferredWidth, target.preferredHeight );
                    }, function (x) {
                        target.preferredWidth = x.x;
                        target.preferredHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOScale:static start.*/
                /**
                 * Tweens a Outline's effectDistance to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOScale: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOScale", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.effectDistance;
                    }, function (x) {
                        target.effectDistance = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOScale:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPosX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPosY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3D: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3D", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D Z to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static start.*/
                /**
                 * Tweens a RectTransform's anchorMax to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorMax: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMax", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMax;
                    }, function (x) {
                        target.anchorMax = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static start.*/
                /**
                 * Tweens a RectTransform's anchorMin to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorMin: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMin", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMin;
                    }, function (x) {
                        target.anchorMin = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivot:static start.*/
                /**
                 * Tweens a RectTransform's pivot to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivot: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivot", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivot:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static start.*/
                /**
                 * Tweens a RectTransform's pivot X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivotX: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotX", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static start.*/
                /**
                 * Tweens a RectTransform's pivot Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivotY: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotY", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static start.*/
                /**
                 * Tweens a RectTransform's sizeDelta to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOSizeDelta: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOSizeDelta", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.sizeDelta;
                    }, function (x) {
                        target.sizeDelta = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static start.*/
                /**
                 * Punches a RectTransform's anchoredPosition towards the given direction and then back to the starting one
                 as if it was connected to the starting position via an elastic.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target        
                 * @param   {UnityEngine.Vector2}          punch         The direction and strength of the punch (added to the RectTransform's current position)
                 * @param   {number}                       duration      The duration of the tween
                 * @param   {number}                       vibrato       Indicates how much will the punch vibrate
                 * @param   {number}                       elasticity    Represents how much (0 to 1) the vector will go beyond the starting position when bouncing backwards.
                 1 creates a full oscillation between the punch direction and the opposite direction,
                 while 0 oscillates only between the punch and the start position
                 * @param   {boolean}                      snapping      If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOPunchAnchorPos: function (target, punch, duration, vibrato, elasticity, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (elasticity === void 0) { elasticity = 1.0; }
                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Punch(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, UnityEngine.Vector3.FromVector2(punch.$clone()), duration, vibrato, elasticity), target), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static start.*/
                /**
                 * Shakes a RectTransform's anchoredPosition with the given values.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}          target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {number}                             strength          The shake strength
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
                 Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            snapping          If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeAnchorPos: function (target, duration, strength, vibrato, randomness, snapping, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos", this ); }

                    if (strength === void 0) { strength = 100.0; }
                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, strength, vibrato, randomness, true, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static start.*/
                /**
                 * Shakes a RectTransform's anchoredPosition with the given values.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}          target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {UnityEngine.Vector2}                strength          The shake strength on each axis
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
                 Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            snapping          If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeAnchorPos$1: function (target, duration, strength, vibrato, randomness, snapping, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake$1(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, UnityEngine.Vector3.FromVector2(strength.$clone()), vibrato, randomness, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target       
                 * @param   {UnityEngine.Vector2}          endValue     The end value to reach
                 * @param   {number}                       jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                       numJumps     Total number of jumps
                 * @param   {number}                       duration     The duration of the tween
                 * @param   {boolean}                      snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJumpAnchorPos: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;

                    // Separate Y Tween so we can elaborate elapsedPercentage on that insted of on the Sequence
                    // (in case users add a delay or other elements to the Sequence)
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0, jumpPower ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.anchoredPosition.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue.x, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Sequence, s, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = target.anchoredPosition.$clone();
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedDirectionalPercentage(s), DG.Tweening.Ease.OutQuad);
                        target.anchoredPosition = pos.$clone();
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's horizontal/verticalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {UnityEngine.Vector2}          endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DONormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DONormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.horizontalNormalizedPosition, target.verticalNormalizedPosition );
                    }, function (x) {
                        target.horizontalNormalizedPosition = x.x;
                        target.verticalNormalizedPosition = x.y;
                    }, endValue.$clone(), duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's horizontalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {number}                       endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOHorizontalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.horizontalNormalizedPosition;
                    }, function (x) {
                        target.horizontalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's verticalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {number}                       endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOVerticalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.verticalNormalizedPosition;
                    }, function (x) {
                        target.verticalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOValue:static start.*/
                /**
                 * Tweens a Slider's value to the given value.
                 Also stores the Slider as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Slider}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOValue: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOValue", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.value;
                    }, function (x) {
                        target.value = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOValue:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOCounter:static start.*/
                /**
                 * Tweens a Text's text from one integer to another, with options for thousands separators
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}                 target                   
                 * @param   {number}                              fromValue                The value to start from
                 * @param   {number}                              endValue                 The end value to reach
                 * @param   {number}                              duration                 The duration of the tween
                 * @param   {boolean}                             addThousandsSeparator    If TRUE (default) also adds thousands separators
                 * @param   {System.Globalization.CultureInfo}    culture                  The {@link } to use (InvariantCulture if NULL)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOCounter: function (target, fromValue, endValue, duration, addThousandsSeparator, culture) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOCounter", this ); }

                    if (addThousandsSeparator === void 0) { addThousandsSeparator = true; }
                    if (culture === void 0) { culture = null; }
                    var v = fromValue;
                    var cInfo = !addThousandsSeparator ? null : culture || System.Globalization.CultureInfo.invariantCulture;
                    var t = DG.Tweening.DOTween.To$2(function () {
                        return v;
                    }, function (x) {
                        v = x;
                        target.text = addThousandsSeparator ? System.Int32.format(v, "N0", cInfo) : Bridge.toString(v);
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOCounter:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOText:static start.*/
                /**
                 * Tweens a Text's text to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target             
                 * @param   {string}                            endValue           The end string to tween to
                 * @param   {number}                            duration           The duration of the tween
                 * @param   {boolean}                           richTextEnabled    If TRUE (default), rich text will be interpreted correctly while animated,
                 otherwise all tags will be considered as normal text
                 * @param   {DG.Tweening.ScrambleMode}          scrambleMode       The type of scramble mode to use, if any
                 * @param   {string}                            scrambleChars      A string containing the characters to use for scrambling.
                 Use as many characters as possible (minimum 10) because DOTween uses a fast scramble mode which gives better results with more characters.
                 Leave it to NULL (default) to use default ones
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOText: function (target, endValue, duration, richTextEnabled, scrambleMode, scrambleChars) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOText", this ); }

                    if (richTextEnabled === void 0) { richTextEnabled = true; }
                    if (scrambleMode === void 0) { scrambleMode = 0; }
                    if (scrambleChars === void 0) { scrambleChars = null; }
                    if (endValue == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogWarning("You can't pass a NULL string to DOText: an empty string will be used instead to avoid errors");
                        }
                        endValue = "";
                    }
                    var t = DG.Tweening.DOTween.To$5(function () {
                        return target.text;
                    }, function (x) {
                        target.text = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$3(t, richTextEnabled, scrambleMode, scrambleChars), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOText:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static start.*/
                /**
                 * Tweens a Graphic's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Graphic as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}    target      
                 * @param   {UnityEngine.Color}         endValue    The value to tween to
                 * @param   {number}                    duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static start.*/
                /**
                 * Tweens a Image's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}    target      
                 * @param   {UnityEngine.Color}       endValue    The value to tween to
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$1", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static start.*/
                /**
                 * Tweens a Text's color BY the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}    target      
                 * @param   {UnityEngine.Color}      endValue    The value to tween to
                 * @param   {number}                 duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$2", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShapeCircle:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition so that it draws a circle around the given center.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations.<p />
                 IMPORTANT: SetFrom(value) requires a {@link } instead of a float, where the X property represents the "from degrees value"
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target             
                 * @param   {UnityEngine.Vector2}               center             Circle-center/pivot around which to rotate (in UI anchoredPosition coordinates)
                 * @param   {number}                            endValueDegrees    The end value degrees to reach (to rotate counter-clockwise pass a negative value)
                 * @param   {number}                            duration           The duration of the tween
                 * @param   {boolean}                           relativeCenter     If TRUE the {@link } coordinates will be considered as relative to the target's current anchoredPosition
                 * @param   {boolean}                           snapping           If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOShapeCircle: function (target, center, endValueDegrees, duration, relativeCenter, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShapeCircle", this ); }

                    if (relativeCenter === void 0) { relativeCenter = false; }
                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To(UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.CircleOptions, DG.Tweening.Plugins.CirclePlugin.Get(), function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, center.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$7(t, endValueDegrees, relativeCenter, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOShapeCircle:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI.Utils", {
        $kind: 1002,
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static start.*/
                /**
                 * Converts the anchoredPosition of the first RectTransform to the second RectTransform,
                 taking into consideration offset, anchors and pivot, and returns the new anchoredPosition
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI.Utils
                 * @memberof DG.Tweening.DOTweenModuleUI.Utils
                 * @param   {UnityEngine.RectTransform}    from    
                 * @param   {UnityEngine.RectTransform}    to
                 * @return  {UnityEngine.Vector2}
                 */
                SwitchToRectTransform: function (from, to) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform", this ); }

                    var localPoint = { v : new UnityEngine.Vector2() };
                    var fromPivotDerivedOffset = new pc.Vec2( from.rect.width * 0.5 + from.rect.xMin, from.rect.height * 0.5 + from.rect.yMin );
                    var screenP = UnityEngine.RectTransformUtility.WorldToScreenPoint(null, from.position);
                    screenP = screenP.$clone().add( fromPivotDerivedOffset.$clone() );
                    UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(to, screenP, null, localPoint);
                    var pivotDerivedOffset = new pc.Vec2( to.rect.width * 0.5 + to.rect.xMin, to.rect.height * 0.5 + to.rect.yMin );
                    return to.anchoredPosition.$clone().add( localPoint.v ).sub( pivotDerivedOffset );
                },
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    /** @namespace DG.Tweening */

    /**
     * Shortcuts/functions that are not strictly related to specific Modules
     but are available only on some Unity versions
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOTweenModuleUnityVersion
     */
    Bridge.define("DG.Tweening.DOTweenModuleUnityVersion", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static start.*/
                /**
                 * Tweens a Material's color using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$3(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static start.*/
                /**
                 * Tweens a Material's named color property using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {string}                  property    The name of the material property to tween (like _Tint or _SpecColor)
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor$1: function (target, gradient, property, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.SetColor$1(property, c.color);
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$4(target, c.color.$clone(), property, colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or complete.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForCompletion(true);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForCompletion: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForCompletion(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or rewinded.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForRewind();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForRewind: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForRewind(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForKill();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForKill: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForKill", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForKill(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or has gone through the given amount of loops.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForElapsedLoops(2);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {number}                                elapsedLoops                    Elapsed loops to wait for
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForElapsedLoops: function (t, elapsedLoops, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops(t, elapsedLoops);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed
                 or has reached the given time position (loops included, delays excluded).
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForPosition(2.5f);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {number}                                position                        Position (loops included, delays excluded) to wait for
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForPosition: function (t, position, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForPosition(t, position);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or started
                 (meaning when the tween is set in a playing state the first time, after any eventual delay).
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForStart();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForStart: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForStart", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForStart(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static start.*/
                /**
                 * Tweens a Material's named texture offset property with the given ID to the given value.
                 Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector2}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOOffset: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOOffset", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureOffset(propertyID);
                    }, function (x) {
                        target.SetTextureOffset(propertyID, x);
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static start.*/
                /**
                 * Tweens a Material's named texture scale property with the given ID to the given value.
                 Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector2}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOTiling: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOTiling", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureScale(propertyID);
                    }, function (x) {
                        target.SetTextureScale(propertyID, x);
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    /**
     * Utility functions that deal with available Modules.
     Modules defines:
     - DOTAUDIO
     - DOTPHYSICS
     - DOTPHYSICS2D
     - DOTSPRITE
     - DOTUI
     Extra defines set and used for implementation of external assets:
     - DOTWEEN_TMP ► TextMesh Pro
     - DOTWEEN_TK2D ► 2D Toolkit
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOTweenModuleUtils
     */
    Bridge.define("DG.Tweening.DOTweenModuleUtils", {
        statics: {
            fields: {
                _initialized: false
            },
            methods: {
                /*DG.Tweening.DOTweenModuleUtils.Init:static start.*/
                /**
                 * Called via Reflection by DOTweenComponent on Awake
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUtils
                 * @memberof DG.Tweening.DOTweenModuleUtils
                 * @return  {void}
                 */
                Init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Init", this ); }

                    if (DG.Tweening.DOTweenModuleUtils._initialized) {
                        return;
                    }

                    DG.Tweening.DOTweenModuleUtils._initialized = true;
                    DG.Tweening.Core.DOTweenExternalCommand.addSetOrientationOnPath(DG.Tweening.DOTweenModuleUtils.Physics.SetOrientationOnPath);

                },
                /*DG.Tweening.DOTweenModuleUtils.Init:static end.*/

                /*DG.Tweening.DOTweenModuleUtils.Preserver:static start.*/
                Preserver: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Preserver", this ); }

                    var loadedAssemblies = System.AppDomain.getAssemblies();
                    var mi = Bridge.Reflection.getMembers(UnityEngine.MonoBehaviour, 8, 284, "Stub");
                },
                /*DG.Tweening.DOTweenModuleUtils.Preserver:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUtils.Physics", {
        $kind: 1002,
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static start.*/
                SetOrientationOnPath: function (options, t, newRot, trans) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath", this ); }

                    if (options.isRigidbody) {
                        Bridge.cast(t.target, UnityEngine.Rigidbody).rotation = newRot.$clone();
                    } else {
                        trans.rotation = newRot.$clone();
                    }
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static start.*/
                HasRigidbody2D: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D", this ); }

                    return UnityEngine.Component.op_Inequality(target.GetComponent(UnityEngine.Rigidbody2D), null);
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static start.*/
                HasRigidbody: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody", this ); }

                    return UnityEngine.Component.op_Inequality(target.GetComponent(UnityEngine.Rigidbody), null);
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static start.*/
                CreateDOTweenPathTween: function (target, tweenRigidbody, isLocal, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween", this ); }

                    var t = null;
                    var rBodyFoundAndTweened = false;
                    if (tweenRigidbody) {
                        var rBody = target.GetComponent(UnityEngine.Rigidbody);
                        if (UnityEngine.Component.op_Inequality(rBody, null)) {
                            rBodyFoundAndTweened = true;
                            t = isLocal ? DG.Tweening.DOTweenModulePhysics.DOLocalPath$1(rBody, path, duration, pathMode) : DG.Tweening.DOTweenModulePhysics.DOPath$1(rBody, path, duration, pathMode);
                        }
                    }
                    if (!rBodyFoundAndTweened && tweenRigidbody) {
                        var rBody2D = target.GetComponent(UnityEngine.Rigidbody2D);
                        if (UnityEngine.Component.op_Inequality(rBody2D, null)) {
                            rBodyFoundAndTweened = true;
                            t = isLocal ? DG.Tweening.DOTweenModulePhysics2D.DOLocalPath$1(rBody2D, path, duration, pathMode) : DG.Tweening.DOTweenModulePhysics2D.DOPath$1(rBody2D, path, duration, pathMode);
                        }
                    }
                    if (!rBodyFoundAndTweened) {
                        t = isLocal ? DG.Tweening.ShortcutExtensions.DOLocalPath(target.transform, path, duration, pathMode) : DG.Tweening.ShortcutExtensions.DOPath(target.transform, path, duration, pathMode);
                    }
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    /*Do.AudioManager start.*/
    Bridge.define("Do.AudioManager", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                KEY_SOUND: null,
                KEY_MUSIC: null,
                KEY_VIBRATION: null,
                instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Do.AudioManager#init", this ); }

                    this.KEY_SOUND = "KEY_SOUND";
                    this.KEY_MUSIC = "KEY_MUSIC";
                    this.KEY_VIBRATION = "KEY_VIBRATION";
                }
            }
        },
        fields: {
            musicClipSource: null,
            soundClipSource: null,
            /**
             * @instance
             * @private
             * @readonly
             * @memberof Do.AudioManager
             * @type System.Collections.Generic.Dictionary$2
             */
            _dictionaryMusic: null,
            _dictionarySound: null,
            _dictionarySoundDuration: null,
            _dictionarySoundTimes: null,
            _sound: false,
            _music: false,
            _vibration: false
        },
        props: {
            Sound: {
                get: function () {
if ( TRACE ) { TRACE( "Do.AudioManager#Sound#get", this ); }

                    return this._sound;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Do.AudioManager#Sound#set", this ); }

                    this._sound = value;
                    //  MyPref.SetBool(KEY_SOUND, _sound);
                    this.SetSoundMute();
                }
            },
            Music: {
                get: function () {
if ( TRACE ) { TRACE( "Do.AudioManager#Music#get", this ); }

                    return this._music;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Do.AudioManager#Music#set", this ); }

                    this._music = value;
                    //    MyPref.SetBool(KEY_MUSIC, _music);
                    this.SetMusicMute();
                }
            },
            Vibration: {
                get: function () {
if ( TRACE ) { TRACE( "Do.AudioManager#Vibration#get", this ); }

                    return this._vibration;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Do.AudioManager#Vibration#set", this ); }

                    this._vibration = value;
                    //   MyPref.SetBool(KEY_VIBRATION, _vibration);
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Do.AudioManager#init", this ); }

                this._dictionaryMusic = new (System.Collections.Generic.Dictionary$2(MusicType,System.Int32)).ctor();
                this._dictionarySound = new (System.Collections.Generic.Dictionary$2(SoundType,System.Int32)).ctor();
                this._dictionarySoundDuration = new (System.Collections.Generic.Dictionary$2(SoundType,System.Single)).ctor();
                this._dictionarySoundTimes = new (System.Collections.Generic.Dictionary$2(SoundType,System.Single)).ctor();
            }
        },
        methods: {
            /*Do.AudioManager.Awake start.*/
            /**
             * @instance
             * @protected
             * @this Do.AudioManager
             * @memberof Do.AudioManager
             * @return  {void}
             */
            Awake: function () {
if ( TRACE ) { TRACE( "Do.AudioManager#Awake", this ); }


                if (UnityEngine.MonoBehaviour.op_Equality(Do.AudioManager.instance, null)) {
                    Do.AudioManager.instance = this;
                }
                this.InitBoolean();
                this.InitSource();
                this.SetMusicMute();
                this.SetSoundMute();
            },
            /*Do.AudioManager.Awake end.*/

            /*Do.AudioManager.InitBoolean start.*/
            InitBoolean: function () {
if ( TRACE ) { TRACE( "Do.AudioManager#InitBoolean", this ); }

                // Sound = MyPref.GetBool(KEY_SOUND, true);
                //  Music = MyPref.GetBool(KEY_MUSIC, true);
                //Vibration = MyPref.GetBool(KEY_VIBRATION, true);
                this.Sound = true;
                this.Music = true;
                this.Vibration = true;

            },
            /*Do.AudioManager.InitBoolean end.*/

            /*Do.AudioManager.InitSource start.*/
            InitSource: function () {
if ( TRACE ) { TRACE( "Do.AudioManager#InitSource", this ); }

                var $t, $t1;
                $t = Bridge.getEnumerator(this.musicClipSource);
                try {
                    while ($t.moveNext()) {
                        var music = $t.Current;
                        this._dictionaryMusic.add(music.musicType, 0);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.soundClipSource);
                try {
                    while ($t1.moveNext()) {
                        var sound = $t1.Current;
                        this._dictionarySound.add(sound.soundType, 0);
                        this._dictionarySoundDuration.add(sound.soundType, sound.duration);
                        this._dictionarySoundTimes.add(sound.soundType, 0.0);
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
            },
            /*Do.AudioManager.InitSource end.*/

            /*Do.AudioManager.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Do.AudioManager#Update", this ); }

                // var deltaTime = Time.unscaledDeltaTime;
                // var listSoundTime = _dictionarySoundTimes.ToList();
                // foreach (var item in listSoundTime)
                // {
                //     var time = item.Value;
                //     if (time <= 0)
                //         continue;
                //     time -= deltaTime;
                //     if (time < 0)
                //         time = 0;
                //     _dictionarySoundTimes[item.Key] = time;
                // }
            },
            /*Do.AudioManager.Update end.*/

            /*Do.AudioManager.SetMusicMute start.*/
            SetMusicMute: function () {
if ( TRACE ) { TRACE( "Do.AudioManager#SetMusicMute", this ); }

                //      musicSource.UnMute = Music;
            },
            /*Do.AudioManager.SetMusicMute end.*/

            /*Do.AudioManager.SetSoundMute start.*/
            SetSoundMute: function () {
if ( TRACE ) { TRACE( "Do.AudioManager#SetSoundMute", this ); }

                //      soundSourceCache.UnMute = Sound;
                // foreach (var soundSource in listSoundSourcePools)
                // {
                //     soundSource.UnMute = Sound;
                // }
            },
            /*Do.AudioManager.SetSoundMute end.*/

            /*Do.AudioManager.Play start.*/
            Play: function (musicType) {
if ( TRACE ) { TRACE( "Do.AudioManager#Play", this ); }

                //BundledObjectLoader.Instance.LoadObjectFromFile(_dictionaryMusic[musicType], obj =>
                //{
                //    musicSource.Play(obj as AudioClip);
                //});
                this.StopMusic();
                //  musicSource.Play(_dictionaryMusic[musicType]);
            },
            /*Do.AudioManager.Play end.*/

            /*Do.AudioManager.Play$1 start.*/
            Play$1: function (soundType) {
if ( TRACE ) { TRACE( "Do.AudioManager#Play$1", this ); }

                if (!this._dictionarySound.containsKey(soundType)) {
                    return;
                }
                if (this._dictionarySoundTimes.getItem(soundType) > 0) {
                    return;
                }
                // GetAudioSourceInSourcePool().PlayOneShot(_dictionarySound[soundType]);
                this._dictionarySoundTimes.setItem(soundType, this._dictionarySoundDuration.getItem(soundType));
            },
            /*Do.AudioManager.Play$1 end.*/

            /*Do.AudioManager.PlayCache start.*/
            PlayCache: function (soundType) {
if ( TRACE ) { TRACE( "Do.AudioManager#PlayCache", this ); }

                // if (soundSourceCache.IsPlaying)
                //     soundSourceCache.Stop(true);
                // soundSourceCache.PlayOneShot(_dictionarySound[soundType]);
            },
            /*Do.AudioManager.PlayCache end.*/

            /*Do.AudioManager.StopMusic start.*/
            StopMusic: function () {
if ( TRACE ) { TRACE( "Do.AudioManager#StopMusic", this ); }

                // if (musicSource.IsPlaying)
                //     musicSource.Stop();
            },
            /*Do.AudioManager.StopMusic end.*/

            /*Do.AudioManager.StopSound start.*/
            StopSound: function () {
if ( TRACE ) { TRACE( "Do.AudioManager#StopSound", this ); }

                //  soundSourceCache.Stop();
                // foreach (var soundSource in listSoundSourcePools.Where(soundSource => soundSource.IsPlaying))
                // {
                //     soundSource.Stop();
                // }
            },
            /*Do.AudioManager.StopSound end.*/

            /*Do.AudioManager.StopAll start.*/
            StopAll: function () {
if ( TRACE ) { TRACE( "Do.AudioManager#StopAll", this ); }

                this.StopMusic();
                this.StopSound();
            },
            /*Do.AudioManager.StopAll end.*/


        },
        overloads: {
            "Play(SoundType)": "Play$1"
        }
    });
    /*Do.AudioManager end.*/

    /*Do.AudioMusic start.*/
    Bridge.define("Do.AudioMusic", {
        fields: {
            musicType: 0
        }
    });
    /*Do.AudioMusic end.*/

    /*Do.AudioSound start.*/
    Bridge.define("Do.AudioSound", {
        fields: {
            soundType: 0,
            duration: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Do.AudioSound#init", this ); }

                this.duration = 0.1;
            }
        }
    });
    /*Do.AudioSound end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    Bridge.define("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", {
        inherits: [UnityEngine.MonoBehaviour]
    });
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*LunaManager start.*/
    Bridge.define("LunaManager", {
        inherits: [UnityEngine.MonoBehaviour],
        methods: {
            /*LunaManager.OnPlayButtonClick start.*/
            OnPlayButtonClick: function () {
if ( TRACE ) { TRACE( "LunaManager#OnPlayButtonClick", this ); }

                UnityEngine.Debug.Log$1("Play");
                Luna.Unity.Playable.InstallFullGame();
                Luna.Unity.LifeCycle.GameEnded();
            },
            /*LunaManager.OnPlayButtonClick end.*/

            /*LunaManager.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "LunaManager#OnEnable", this ); }

                Luna.Unity.LifeCycle.addOnPause(Bridge.fn.cacheBind(this, this.PauseGameplay));
                Luna.Unity.LifeCycle.addOnResume(Bridge.fn.cacheBind(this, this.ResumeGameplay));
            },
            /*LunaManager.OnEnable end.*/

            /*LunaManager.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "LunaManager#OnDisable", this ); }

                Luna.Unity.LifeCycle.removeOnPause(Bridge.fn.cacheBind(this, this.PauseGameplay));
                Luna.Unity.LifeCycle.removeOnResume(Bridge.fn.cacheBind(this, this.ResumeGameplay));
            },
            /*LunaManager.OnDisable end.*/

            /*LunaManager.ResumeGameplay start.*/
            ResumeGameplay: function () {
if ( TRACE ) { TRACE( "LunaManager#ResumeGameplay", this ); }

                UnityEngine.Time.timeScale = 1.0;
            },
            /*LunaManager.ResumeGameplay end.*/

            /*LunaManager.PauseGameplay start.*/
            PauseGameplay: function () {
if ( TRACE ) { TRACE( "LunaManager#PauseGameplay", this ); }

                UnityEngine.Time.timeScale = 0;
            },
            /*LunaManager.PauseGameplay end.*/


        }
    });
    /*LunaManager end.*/

    /*MusicType start.*/
    Bridge.define("MusicType", {
        $kind: 6,
        statics: {
            fields: {
                Home: 0,
                Gameplay: 1
            }
        }
    });
    /*MusicType end.*/

    /*NutType start.*/
    Bridge.define("NutType", {
        $kind: 6,
        statics: {
            fields: {
                Normal: 0,
                Star: 1,
                Square: 2
            }
        }
    });
    /*NutType end.*/

    /*ScreenType start.*/
    Bridge.define("ScreenType", {
        $kind: 6,
        statics: {
            fields: {
                Horizontal: 0,
                Vertical: 1
            }
        }
    });
    /*ScreenType end.*/

    /*SoundType start.*/
    Bridge.define("SoundType", {
        $kind: 6,
        statics: {
            fields: {
                Click_UI: 0,
                Coin_Collect: 1,
                Nut_Go_To_Screw: 2,
                Nut_Out_Of_Screw: 3,
                Complete_Holder_1: 4,
                Complete_Holder_2: 5,
                Complete_Holder_3: 6,
                Hard_Level: 7,
                Very_Hard_Level: 8,
                Bomb_Explore: 9,
                Bomb_Defuse: 10,
                Booster_Fill: 11,
                Booster_Add_Holder: 12,
                Update_Progress: 13,
                Undo_Move: 14,
                Glass_Break: 15,
                Show_Hidden: 16,
                Holder_Close: 17,
                Ice_Break: 18,
                Rope_Cut: 19,
                Rope_Reject: 20,
                Use_Booster: 21,
                Done_Progress: 22,
                Firework: 23,
                Win: 24,
                Lose: 25,
                Island_Build: 26,
                Island_Complete_1: 27,
                Island_Complete_2: 28,
                Feature_Anounce: 29
            }
        }
    });
    /*SoundType end.*/

    /*Spine.BoneMatrix start.*/
    Bridge.define("Spine.BoneMatrix", {
        $kind: 4,
        statics: {
            methods: {
                /*Spine.BoneMatrix.CalculateSetupWorld:static start.*/
                /**
                 * Recursively calculates a worldspace bone matrix based on BoneData.
                 *
                 * @static
                 * @public
                 * @this Spine.BoneMatrix
                 * @memberof Spine.BoneMatrix
                 * @param   {spine.BoneData}      boneData
                 * @return  {Spine.BoneMatrix}
                 */
                CalculateSetupWorld: function (boneData) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#CalculateSetupWorld", this ); }

                    if (boneData == null) {
                        return Bridge.getDefaultValue(Spine.BoneMatrix);
                    }

                    // End condition: isRootBone
                    if (boneData.parent == null) {
                        return Spine.BoneMatrix.GetInheritedInternal(boneData, Bridge.getDefaultValue(Spine.BoneMatrix));
                    }

                    var result = Spine.BoneMatrix.CalculateSetupWorld(boneData.parent);
                    return Spine.BoneMatrix.GetInheritedInternal(boneData, result.$clone());
                },
                /*Spine.BoneMatrix.CalculateSetupWorld:static end.*/

                /*Spine.BoneMatrix.GetInheritedInternal:static start.*/
                GetInheritedInternal: function (boneData, parentMatrix) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#GetInheritedInternal", this ); }

                    var parent = boneData.parent;
                    if (parent == null) {
                        return new Spine.BoneMatrix.$ctor2(boneData);
                    } // isRootBone

                    var pa = parentMatrix.a, pb = parentMatrix.b, pc = parentMatrix.c, pd = parentMatrix.d;
                    var result = Bridge.getDefaultValue(Spine.BoneMatrix);
                    result.x = pa * boneData.x + pb * boneData.y + parentMatrix.x;
                    result.y = pc * boneData.x + pd * boneData.y + parentMatrix.y;

                    switch (boneData.transformMode) {
                        case spine.BoneData.Normal: 
                            {
                                var rotationY = boneData.rotation + 90 + boneData.shearY;
                                var la = Spine.MathUtils.CosDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                var lb = Spine.MathUtils.CosDeg(rotationY) * boneData.scaleY;
                                var lc = Spine.MathUtils.SinDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                var ld = Spine.MathUtils.SinDeg(rotationY) * boneData.scaleY;
                                result.a = pa * la + pb * lc;
                                result.b = pa * lb + pb * ld;
                                result.c = pc * la + pd * lc;
                                result.d = pc * lb + pd * ld;
                                break;
                            }
                        case spine.BoneData.OnlyTranslation: 
                            {
                                var rotationY1 = boneData.rotation + 90 + boneData.shearY;
                                result.a = Spine.MathUtils.CosDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                result.b = Spine.MathUtils.CosDeg(rotationY1) * boneData.scaleY;
                                result.c = Spine.MathUtils.SinDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                result.d = Spine.MathUtils.SinDeg(rotationY1) * boneData.scaleY;
                                break;
                            }
                        case spine.BoneData.NoRotationOrReflection: 
                            {
                                var s = pa * pa + pc * pc, prx;
                                if (s > 0.0001) {
                                    s = Math.abs(pa * pd - pb * pc) / s;
                                    pb = pc * s;
                                    pd = pa * s;
                                    prx = Spine.MathUtils.Atan2(pc, pa) * Spine.MathUtils.RadDeg;
                                } else {
                                    pa = 0;
                                    pc = 0;
                                    prx = 90 - Spine.MathUtils.Atan2(pd, pb) * Spine.MathUtils.RadDeg;
                                }
                                var rx = boneData.rotation + boneData.shearX - prx;
                                var ry = boneData.rotation + boneData.shearY - prx + 90;
                                var la1 = Spine.MathUtils.CosDeg(rx) * boneData.scaleX;
                                var lb1 = Spine.MathUtils.CosDeg(ry) * boneData.scaleY;
                                var lc1 = Spine.MathUtils.SinDeg(rx) * boneData.scaleX;
                                var ld1 = Spine.MathUtils.SinDeg(ry) * boneData.scaleY;
                                result.a = pa * la1 - pb * lc1;
                                result.b = pa * lb1 - pb * ld1;
                                result.c = pc * la1 + pd * lc1;
                                result.d = pc * lb1 + pd * ld1;
                                break;
                            }
                        case spine.BoneData.NoScale: 
                        case spine.BoneData.NoScaleOrReflection: 
                            {
                                var cos = Spine.MathUtils.CosDeg(boneData.rotation), sin = Spine.MathUtils.SinDeg(boneData.rotation);
                                var za = pa * cos + pb * sin;
                                var zc = pc * cos + pd * sin;
                                var s1 = Math.sqrt(za * za + zc * zc);
                                if (s1 > 1E-05) {
                                    s1 = 1 / s1;
                                }
                                za *= s1;
                                zc *= s1;
                                s1 = Math.sqrt(za * za + zc * zc);
                                var r = 1.57079637 + Spine.MathUtils.Atan2(zc, za);
                                var zb = Spine.MathUtils.Cos(r) * s1;
                                var zd = Spine.MathUtils.Sin(r) * s1;
                                var la2 = Spine.MathUtils.CosDeg(boneData.shearX) * boneData.scaleX;
                                var lb2 = Spine.MathUtils.CosDeg(90 + boneData.shearY) * boneData.scaleY;
                                var lc2 = Spine.MathUtils.SinDeg(boneData.shearX) * boneData.scaleX;
                                var ld2 = Spine.MathUtils.SinDeg(90 + boneData.shearY) * boneData.scaleY;
                                if (boneData.transformMode !== spine.BoneData.NoScaleOrReflection ? pa * pd - pb * pc < 0 : false) {
                                    zb = -zb;
                                    zd = -zd;
                                }
                                result.a = za * la2 + zb * lc2;
                                result.b = za * lb2 + zb * ld2;
                                result.c = zc * la2 + zd * lc2;
                                result.d = zc * lb2 + zd * ld2;
                                break;
                            }
                    }

                    return result.$clone();
                },
                /*Spine.BoneMatrix.GetInheritedInternal:static end.*/

                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#getDefaultValue", this ); }
 return new Spine.BoneMatrix(); }
            }
        },
        fields: {
            a: 0,
            b: 0,
            c: 0,
            d: 0,
            x: 0,
            y: 0
        },
        ctors: {
            /**
             * Constructor for a local bone matrix based on Setup Pose BoneData.
             *
             * @instance
             * @public
             * @this Spine.BoneMatrix
             * @memberof Spine.BoneMatrix
             * @param   {spine.BoneData}    boneData
             * @return  {void}
             */
            $ctor2: function (boneData) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$ctor2", this ); }

                this.$initialize();
                var rotationY = boneData.rotation + 90 + boneData.shearY;
                var rotationX = boneData.rotation + boneData.shearX;

                this.a = Spine.MathUtils.CosDeg(rotationX) * boneData.scaleX;
                this.c = Spine.MathUtils.SinDeg(rotationX) * boneData.scaleX;
                this.b = Spine.MathUtils.CosDeg(rotationY) * boneData.scaleY;
                this.d = Spine.MathUtils.SinDeg(rotationY) * boneData.scaleY;
                this.x = boneData.x;
                this.y = boneData.y;
            },
            /**
             * Constructor for a local bone matrix based on a bone instance's current pose.
             *
             * @instance
             * @public
             * @this Spine.BoneMatrix
             * @memberof Spine.BoneMatrix
             * @param   {Spine.Bone}    bone
             * @return  {void}
             */
            $ctor1: function (bone) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$ctor1", this ); }

                this.$initialize();
                var rotationY = bone.rotation + 90 + bone.shearY;
                var rotationX = bone.rotation + bone.shearX;

                this.a = Spine.MathUtils.CosDeg(rotationX) * bone.scaleX;
                this.c = Spine.MathUtils.SinDeg(rotationX) * bone.scaleX;
                this.b = Spine.MathUtils.CosDeg(rotationY) * bone.scaleY;
                this.d = Spine.MathUtils.SinDeg(rotationY) * bone.scaleY;
                this.x = bone.x;
                this.y = bone.y;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.BoneMatrix.TransformMatrix start.*/
            TransformMatrix: function (local) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#TransformMatrix", this ); }

                var $t;
                return ($t = new Spine.BoneMatrix.ctor(), $t.a = this.a * local.a + this.b * local.c, $t.b = this.a * local.b + this.b * local.d, $t.c = this.c * local.a + this.d * local.c, $t.d = this.c * local.b + this.d * local.d, $t.x = this.a * local.x + this.b * local.y + this.x, $t.y = this.c * local.x + this.d * local.y + this.y, $t);
            },
            /*Spine.BoneMatrix.TransformMatrix end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#getHashCode", this ); }

                var h = Bridge.addHash([3621996792, this.a, this.b, this.c, this.d, this.x, this.y]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#equals", this ); }

                if (!Bridge.is(o, Spine.BoneMatrix)) {
                    return false;
                }
                return Bridge.equals(this.a, o.a) && Bridge.equals(this.b, o.b) && Bridge.equals(this.c, o.c) && Bridge.equals(this.d, o.d) && Bridge.equals(this.x, o.x) && Bridge.equals(this.y, o.y);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$clone", this ); }

                var s = to || new Spine.BoneMatrix();
                s.a = this.a;
                s.b = this.b;
                s.c = this.c;
                s.d = this.d;
                s.x = this.x;
                s.y = this.y;
                return s;
            }
        }
    });
    /*Spine.BoneMatrix end.*/

    /*Spine.SpineSkeletonExtensions start.*/
    Bridge.define("Spine.SpineSkeletonExtensions", {
        statics: {
            methods: {
                /*Spine.SpineSkeletonExtensions.IsWeighted:static start.*/
                IsWeighted: function (va) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#IsWeighted", this ); }

                    return va.bones != null && va.bones.length > 0;
                },
                /*Spine.SpineSkeletonExtensions.IsWeighted:static end.*/

                /*Spine.SpineSkeletonExtensions.InheritsRotation:static start.*/
                InheritsRotation: function (mode) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#InheritsRotation", this ); }

                    var RotationBit = 0;
                    return (System.Int64(mode).and(System.Int64((1)))).equals(System.Int64(0));
                },
                /*Spine.SpineSkeletonExtensions.InheritsRotation:static end.*/

                /*Spine.SpineSkeletonExtensions.InheritsScale:static start.*/
                InheritsScale: function (mode) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#InheritsScale", this ); }

                    var ScaleBit = 1;
                    return (System.Int64(mode).and(System.Int64((2)))).equals(System.Int64(0));
                },
                /*Spine.SpineSkeletonExtensions.InheritsScale:static end.*/


            }
        }
    });
    /*Spine.SpineSkeletonExtensions end.*/

    /*Spine.Unity.ActivateBasedOnFlipDirection start.*/
    /** @namespace Spine.Unity */

    /**
     * Utility component to support flipping of 2D hinge chains (chains of HingeJoint2D objects) along
     with the parent skeleton by activating the respective mirrored versions of the hinge chain.
     Note: This component is automatically attached when calling "Create Hinge Chain 2D" at {@link },
     do not attempt to use this component for other purposes.
     *
     * @public
     * @class Spine.Unity.ActivateBasedOnFlipDirection
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.ActivateBasedOnFlipDirection", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            skeletonGraphic: null,
            activeOnNormalX: null,
            activeOnFlippedX: null,
            jointsNormalX: null,
            jointsFlippedX: null,
            skeletonComponent: null,
            wasFlippedXBefore: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#init", this ); }

                this.wasFlippedXBefore = false;
            }
        },
        methods: {
            /*Spine.Unity.ActivateBasedOnFlipDirection.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#Start", this ); }

                this.jointsNormalX = this.activeOnNormalX.GetComponentsInChildren(UnityEngine.HingeJoint2D);
                this.jointsFlippedX = this.activeOnFlippedX.GetComponentsInChildren(UnityEngine.HingeJoint2D);
                this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? Bridge.cast(this.skeletonRenderer, Spine.Unity.ISkeletonComponent) : Bridge.cast(this.skeletonGraphic, Spine.Unity.ISkeletonComponent);
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.Start end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#FixedUpdate", this ); }

                var isFlippedX = (this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.scaleX < 0);
                if (isFlippedX !== this.wasFlippedXBefore) {
                    this.HandleFlip(isFlippedX);
                }
                this.wasFlippedXBefore = isFlippedX;
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.FixedUpdate end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.HandleFlip start.*/
            HandleFlip: function (isFlippedX) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#HandleFlip", this ); }

                var gameObjectToActivate = isFlippedX ? this.activeOnFlippedX : this.activeOnNormalX;
                var gameObjectToDeactivate = isFlippedX ? this.activeOnNormalX : this.activeOnFlippedX;

                gameObjectToActivate.SetActive(true);
                gameObjectToDeactivate.SetActive(false);

                this.ResetJointPositions(isFlippedX ? this.jointsFlippedX : this.jointsNormalX);
                this.ResetJointPositions(isFlippedX ? this.jointsNormalX : this.jointsFlippedX);
                this.CompensateMovementAfterFlipX(gameObjectToActivate.transform, gameObjectToDeactivate.transform);
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.HandleFlip end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.ResetJointPositions start.*/
            ResetJointPositions: function (joints) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#ResetJointPositions", this ); }

                for (var i = 0; i < joints.length; i = (i + 1) | 0) {
                    var joint = joints[i];
                    var parent = joint.connectedBody.transform;
                    joint.transform.position = parent.TransformPoint$1(UnityEngine.Vector3.FromVector2(joint.connectedAnchor));
                }
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.ResetJointPositions end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.CompensateMovementAfterFlipX start.*/
            CompensateMovementAfterFlipX: function (toActivate, toDeactivate) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#CompensateMovementAfterFlipX", this ); }

                var targetLocation = toDeactivate.GetChild(0);
                var currentLocation = toActivate.GetChild(0);
                toActivate.position = toActivate.position.$clone().add( targetLocation.position.$clone().sub( currentLocation.position ) );
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.CompensateMovementAfterFlipX end.*/


        }
    });
    /*Spine.Unity.ActivateBasedOnFlipDirection end.*/

    /*Spine.Unity.ISpineComponent start.*/
    Bridge.define("Spine.Unity.ISpineComponent", {
        $kind: 3
    });
    /*Spine.Unity.ISpineComponent end.*/

    /*Spine.Unity.AnimationTools.TimelineExtensions start.*/
    Bridge.define("Spine.Unity.AnimationTools.TimelineExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate:static start.*/
                /**
                 * Evaluates the resulting value of a TranslateTimeline at a given time.
                 SkeletonData can be accessed from Skeleton.Data or from SkeletonDataAsset.GetSkeletonData.
                 If no SkeletonData is given, values are returned as difference to setup pose
                 instead of absolute values.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.TranslateTimeline}    timeline        
                 * @param   {number}                     time            
                 * @param   {Spine.SkeletonData}         skeletonData
                 * @return  {UnityEngine.Vector2}
                 */
                Evaluate: function (timeline, time, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#Evaluate", this ); }

                    var $t, $t1;
                    if (skeletonData === void 0) { skeletonData = null; }
                    if (time < ($t = timeline.frames)[0]) {
                        return pc.Vec2.ZERO.clone();
                    }

                    var x = { }, y = { };
                    timeline.getCurveValue(x, y, time);

                    if (skeletonData == null) {
                        return new pc.Vec2( x.v, y.v );
                    } else {
                        var boneData = ($t1 = skeletonData.Bones.Items)[timeline.boneIndex];
                        return new pc.Vec2( boneData.x + x.v, boneData.y + y.v );
                    }
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1:static start.*/
                /**
                 * Evaluates the resulting value of a pair of split translate timelines at a given time.
                 SkeletonData can be accessed from Skeleton.Data or from SkeletonDataAsset.GetSkeletonData.
                 If no SkeletonData is given, values are returned as difference to setup pose
                 instead of absolute values.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.TranslateXTimeline}    xTimeline       
                 * @param   {spine.TranslateYTimeline}    yTimeline       
                 * @param   {number}                      time            
                 * @param   {Spine.SkeletonData}          skeletonData
                 * @return  {UnityEngine.Vector2}
                 */
                Evaluate$1: function (xTimeline, yTimeline, time, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$1", this ); }

                    var $t, $t1;
                    if (skeletonData === void 0) { skeletonData = null; }

                    var x = 0, y = 0;
                    if (xTimeline != null && time > ($t = xTimeline.frames)[0]) {
                        x = xTimeline.getCurveValue(time);
                    }
                    if (yTimeline != null && time > ($t1 = yTimeline.frames)[0]) {
                        y = yTimeline.getCurveValue(time);
                    }

                    if (skeletonData == null) {
                        return new pc.Vec2( x, y );
                    } else {
                        var bonesItems = skeletonData.Bones.Items;
                        var boneDataX = bonesItems[xTimeline.boneIndex];
                        var boneDataY = bonesItems[yTimeline.boneIndex];
                        return new pc.Vec2( boneDataX.x + x, boneDataY.y + y );
                    }
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone:static start.*/
                /**
                 * Gets the translate timeline for a given boneIndex.
                 You can get the boneIndex using SkeletonData.FindBoneIndex.
                 The root bone is always boneIndex 0.
                 This will return null if a TranslateTimeline is not found.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Spine.Animation}            a            
                 * @param   {number}                     boneIndex
                 * @return  {spine.TranslateTimeline}
                 */
                FindTranslateTimelineForBone: function (a, boneIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#FindTranslateTimelineForBone", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(a.Timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            if ((Bridge.getType(timeline).prototype instanceof spine.TranslateTimeline)) {
                                continue;
                            }

                            var translateTimeline = Bridge.as(timeline, spine.TranslateTimeline);
                            if (translateTimeline != null && translateTimeline.boneIndex === boneIndex) {
                                return translateTimeline;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone:static start.*/
                /**
                 * Gets the IBoneTimeline timeline of a given type for a given boneIndex.
                 You can get the boneIndex using SkeletonData.FindBoneIndex.
                 The root bone is always boneIndex 0.
                 This will return null if a timeline of the given type is not found.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Function}           T            
                 * @param   {Spine.Animation}    a            
                 * @param   {number}             boneIndex
                 * @return  {T}
                 */
                FindTimelineForBone: function (T, a, boneIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#FindTimelineForBone", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(a.Timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            var translateTimeline = Bridge.as(timeline, T);
                            if (Bridge.rValue(translateTimeline) != null && Bridge.rValue(translateTimeline).Spine$IBoneTimeline$BoneIndex === boneIndex) {
                                return Bridge.rValue(translateTimeline);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone:static end.*/


            }
        }
    });
    /*Spine.Unity.AnimationTools.TimelineExtensions end.*/

    /*Spine.Unity.AtlasAssetBase start.*/
    Bridge.define("Spine.Unity.AtlasAssetBase", {
        inherits: [UnityEngine.ScriptableObject]
    });
    /*Spine.Unity.AtlasAssetBase end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AtlasUtilities", {
        statics: {
            fields: {
                SpineTextureFormat: 0,
                DefaultMipmapBias: 0,
                UseMipMaps: false,
                DefaultScale: 0,
                NonrenderingRegion: 0,
                existingRegions: null,
                regionIndices: null,
                originalRegions: null,
                repackedRegions: null,
                texturesToPackAtParam: null,
                inoutAttachments: null,
                CachedRegionTextures: null,
                CachedRegionTexturesList: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#init", this ); }

                    this.SpineTextureFormat = UnityEngine.TextureFormat.RGBA32;
                    this.DefaultMipmapBias = -0.5;
                    this.UseMipMaps = false;
                    this.DefaultScale = 0.01;
                    this.NonrenderingRegion = -1;
                    this.existingRegions = new (System.Collections.Generic.Dictionary$2(Spine.AtlasRegion,System.Int32)).ctor();
                    this.regionIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    this.originalRegions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();
                    this.repackedRegions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();
                    this.texturesToPackAtParam = System.Array.init(1, null, System.Collections.Generic.List$1(UnityEngine.Texture2D));
                    this.inoutAttachments = new (System.Collections.Generic.List$1(spine.Attachment)).ctor();
                    this.CachedRegionTextures = new (System.Collections.Generic.Dictionary$2(Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey,UnityEngine.Texture2D)).ctor();
                    this.CachedRegionTexturesList = new (System.Collections.Generic.List$1(UnityEngine.Texture2D)).ctor();
                }
            },
            methods: {
                /*Spine.Unity.AttachmentTools.AtlasUtilities.Init:static start.*/
                Init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#Init", this ); }

                    // handle disabled domain reload
                    Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.Init:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$2:static start.*/
                ToAtlasRegion$2: function (t, materialPropertySource, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$2", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3(t, materialPropertySource.shader, scale, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$2:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3:static start.*/
                ToAtlasRegion$3: function (t, shader, scale, materialPropertySource) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$3", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }

                    material.mainTexture = t;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);

                    var width = t.width;
                    var height = t.height;

                    var region = new Spine.AtlasRegion();
                    region.name = t.name;

                    // World space units
                    var boundsMin = pc.Vec2.ZERO.clone(), boundsMax = new pc.Vec2( width, height ).scale( scale );

                    // Texture space/pixel units
                    region.width = Bridge.Int.clip32(width);
                    region.originalWidth = Bridge.Int.clip32(width);
                    region.height = Bridge.Int.clip32(height);
                    region.originalHeight = Bridge.Int.clip32(height);
                    region.offsetX = width * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.x, boundsMax.x, 0));
                    region.offsetY = height * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.y, boundsMax.y, 0));

                    // Use the full area of the texture.
                    region.u = 0;
                    region.v = 1;
                    region.u2 = 1;
                    region.v2 = 0;
                    region.x = 0;
                    region.y = 0;

                    region.page = page;

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion:static start.*/
                /**
                 * Creates a Spine.AtlasRegion from a UnityEngine.Sprite.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Sprite}    s       
                 * @param   {Spine.AtlasPage}       page
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegion: function (s, page) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion", this ); }

                    if (page == null) {
                        throw new System.ArgumentNullException.$ctor3("page", "page cannot be null. AtlasPage determines which texture region belongs and how it should be rendered. You can use material.ToSpineAtlasPage() to get a shareable AtlasPage from a Material, or use the sprite.ToAtlasRegion(material) overload.");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s);
                    region.page = page;
                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1:static start.*/
                /**
                 * Creates a Spine.AtlasRegion from a UnityEngine.Sprite. This creates a new AtlasPage object for every AtlasRegion you create. You can centralize Material control by creating a shared atlas page using Material.ToSpineAtlasPage and using the sprite.ToAtlasRegion(AtlasPage) overload.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Sprite}      s           
                 * @param   {UnityEngine.Material}    material
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegion$1: function (s, material) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$1", this ); }

                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s);
                    region.page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);
                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4:static start.*/
                ToAtlasRegion$4: function (s, isolatedTexture) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$4", this ); }

                    if (isolatedTexture === void 0) { isolatedTexture = false; }
                    var region = new Spine.AtlasRegion();
                    region.name = s.name;
                    region.index = -1;
                    region.degrees = s.packed && s.packingRotation !== UnityEngine.SpritePackingRotation.None ? 90 : 0;

                    // World space units
                    var bounds = s.bounds;
                    var boundsMin = UnityEngine.Vector2.FromVector3(bounds.min.$clone()), boundsMax = UnityEngine.Vector2.FromVector3(bounds.max.$clone());

                    // Texture space/pixel units
                    var spineRect = Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(s.rect, s.texture.height);
                    region.width = Bridge.Int.clip32(spineRect.width);
                    region.originalWidth = Bridge.Int.clip32(spineRect.width);
                    region.height = Bridge.Int.clip32(spineRect.height);
                    region.originalHeight = Bridge.Int.clip32(spineRect.height);
                    region.offsetX = spineRect.width * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.x, boundsMax.x, 0));
                    region.offsetY = spineRect.height * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.y, boundsMax.y, 0));

                    if (isolatedTexture) {
                        region.u = 0;
                        region.v = 1;
                        region.u2 = 1;
                        region.v2 = 0;
                        region.x = 0;
                        region.y = 0;
                    } else {
                        var tex = s.texture;
                        var uvRect = Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect(s.textureRect.$clone(), tex.width, tex.height);
                        region.u = uvRect.xMin;
                        region.v = uvRect.yMax;
                        region.u2 = uvRect.xMax;
                        region.v2 = uvRect.yMin;
                        region.x = Bridge.Int.clip32(spineRect.x);
                        region.y = Bridge.Int.clip32(spineRect.y);
                    }

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$2:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Texture2D}        t                         
                 * @param   {UnityEngine.Material}         materialPropertySource    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegionPMAClone$2: function (t, materialPropertySource, textureFormat, mipmaps) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$2", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3(t, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$2:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Texture2D}        t                         
                 * @param   {UnityEngine.Shader}           shader                    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps                   
                 * @param   {UnityEngine.Material}         materialPropertySource
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegionPMAClone$3: function (t, shader, textureFormat, mipmaps, materialPropertySource) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$3", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }
                    var newTexture = Spine.Unity.AttachmentTools.AtlasUtilities.GetClone(t, textureFormat, mipmaps, false, true);

                    newTexture.name = (t.name || "") + "-pma-";
                    material.name = (t.name || "") + (shader.name || "");

                    material.mainTexture = newTexture;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);

                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3(newTexture, shader);
                    region.page = page;

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone:static start.*/
                ToAtlasRegionPMAClone: function (s, materialPropertySource, textureFormat, mipmaps) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1(s, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Sprite}           s                         
                 * @param   {UnityEngine.Shader}           shader                    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps                   
                 * @param   {UnityEngine.Material}         materialPropertySource
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegionPMAClone$1: function (s, shader, textureFormat, mipmaps, materialPropertySource) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$1", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }

                    var tex = Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1(s, textureFormat, mipmaps, false, true);
                    tex.name = (s.name || "") + "-pma-";
                    material.name = (tex.name || "") + (shader.name || "");

                    material.mainTexture = tex;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);

                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s, true);
                    region.page = page;

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage:static start.*/
                /**
                 * Creates a new Spine.AtlasPage from a UnityEngine.Material. If the material has a preassigned texture, the page width and height will be set.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Material}    m
                 * @return  {Spine.AtlasPage}
                 */
                ToSpineAtlasPage: function (m) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToSpineAtlasPage", this ); }

                    var $t;
                    var newPage = ($t = new Spine.AtlasPage(), $t.rendererObject = m, $t.name = m.name, $t);

                    var t = m.mainTexture;
                    if (t != null) {
                        newPage.width = t.width;
                        newPage.height = t.height;
                    }

                    return newPage;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments:static start.*/
                /**
                 * Fills the outputAttachments list with new attachment objects based on the attachments in sourceAttachments,
                 but mapped to a new single texture using the same material.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {System.Collections.Generic.List$1}    sourceAttachments                     The list of attachments to be repacked.
                 * @param   {System.Collections.Generic.List$1}    outputAttachments                     The List(Attachment) to populate with the newly created Attachment objects.
                 May be equal to <pre><code>sourceAttachments</code></pre> for in-place operation.
                 * @param   {UnityEngine.Material}                 materialPropertySource                May be null. If no Material property source is provided, a material with
                 default parameters using the provided <pre><code>shader</code></pre> will be created.
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {string}                               newAssetName                          
                 * @param   {boolean}                              clearCache                            When set to <pre><code>true</code></pre>, {@link } is called after
                 repacking to clear the texture cache. See remarks for additional info.
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    Optional additional textures (such as normal maps) to copy while repacking.
                 To copy e.g. the main texture and normal maps, pass 'new int[] { Shader.PropertyToID("_BumpMap") }' at this parameter.
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be filled with the resulting repacked texture for every property,
                 just as the main repacked texture is assigned to <pre><code>outputTexture</code></pre>.
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used as <pre><code>TextureFormat</code></pre> at the Texture at the respective property.
                 When <pre><code>additionalTextureFormats</code></pre> is <pre><code>null</code></pre> or when its array size is smaller,
                 <pre><code>textureFormat</code></pre> is used where there exists no corresponding array item.
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear             When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used to determine whether <pre><code>linear</code></pre> or <pre><code>sRGB</code></pre> color space is used at the
                 Texture at the respective property. When <pre><code>additionalTextureIsLinear</code></pre> is <pre><code>null</code></pre>, <pre><code>linear</code></pre> color space
                 is assumed at every additional Texture element.
                 When e.g. packing the main texture and normal maps, pass 'new bool[] { true }' at this parameter, because normal maps use
                 linear color space.
                 * @return  {void}
                 */
                GetRepackedAttachments: function (sourceAttachments, outputAttachments, materialPropertySource, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newAssetName, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments", this ); }

                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (newAssetName === void 0) { newAssetName = "Repacked Attachments"; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    var shader = materialPropertySource == null ? UnityEngine.Shader.Find("Spine/Skeleton") : materialPropertySource.shader;
                    Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments$1(sourceAttachments, outputAttachments, shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newAssetName, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments$1:static start.*/
                /**
                 * Fills the outputAttachments list with new attachment objects based on the attachments in sourceAttachments,
                 but mapped to a new single texture using the same material.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {System.Collections.Generic.List$1}    sourceAttachments                     The list of attachments to be repacked.
                 * @param   {System.Collections.Generic.List$1}    outputAttachments                     The List(Attachment) to populate with the newly created Attachment objects.
                 May be equal to <pre><code>sourceAttachments</code></pre> for in-place operation.
                 * @param   {UnityEngine.Shader}                   shader                                
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {string}                               newAssetName                          
                 * @param   {UnityEngine.Material}                 materialPropertySource                May be null. If no Material property source is provided, a material with
                 default parameters using the provided <pre><code>shader</code></pre> will be created.
                 * @param   {boolean}                              clearCache                            
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    Optional additional textures (such as normal maps) to copy while repacking.
                 To copy e.g. the main texture and normal maps, pass 'new int[] { Shader.PropertyToID("_BumpMap") }' at this parameter.
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be filled with the resulting repacked texture for every property,
                 just as the main repacked texture is assigned to <pre><code>outputTexture</code></pre>.
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used as <pre><code>TextureFormat</code></pre> at the Texture at the respective property.
                 When <pre><code>additionalTextureFormats</code></pre> is <pre><code>null</code></pre> or when its array size is smaller,
                 <pre><code>textureFormat</code></pre> is used where there exists no corresponding array item.
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear             When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used to determine whether <pre><code>linear</code></pre> or <pre><code>sRGB</code></pre> color space is used at the
                 Texture at the respective property. When <pre><code>additionalTextureIsLinear</code></pre> is <pre><code>null</code></pre>, <pre><code>linear</code></pre> color space
                 is assumed at every additional Texture element.
                 When e.g. packing the main texture and normal maps, pass 'new bool[] { true }' at this parameter, because normal maps use
                 linear color space.
                 * @return  {void}
                 */
                GetRepackedAttachments$1: function (sourceAttachments, outputAttachments, shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newAssetName, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments$1", this ); }

                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (newAssetName === void 0) { newAssetName = "Repacked Attachments"; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    if (sourceAttachments == null) {
                        throw new System.ArgumentNullException.$ctor1("sourceAttachments");
                    }
                    if (outputAttachments == null) {
                        throw new System.ArgumentNullException.$ctor1("outputAttachments");
                    }
                    outputTexture.v = null;
                    if (additionalTexturePropertyIDsToCopy != null && additionalTextureIsLinear == null) {
                        additionalTextureIsLinear = System.Array.init(additionalTexturePropertyIDsToCopy.length, false, System.Boolean);
                        for (var i = 0; i < additionalTextureIsLinear.length; i = (i + 1) | 0) {
                            additionalTextureIsLinear[i] = true;
                        }
                    }

                    // Use these to detect and use shared regions.
                    Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.clear();
                    Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.clear();

                    // Collect all textures from original attachments.
                    var numTextureParamsToRepack = (1 + (additionalTexturePropertyIDsToCopy == null ? 0 : additionalTexturePropertyIDsToCopy.length)) | 0;
                    additionalOutputTextures = (additionalTexturePropertyIDsToCopy == null ? null : System.Array.init(additionalTexturePropertyIDsToCopy.length, null, UnityEngine.Texture2D));
                    if (Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam.length < numTextureParamsToRepack) {
                        System.Array.resize(Bridge.ref(Spine.Unity.AttachmentTools.AtlasUtilities, "texturesToPackAtParam"), numTextureParamsToRepack, null, System.Collections.Generic.List$1(UnityEngine.Texture2D));
                    }
                    for (var i1 = 0; i1 < numTextureParamsToRepack; i1 = (i1 + 1) | 0) {
                        if (Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i1] != null) {
                            Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i1].clear();
                        } else {
                            Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i1] = new (System.Collections.Generic.List$1(UnityEngine.Texture2D)).ctor();
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.clear();

                    if (!Bridge.referenceEquals(sourceAttachments, outputAttachments)) {
                        outputAttachments.clear();
                        outputAttachments.AddRange(sourceAttachments);
                    }

                    var newRegionIndex = 0;
                    for (var attachmentIndex = 0, n = sourceAttachments.Count; attachmentIndex < n; attachmentIndex = (attachmentIndex + 1) | 0) {
                        var originalAttachment = sourceAttachments.getItem(attachmentIndex);

                        if (Bridge.is(originalAttachment, Spine.IHasRendererObject)) {
                            var originalMeshAttachment = Bridge.as(originalAttachment, Spine.MeshAttachment);
                            var newAttachment = (originalMeshAttachment != null) ? originalMeshAttachment.newLinkedMesh() : originalAttachment.copy();
                            var region = Bridge.as(Bridge.cast(newAttachment, Spine.IHasRendererObject).Spine$IHasRendererObject$RendererObject, Spine.AtlasRegion);
                            var existingIndex = { };
                            if (Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.tryGetValue(region, existingIndex)) {
                                Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(existingIndex.v);
                            } else {
                                Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.add(region);
                                for (var i2 = 0; i2 < numTextureParamsToRepack; i2 = (i2 + 1) | 0) {
                                    var regionTexture = (i2 === 0 ? Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture(region, textureFormat, mipmaps) : Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture(region, (additionalTextureFormats != null && ((i2 - 1) | 0) < additionalTextureFormats.length) ? additionalTextureFormats[((i2 - 1) | 0)] : textureFormat, mipmaps, additionalTexturePropertyIDsToCopy[((i2 - 1) | 0)], additionalTextureIsLinear[((i2 - 1) | 0)]));
                                    Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i2].add(regionTexture);
                                }

                                Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.add(region, newRegionIndex);
                                Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(newRegionIndex);
                                newRegionIndex = (newRegionIndex + 1) | 0;
                            }

                            outputAttachments.setItem(attachmentIndex, newAttachment);
                        } else {
                            outputAttachments.setItem(attachmentIndex, useOriginalNonrenderables ? originalAttachment : originalAttachment.copy());
                            Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(Spine.Unity.AttachmentTools.AtlasUtilities.NonrenderingRegion); // Output attachments pairs with regionIndices list 1:1. Pad with a sentinel if the attachment doesn't have a region.
                        }
                    }

                    // Rehydrate the repacked textures as a Material, Spine atlas and Spine.AtlasAttachments
                    var newMaterial = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        newMaterial.CopyPropertiesFromMaterial(materialPropertySource);
                        newMaterial.shaderKeywords = materialPropertySource.shaderKeywords;
                    }
                    newMaterial.name = newAssetName;

                    var rects = null;
                    for (var i3 = 0; i3 < numTextureParamsToRepack; i3 = (i3 + 1) | 0) {
                        // Fill a new texture with the collected attachment textures.
                        var newTexture = new UnityEngine.Texture2D.$ctor12(maxAtlasSize, maxAtlasSize, (i3 > 0 && additionalTextureFormats != null && ((i3 - 1) | 0) < additionalTextureFormats.length) ? additionalTextureFormats[((i3 - 1) | 0)] : textureFormat, mipmaps, (i3 > 0) ? additionalTextureIsLinear[((i3 - 1) | 0)] : false);
                        newTexture.mipMapBias = Spine.Unity.AttachmentTools.AtlasUtilities.DefaultMipmapBias;

                        var texturesToPack = Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i3];
                        if (texturesToPack.Count > 0) {
                            var sourceTexture = texturesToPack.getItem(0);
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, sourceTexture);
                        }
                        newTexture.name = newAssetName;
                        var rectsForTexParam = newTexture.PackTextures(texturesToPack.ToArray(), padding, maxAtlasSize);
                        if (i3 === 0) {
                            rects = rectsForTexParam;
                            newMaterial.mainTexture = newTexture;
                            outputTexture.v = newTexture;
                        } else {
                            newMaterial.SetTexture(additionalTexturePropertyIDsToCopy[((i3 - 1) | 0)], newTexture);
                            additionalOutputTextures[((i3 - 1) | 0)] = newTexture;
                        }
                    }

                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(newMaterial);
                    page.name = newAssetName;

                    Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.clear();
                    for (var i4 = 0, n1 = Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.Count; i4 < n1; i4 = (i4 + 1) | 0) {
                        var oldRegion = Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.getItem(i4);
                        var newRegion = Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion(rects[i4], oldRegion, page);
                        Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.add(newRegion);
                    }

                    // Map the cloned attachments to the repacked atlas.
                    for (var i5 = 0, n2 = outputAttachments.Count; i5 < n2; i5 = (i5 + 1) | 0) {
                        var a = outputAttachments.getItem(i5);
                        if (Bridge.is(a, Spine.IHasRendererObject)) {
                            Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion(a, Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.getItem(Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.getItem(i5)));
                        }
                    }

                    // Clean up.
                    if (clearCache) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache();
                    }

                    outputMaterial.v = newMaterial;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin:static start.*/
                /**
                 * Creates and populates a duplicate skin with cloned attachments that are backed by a new packed texture atlas
                 comprised of all the regions from the original skin.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.Skin}                           o                                     
                 * @param   {string}                               newName                               
                 * @param   {UnityEngine.Material}                 materialPropertySource                
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {boolean}                              clearCache                            When set to <pre><code>true</code></pre>, {@link } is called after
                 repacking to clear the texture cache. See remarks for additional info.
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    Optional additional textures (such as normal maps) to copy while repacking.
                 To copy e.g. the main texture and normal maps, pass 'new int[] { Shader.PropertyToID("_BumpMap") }' at this parameter.
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be filled with the resulting repacked texture for every property,
                 just as the main repacked texture is assigned to <pre><code>outputTexture</code></pre>.
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used as <pre><code>TextureFormat</code></pre> at the Texture at the respective property.
                 When <pre><code>additionalTextureFormats</code></pre> is <pre><code>null</code></pre> or when its array size is smaller,
                 <pre><code>textureFormat</code></pre> is used where there exists no corresponding array item.
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear             When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used to determine whether <pre><code>linear</code></pre> or <pre><code>sRGB</code></pre> color space is used at the
                 Texture at the respective property. When <pre><code>additionalTextureIsLinear</code></pre> is <pre><code>null</code></pre>, <pre><code>linear</code></pre> color space
                 is assumed at every additional Texture element.
                 When e.g. packing the main texture and normal maps, pass 'new bool[] { true }' at this parameter, because normal maps use
                 linear color space.
                 * @return  {Spine.Skin}
                 */
                GetRepackedSkin: function (o, newName, materialPropertySource, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, useOriginalNonrenderables, clearCache, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin", this ); }

                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    return Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1(o, newName, materialPropertySource.shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1:static start.*/
                /**
                 * Creates and populates a duplicate skin with cloned attachments that are backed by a new packed texture atlas
                 comprised of all the regions from the original skin.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.Skin}                           o                                     
                 * @param   {string}                               newName                               
                 * @param   {UnityEngine.Shader}                   shader                                
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {UnityEngine.Material}                 materialPropertySource                
                 * @param   {boolean}                              clearCache                            
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear
                 * @return  {Spine.Skin}
                 */
                GetRepackedSkin$1: function (o, newName, shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin$1", this ); }

                    var $t, $t1;
                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    outputTexture.v = null;

                    if (o == null) {
                        throw new System.NullReferenceException.$ctor1("Skin was null");
                    }
                    var skinAttachments = o.Attachments;
                    var newSkin = new Spine.Skin(newName);

                    newSkin.Bones.AddRange(o.Bones);
                    newSkin.Constraints.AddRange(o.Constraints);

                    Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments.clear();
                    $t = Bridge.getEnumerator(o.Attachments, spine.SkinEntry);
                    try {
                        while ($t.moveNext()) {
                            var entry = $t.Current;
                            Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments.add(entry.attachment);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments(Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments, Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments, materialPropertySource, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newName, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear);
                    var i = 0;
                    $t1 = Bridge.getEnumerator(o.Attachments, spine.SkinEntry);
                    try {
                        while ($t1.moveNext()) {
                            var originalSkinEntry = $t1.Current;
                            var newAttachment = Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments.getItem(Bridge.identity(i, ((i = (i + 1) | 0))));
                            newSkin.setAttachment(originalSkinEntry.slotIndex, originalSkinEntry.name, newAttachment);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    return newSkin;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSprite:static start.*/
                ToSprite: function (ar, pixelsPerUnit) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToSprite", this ); }

                    if (pixelsPerUnit === void 0) { pixelsPerUnit = 100.0; }
                    return UnityEngine.Sprite.Create$1(Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture(ar), Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect(ar), new pc.Vec2( 0.5, 0.5 ), pixelsPerUnit);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSprite:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache:static start.*/
                /**
                 * Frees up textures cached by repacking and remapping operations.
                 Calling {@link } with parameter <pre><code>premultiplyAlpha=true</code></pre>,
                 {@link } or {@link } will cache textures for later re-use,
                	which might steadily increase the texture memory footprint when used excessively.
                	You can clear this Texture cache by calling {@link }.
                 You may also want to call <pre><code>Resources.UnloadUnusedAssets()</code></pre> after that. Be aware that while this cleanup
                 frees up memory, it is also a costly operation and will likely cause a spike in the framerate.
                 Thus it is recommended to perform costly repacking and cleanup operations after e.g. a character customization
                 screen has been exited, and if required additionally after a certain number of <pre><code>GetRemappedClone()</code></pre> calls.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @return  {void}
                 */
                ClearCache: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ClearCache", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList);
                    try {
                        while ($t.moveNext()) {
                            var t = $t.Current;
                            UnityEngine.Object.Destroy(t);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.clear();
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList.clear();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture:static start.*/
                /**
                 * Creates a new Texture2D object based on an AtlasRegion.
                 If applyImmediately is true, Texture2D.Apply is called immediately after the Texture2D is filled with data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}            ar                   
                 * @param   {UnityEngine.TextureFormat}    textureFormat        
                 * @param   {boolean}                      mipmaps              
                 * @param   {number}                       texturePropertyId    
                 * @param   {boolean}                      linear               
                 * @param   {boolean}                      applyPMA
                 * @return  {UnityEngine.Texture2D}
                 */
                ToTexture: function (ar, textureFormat, mipmaps, texturePropertyId, linear, applyPMA) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture", this ); }

                    var $t;
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (texturePropertyId === void 0) { texturePropertyId = 0; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }

                    var output = { };

                    var cacheKey = new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey.$ctor1(texturePropertyId, ar);
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.tryGetValue(cacheKey.$clone(), output);
                    if (output.v == null) {
                        var sourceTexture = texturePropertyId === 0 ? Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture(ar) : Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture(ar, texturePropertyId);
                        var r = Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect(ar);
                        var width = Bridge.Int.clip32(r.width);
                        var height = Bridge.Int.clip32(r.height);
                        output.v = ($t = new UnityEngine.Texture2D.$ctor12(width, height, textureFormat, mipmaps, linear), $t.name = ar.name, $t);
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(output.v, sourceTexture);
                        if (applyPMA) {
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(sourceTexture, r, output.v);
                        } else {
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(sourceTexture, r, output.v);
                        }
                        Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.add(cacheKey.$clone(), output.v);
                        Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList.add(output.v);
                    }

                    return output.v;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1:static start.*/
                ToTexture$1: function (s, textureFormat, mipmaps, linear, applyPMA) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture$1", this ); }

                    var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7;
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }

                    var spriteTexture = s.texture;
                    var r = new UnityEngine.Rect();
                    if (!s.packed || s.packingMode === UnityEngine.SpritePackingMode.Rectangle) {
                        r = s.textureRect.$clone();
                    } else {
                        r = new UnityEngine.Rect.ctor();
                        r.xMin = Math.min(($t = s.uv)[0].x, ($t1 = s.uv)[1].x) * spriteTexture.width;
                        r.xMax = Math.max(($t2 = s.uv)[0].x, ($t3 = s.uv)[1].x) * spriteTexture.width;
                        r.yMin = Math.min(($t4 = s.uv)[0].y, ($t5 = s.uv)[2].y) * spriteTexture.height;
                        r.yMax = Math.max(($t6 = s.uv)[0].y, ($t7 = s.uv)[2].y) * spriteTexture.height;
                    }
                    var newTexture = new UnityEngine.Texture2D.$ctor12(Bridge.Int.clip32(r.width), Bridge.Int.clip32(r.height), textureFormat, mipmaps, linear);
                    Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, spriteTexture);
                    if (applyPMA) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(spriteTexture, r, newTexture);
                    } else {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(spriteTexture, r, newTexture);
                    }
                    return newTexture;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetClone:static start.*/
                GetClone: function (t, textureFormat, mipmaps, linear, applyPMA) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetClone", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }

                    var newTexture = new UnityEngine.Texture2D.$ctor12(t.width, t.height, textureFormat, mipmaps, linear);
                    Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, t);
                    if (applyPMA) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(t, new UnityEngine.Rect.$ctor1(0, 0, t.width, t.height), newTexture);
                    } else {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(t, new UnityEngine.Rect.$ctor1(0, 0, t.width, t.height), newTexture);
                    }
                    return newTexture;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetClone:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture:static start.*/
                CopyTexture: function (source, sourceRect, destination) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#CopyTexture", this ); }

                    if (UnityEngine.SystemInfo.copyTextureSupport === UnityEngine.Rendering.CopyTextureSupport.None) {
                        // GetPixels fallback for old devices.
                        var pixelBuffer = source.GetPixels$2(Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height));
                        destination.SetPixels$1(pixelBuffer);
                        destination.Apply();
                    } else {
                        UnityEngine.Graphics.CopyTexture(source, 0, 0, Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height), destination, 0, 0, 0, 0);
                    }
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA:static start.*/
                CopyTextureApplyPMA: function (source, sourceRect, destination) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureApplyPMA", this ); }

                    var pixelBuffer = source.GetPixels$2(Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height));
                    for (var i = 0, n = pixelBuffer.length; i < n; i = (i + 1) | 0) {
                        var p = pixelBuffer[i].$clone();
                        var a = p.a;
                        p.r = p.r * a;
                        p.g = p.g * a;
                        p.b = p.b * a;
                        pixelBuffer[i] = p.$clone();
                    }
                    destination.SetPixels$1(pixelBuffer);
                    destination.Apply();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.IsRenderable:static start.*/
                IsRenderable: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#IsRenderable", this ); }

                    return Bridge.is(a, Spine.IHasRendererObject);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.IsRenderable:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect:static start.*/
                /**
                 * Get a rect with flipped Y so that a Spine atlas rect gets converted to a Unity Sprite rect and vice versa.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}    rect             
                 * @param   {number}              textureHeight
                 * @return  {UnityEngine.Rect}
                 */
                SpineUnityFlipRect: function (rect, textureHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#SpineUnityFlipRect", this ); }

                    rect.y = textureHeight - rect.y - rect.height;
                    return rect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect:static start.*/
                /**
                 * Gets the Rect of an AtlasRegion according to Unity texture coordinates (x-right, y-up).
                 This overload relies on region.page.height being correctly set.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}    region
                 * @return  {UnityEngine.Rect}
                 */
                GetUnityRect: function (region) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect", this ); }

                    return Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect(region), region.page.height);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect$1:static start.*/
                /**
                 * Gets the Rect of an AtlasRegion according to Unity texture coordinates (x-right, y-up).
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}    region           
                 * @param   {number}               textureHeight
                 * @return  {UnityEngine.Rect}
                 */
                GetUnityRect$1: function (region, textureHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect$1", this ); }

                    return Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect(region), textureHeight);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect:static start.*/
                /**
                 * Returns a Rect of the AtlasRegion according to Spine texture coordinates. (x-right, y-down)
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}    region           
                 * @param   {boolean}              includeRotate
                 * @return  {UnityEngine.Rect}
                 */
                GetSpineAtlasRect: function (region, includeRotate) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetSpineAtlasRect", this ); }

                    if (includeRotate === void 0) { includeRotate = true; }
                    if (includeRotate && (region.degrees === 90 || region.degrees === 270)) {
                        return new UnityEngine.Rect.$ctor1(region.x, region.y, region.height, region.width);
                    } else {
                        return new UnityEngine.Rect.$ctor1(region.x, region.y, region.width, region.height);
                    }
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect:static start.*/
                /**
                 * Denormalize a uvRect into a texture-space Rect.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}    uvRect       
                 * @param   {number}              texWidth     
                 * @param   {number}              texHeight
                 * @return  {UnityEngine.Rect}
                 */
                UVRectToTextureRect: function (uvRect, texWidth, texHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToTextureRect", this ); }

                    uvRect.x *= texWidth;
                    uvRect.width *= texWidth;
                    uvRect.y *= texHeight;
                    uvRect.height *= texHeight;
                    return uvRect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect:static start.*/
                /**
                 * Normalize a texture Rect into UV coordinates.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}    textureRect    
                 * @param   {number}              texWidth       
                 * @param   {number}              texHeight
                 * @return  {UnityEngine.Rect}
                 */
                TextureRectToUVRect: function (textureRect, texWidth, texHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#TextureRectToUVRect", this ); }

                    textureRect.x = pc.math.inverseLerp(0, texWidth, textureRect.x);
                    textureRect.y = pc.math.inverseLerp(0, texHeight, textureRect.y);
                    textureRect.width = pc.math.inverseLerp(0, texWidth, textureRect.width);
                    textureRect.height = pc.math.inverseLerp(0, texHeight, textureRect.height);
                    return textureRect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion:static start.*/
                /**
                 * Creates a new Spine AtlasRegion according to a Unity UV Rect (x-right, y-up, uv-normalized).
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}     uvRect             
                 * @param   {Spine.AtlasRegion}    referenceRegion    
                 * @param   {Spine.AtlasPage}      page
                 * @return  {Spine.AtlasRegion}
                 */
                UVRectToAtlasRegion: function (uvRect, referenceRegion, page) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToAtlasRegion", this ); }

                    var $t;
                    var tr = Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect(uvRect.$clone(), page.width, page.height);
                    var rr = Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(tr, page.height);

                    var x = Bridge.Int.clip32(rr.x), y = Bridge.Int.clip32(rr.y);
                    var w, h;
                    if (referenceRegion.degrees === 90 || referenceRegion.degrees === 270) {
                        w = Bridge.Int.clip32(rr.height);
                        h = Bridge.Int.clip32(rr.width);
                    } else {
                        w = Bridge.Int.clip32(rr.width);
                        h = Bridge.Int.clip32(rr.height);
                    }

                    var originalW = Math.round(w * (referenceRegion.originalWidth / referenceRegion.width));
                    var originalH = Math.round(h * (referenceRegion.originalHeight / referenceRegion.height));
                    var offsetX = Math.round(referenceRegion.offsetX * (w / referenceRegion.width));
                    var offsetY = Math.round(referenceRegion.offsetY * (h / referenceRegion.height));

                    if (referenceRegion.degrees === 270) {
                        w = Bridge.Int.clip32(rr.width);
                        h = Bridge.Int.clip32(rr.height);
                    }

                    var u = uvRect.xMin;
                    var u2 = uvRect.xMax;
                    var v = uvRect.yMax;
                    var v2 = uvRect.yMin;

                    return ($t = new Spine.AtlasRegion(), $t.page = page, $t.name = referenceRegion.name, $t.u = u, $t.u2 = u2, $t.v = v, $t.v2 = v2, $t.index = -1, $t.width = w, $t.originalWidth = originalW, $t.height = h, $t.originalHeight = originalH, $t.offsetX = offsetX, $t.offsetY = offsetY, $t.x = x, $t.y = y, $t.rotate = referenceRegion.rotate, $t.degrees = referenceRegion.degrees, $t);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture:static start.*/
                /**
                 * Convenience method for getting the main texture of the material of the page of the region.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}        region
                 * @return  {UnityEngine.Texture2D}
                 */
                GetMainTexture: function (region) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetMainTexture", this ); }

                    var material = (Bridge.as(region.page.rendererObject, UnityEngine.Material));
                    return Bridge.as(material.mainTexture, UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture$1:static start.*/
                /**
                 * Convenience method for getting any texture of the material of the page of the region by texture property name.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}        region                 
                 * @param   {string}                   texturePropertyName
                 * @return  {UnityEngine.Texture2D}
                 */
                GetTexture$1: function (region, texturePropertyName) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture$1", this ); }

                    var material = (Bridge.as(region.page.rendererObject, UnityEngine.Material));
                    return Bridge.as(material.GetTexture$1(texturePropertyName), UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture:static start.*/
                /**
                 * Convenience method for getting any texture of the material of the page of the region by texture property id.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}        region               
                 * @param   {number}                   texturePropertyId
                 * @return  {UnityEngine.Texture2D}
                 */
                GetTexture: function (region, texturePropertyId) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture", this ); }

                    var material = (Bridge.as(region.page.rendererObject, UnityEngine.Material));
                    return Bridge.as(material.GetTexture(texturePropertyId), UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom:static start.*/
                CopyTextureAttributesFrom: function (destination, source) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureAttributesFrom", this ); }

                    destination.filterMode = source.filterMode;
                    destination.anisoLevel = source.anisoLevel;
                    destination.wrapModeU = source.wrapModeU;
                    destination.wrapModeV = source.wrapModeV;
                    destination.wrapModeW = source.wrapModeW;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp:static start.*/
                InverseLerp: function (a, b, value) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#InverseLerp", this ); }

                    return (value - a) / (b - a);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AtlasUtilities end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getDefaultValue", this ); }
 return new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey(); }
            }
        },
        fields: {
            i: 0,
            region: null
        },
        ctors: {
            $ctor1: function (i, region) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$ctor1", this ); }

                this.$initialize();
                this.i = i;
                this.region = region;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey.getHashCode start.*/
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getHashCode", this ); }

                return Bridge.Int.mul(Bridge.getHashCode(this.i), 23) ^ Bridge.getHashCode(this.region);
            },
            /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey.getHashCode end.*/

            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey)) {
                    return false;
                }
                return Bridge.equals(this.i, o.i) && Bridge.equals(this.region, o.region);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$clone", this ); }

                var s = to || new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey();
                s.i = this.i;
                s.region = this.region;
                return s;
            }
        },
        overloads: {
            "GetHashCode()": "getHashCode"
        }
    });
    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey end.*/

    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AttachmentCloneExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone$1:static start.*/
                /**
                 * Gets a clone of the attachment remapped with a sprite image.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @param   {spine.Attachment}        o                          The original attachment.
                 * @param   {UnityEngine.Sprite}      sprite                     The sprite whose texture to use.
                 * @param   {UnityEngine.Material}    sourceMaterial             The source material used to copy the shader and material properties from.
                 * @param   {boolean}                 premultiplyAlpha           If <pre><code>true</code></pre>, a premultiply alpha clone of the original texture will be created.
                 See remarks below for additional info.
                 * @param   {boolean}                 cloneMeshAsLinked          If <pre><code>true</code></pre> MeshAttachments will be cloned as linked meshes and will inherit animation from the original attachment.
                 * @param   {boolean}                 useOriginalRegionSize      If <pre><code>true</code></pre> the size of the original attachment will be followed, instead of using the Sprite size.
                 * @param   {boolean}                 pivotShiftsMeshUVCoords    If <pre><code>true</code></pre> and the original Attachment is a MeshAttachment, then
                	a non-central sprite pivot will shift uv coords in the opposite direction. Vertices will not be offset in
                	any case when the original Attachment is a MeshAttachment.
                 * @param   {boolean}                 useOriginalRegionScale     If <pre><code>true</code></pre> and the original Attachment is a RegionAttachment, then
                	the original region's scale value is used instead of the Sprite's pixels per unit property. Since uniform scale is used,
                	x scale of the original attachment (width scale) is used, scale in y direction (height scale) is ignored.
                 * @return  {spine.Attachment}                                   The remapped clone.
                 */
                GetRemappedClone$1: function (o, sprite, sourceMaterial, premultiplyAlpha, cloneMeshAsLinked, useOriginalRegionSize, pivotShiftsMeshUVCoords, useOriginalRegionScale) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone$1", this ); }

                    var $t;
                    if (premultiplyAlpha === void 0) { premultiplyAlpha = true; }
                    if (cloneMeshAsLinked === void 0) { cloneMeshAsLinked = true; }
                    if (useOriginalRegionSize === void 0) { useOriginalRegionSize = false; }
                    if (pivotShiftsMeshUVCoords === void 0) { pivotShiftsMeshUVCoords = true; }
                    if (useOriginalRegionScale === void 0) { useOriginalRegionScale = false; }
                    var atlasRegion = premultiplyAlpha ? Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone(sprite, sourceMaterial) : Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1(sprite, ($t = new UnityEngine.Material.$ctor1(sourceMaterial), $t.mainTexture = sprite.texture, $t));
                    if (!pivotShiftsMeshUVCoords && Bridge.is(o, Spine.MeshAttachment)) {
                        // prevent non-central sprite pivot setting offsetX/Y and shifting uv coords out of mesh bounds
                        atlasRegion.offsetX = 0;
                        atlasRegion.offsetY = 0;
                    }
                    var scale = 1.0 / sprite.pixelsPerUnit;
                    if (useOriginalRegionScale) {
                        var regionAttachment = Bridge.as(o, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            scale = regionAttachment.width / regionAttachment.RegionOriginalWidth;
                        }
                    }
                    return Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone(o, atlasRegion, cloneMeshAsLinked, useOriginalRegionSize, scale);
                },
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone:static start.*/
                /**
                 * Gets a clone of the attachment remapped with an atlasRegion image.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @param   {spine.Attachment}     o                        The original attachment.
                 * @param   {Spine.AtlasRegion}    atlasRegion              Atlas region.
                 * @param   {boolean}              cloneMeshAsLinked        If <pre><code>true</code></pre> MeshAttachments will be cloned as linked meshes and will inherit animation from the original attachment.
                 * @param   {boolean}              useOriginalRegionSize    If <pre><code>true</code></pre> the size of the original attachment will be followed, instead of using the Sprite size.
                 * @param   {number}               scale                    Unity units per pixel scale used to scale the atlas region size when not using the original region size.
                 * @return  {spine.Attachment}                              The remapped clone.
                 */
                GetRemappedClone: function (o, atlasRegion, cloneMeshAsLinked, useOriginalRegionSize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone", this ); }

                    if (cloneMeshAsLinked === void 0) { cloneMeshAsLinked = true; }
                    if (useOriginalRegionSize === void 0) { useOriginalRegionSize = false; }
                    if (scale === void 0) { scale = 0.01; }
                    var regionAttachment = Bridge.as(o, Spine.RegionAttachment);
                    if (regionAttachment != null) {
                        var newAttachment = Bridge.cast(regionAttachment.copy(), Spine.RegionAttachment);
                        Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion$2(newAttachment, atlasRegion, false);
                        if (!useOriginalRegionSize) {
                            newAttachment.width = atlasRegion.width * scale;
                            newAttachment.height = atlasRegion.height * scale;
                        }
                        newAttachment.updateOffset();
                        return newAttachment;
                    } else {
                        var meshAttachment = Bridge.as(o, Spine.MeshAttachment);
                        if (meshAttachment != null) {
                            var newAttachment1 = cloneMeshAsLinked ? meshAttachment.newLinkedMesh() : Bridge.cast(meshAttachment.copy(), Spine.MeshAttachment);
                            Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion$1(newAttachment1, atlasRegion);
                            return newAttachment1;
                        }
                    }
                    return o.copy();
                },
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions end.*/

    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AttachmentRegionExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion:static start.*/
                /**
                 * Tries to set the region (image) of a renderable attachment. If the attachment is not renderable, nothing is applied.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {spine.Attachment}     attachment      
                 * @param   {Spine.AtlasRegion}    region          
                 * @param   {boolean}              updateOffset
                 * @return  {void}
                 */
                SetRegion: function (attachment, region, updateOffset) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRegion", this ); }

                    if (updateOffset === void 0) { updateOffset = true; }
                    var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                    if (regionAttachment != null) {
                        Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion$2(regionAttachment, region, updateOffset);
                    }

                    var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                    if (meshAttachment != null) {
                        Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion$1(meshAttachment, region, updateOffset);
                    }
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion$2:static start.*/
                /**
                 * Sets the region (image) of a RegionAttachment
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    attachment      
                 * @param   {Spine.AtlasRegion}         region          
                 * @param   {boolean}                   updateOffset
                 * @return  {void}
                 */
                SetRegion$2: function (attachment, region, updateOffset) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRegion$2", this ); }

                    if (updateOffset === void 0) { updateOffset = true; }
                    if (region == null) {
                        throw new System.ArgumentNullException.$ctor1("region");
                    }

                    // (AtlasAttachmentLoader.cs)
                    attachment.rendererObject = region;
                    attachment.setUVs(region.u, region.v, region.u2, region.v2, region.degrees);
                    attachment.RegionOffsetX = region.offsetX;
                    attachment.RegionOffsetY = region.offsetY;
                    attachment.RegionWidth = region.width;
                    attachment.RegionHeight = region.height;
                    attachment.RegionOriginalWidth = region.originalWidth;
                    attachment.RegionOriginalHeight = region.originalHeight;

                    if (updateOffset) {
                        attachment.updateOffset();
                    }
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion$2:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion$1:static start.*/
                /**
                 * Sets the region (image) of a MeshAttachment
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.MeshAttachment}    attachment    
                 * @param   {Spine.AtlasRegion}       region        
                 * @param   {boolean}                 updateUVs
                 * @return  {void}
                 */
                SetRegion$1: function (attachment, region, updateUVs) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRegion$1", this ); }

                    if (updateUVs === void 0) { updateUVs = true; }
                    if (region == null) {
                        throw new System.ArgumentNullException.$ctor1("region");
                    }

                    // (AtlasAttachmentLoader.cs)
                    attachment.RendererObject = region;
                    attachment.RegionU = region.u;
                    attachment.RegionV = region.v;
                    attachment.RegionU2 = region.u2;
                    attachment.RegionV2 = region.v2;
                    attachment.RegionDegrees = region.degrees;
                    attachment.RegionOffsetX = region.offsetX;
                    attachment.RegionOffsetY = region.offsetY;
                    attachment.RegionWidth = region.width;
                    attachment.RegionHeight = region.height;
                    attachment.RegionOriginalWidth = region.originalWidth;
                    attachment.RegionOriginalHeight = region.originalHeight;

                    if (updateUVs) {
                        attachment.updateUVs();
                    }
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRegion$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$2:static start.*/
                /**
                 * Creates a RegionAttachment based on a sprite. This method creates a real, usable AtlasRegion. That AtlasRegion uses a new AtlasPage with the Material provided.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {UnityEngine.Sprite}        sprite      
                 * @param   {UnityEngine.Material}      material    
                 * @param   {number}                    rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachment$2: function (sprite, material, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$2", this ); }

                    if (rotation === void 0) { rotation = 0.0; }
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1(sprite, Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material), rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$2:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1:static start.*/
                /**
                 * Creates a RegionAttachment based on a sprite. This method creates a real, usable AtlasRegion. That AtlasRegion uses the AtlasPage provided.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {UnityEngine.Sprite}        sprite      
                 * @param   {Spine.AtlasPage}           page        
                 * @param   {number}                    rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachment$1: function (sprite, page, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$1", this ); }

                    if (rotation === void 0) { rotation = 0.0; }
                    if (sprite == null) {
                        throw new System.ArgumentNullException.$ctor1("sprite");
                    }
                    if (page == null) {
                        throw new System.ArgumentNullException.$ctor1("page");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion(sprite, page);
                    var unitsPerPixel = 1.0 / sprite.pixelsPerUnit;
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment(region, sprite.name, unitsPerPixel, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment:static start.*/
                /**
                 * Creates a new RegionAttachment from a given AtlasRegion.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.AtlasRegion}         region            
                 * @param   {string}                    attachmentName    
                 * @param   {number}                    scale             
                 * @param   {number}                    rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachment: function (region, attachmentName, scale, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    if (rotation === void 0) { rotation = 0.0; }
                    if (System.String.isNullOrEmpty(attachmentName)) {
                        throw new System.ArgumentException.$ctor3("attachmentName can't be null or empty.", "attachmentName");
                    }
                    if (region == null) {
                        throw new System.ArgumentNullException.$ctor1("region");
                    }

                    // (AtlasAttachmentLoader.cs)
                    var attachment = new Spine.RegionAttachment(attachmentName);

                    attachment.rendererObject = region;
                    attachment.setUVs(region.u, region.v, region.u2, region.v2, region.degrees);
                    attachment.RegionOffsetX = region.offsetX;
                    attachment.RegionOffsetY = region.offsetY;
                    attachment.RegionWidth = region.width;
                    attachment.RegionHeight = region.height;
                    attachment.RegionOriginalWidth = region.originalWidth;
                    attachment.RegionOriginalHeight = region.originalHeight;

                    attachment.path = region.name;
                    attachment.scaleX = 1;
                    attachment.scaleY = 1;
                    attachment.rotation = rotation;

                    attachment.color.r = 1;
                    attachment.color.g = 1;
                    attachment.color.b = 1;
                    attachment.color.a = 1;

                    // pass OriginalWidth and OriginalHeight because UpdateOffset uses it in its calculation.
                    attachment.width = attachment.RegionOriginalWidth * scale;
                    attachment.height = attachment.RegionOriginalHeight * scale;

                    Spine.Unity.SkeletonExtensions.SetColor$2(attachment, new pc.Color( 1, 1, 1, 1 ));
                    attachment.updateOffset();
                    return attachment;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate texture of the Sprite's texture data.
                 Returns a RegionAttachment that uses it. Use this if you plan to use a premultiply alpha shader such as "Spine/Skeleton".
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {UnityEngine.Sprite}           sprite                    
                 * @param   {UnityEngine.Shader}           shader                    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps                   
                 * @param   {UnityEngine.Material}         materialPropertySource    
                 * @param   {number}                       rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachmentPMAClone$1: function (sprite, shader, textureFormat, mipmaps, materialPropertySource, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone$1", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    if (rotation === void 0) { rotation = 0.0; }
                    if (sprite == null) {
                        throw new System.ArgumentNullException.$ctor1("sprite");
                    }
                    if (shader == null) {
                        throw new System.ArgumentNullException.$ctor1("shader");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1(sprite, shader, textureFormat, mipmaps, materialPropertySource);
                    var unitsPerPixel = 1.0 / sprite.pixelsPerUnit;
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment(region, sprite.name, unitsPerPixel, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone:static start.*/
                ToRegionAttachmentPMAClone: function (sprite, materialPropertySource, textureFormat, mipmaps, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (rotation === void 0) { rotation = 0.0; }
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1(sprite, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale$1:static start.*/
                /**
                 * Sets the scale. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {UnityEngine.Vector2}       scale
                 * @return  {void}
                 */
                SetScale$1: function (regionAttachment, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale$1", this ); }

                    regionAttachment.scaleX = scale.x;
                    regionAttachment.scaleY = scale.y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale:static start.*/
                /**
                 * Sets the scale. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {number}                    x                   
                 * @param   {number}                    y
                 * @return  {void}
                 */
                SetScale: function (regionAttachment, x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale", this ); }

                    regionAttachment.scaleX = x;
                    regionAttachment.scaleY = y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset$1:static start.*/
                /**
                 * Sets the position offset. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {UnityEngine.Vector2}       offset
                 * @return  {void}
                 */
                SetPositionOffset$1: function (regionAttachment, offset) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset$1", this ); }

                    regionAttachment.x = offset.x;
                    regionAttachment.y = offset.y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset:static start.*/
                /**
                 * Sets the position offset. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {number}                    x                   
                 * @param   {number}                    y
                 * @return  {void}
                 */
                SetPositionOffset: function (regionAttachment, x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset", this ); }

                    regionAttachment.x = x;
                    regionAttachment.y = y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRotation:static start.*/
                /**
                 * Sets the rotation. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {number}                    rotation
                 * @return  {void}
                 */
                SetRotation: function (regionAttachment, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRotation", this ); }

                    regionAttachment.rotation = rotation;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRotation:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions end.*/

    /*Spine.Unity.BlendModeMaterials start.*/
    Bridge.define("Spine.Unity.BlendModeMaterials", {
        fields: {
            requiresBlendModeMaterials: false,
            applyAdditiveMaterial: false,
            additiveMaterials: null,
            multiplyMaterials: null,
            screenMaterials: null
        },
        props: {
            RequiresBlendModeMaterials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#get", this ); }

                    return this.requiresBlendModeMaterials;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#set", this ); }

                    this.requiresBlendModeMaterials = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#init", this ); }

                this.requiresBlendModeMaterials = false;
                this.applyAdditiveMaterial = false;
                this.additiveMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
                this.multiplyMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
                this.screenMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterials.BlendModeForMaterial start.*/
            BlendModeForMaterial: function (material) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#BlendModeForMaterial", this ); }

                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(this.multiplyMaterials);
                try {
                    while ($t.moveNext()) {
                        var pair = $t.Current;
                        if (Bridge.referenceEquals(pair.material, material)) {
                            return spine.BlendMode.Multiply;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.additiveMaterials);
                try {
                    while ($t1.moveNext()) {
                        var pair1 = $t1.Current;
                        if (Bridge.referenceEquals(pair1.material, material)) {
                            return spine.BlendMode.Additive;
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
                $t2 = Bridge.getEnumerator(this.screenMaterials);
                try {
                    while ($t2.moveNext()) {
                        var pair2 = $t2.Current;
                        if (Bridge.referenceEquals(pair2.material, material)) {
                            return spine.BlendMode.Screen;
                        }
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }
                return spine.BlendMode.Normal;
            },
            /*Spine.Unity.BlendModeMaterials.BlendModeForMaterial end.*/

            /*Spine.Unity.BlendModeMaterials.ApplyMaterials start.*/
            ApplyMaterials: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#ApplyMaterials", this ); }

                var $t, $t1;
                if (skeletonData == null) {
                    throw new System.ArgumentNullException.$ctor1("skeletonData");
                }
                if (!this.requiresBlendModeMaterials) {
                    return;
                }

                var skinEntries = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                var slotsItems = skeletonData.Slots.Items;
                for (var slotIndex = 0, slotCount = skeletonData.Slots.Count; slotIndex < slotCount; slotIndex = (slotIndex + 1) | 0) {
                    var slot = slotsItems[slotIndex];
                    if (slot.blendMode === spine.BlendMode.Normal) {
                        continue;
                    }
                    if (!this.applyAdditiveMaterial && slot.blendMode === spine.BlendMode.Additive) {
                        continue;
                    }

                    var replacementMaterials = null;
                    switch (slot.blendMode) {
                        case spine.BlendMode.Multiply: 
                            replacementMaterials = this.multiplyMaterials;
                            break;
                        case spine.BlendMode.Screen: 
                            replacementMaterials = this.screenMaterials;
                            break;
                        case spine.BlendMode.Additive: 
                            replacementMaterials = this.additiveMaterials;
                            break;
                    }
                    if (replacementMaterials == null) {
                        continue;
                    }

                    skinEntries.clear();
                    $t = Bridge.getEnumerator(skeletonData.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            ( skinEntries._items.length = 0, skin.getAttachmentsForSlot( slotIndex, skinEntries._items ), skinEntries._size = skinEntries._items.length );
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    $t1 = Bridge.getEnumerator(skinEntries);
                    try {
                        while ($t1.moveNext()) {
                            var entry = $t1.Current;
                            var renderableAttachment = Bridge.as(entry.attachment, Spine.IHasRendererObject);
                            if (renderableAttachment != null) {
                                renderableAttachment.Spine$IHasRendererObject$RendererObject = this.CloneAtlasRegionWithMaterial(Bridge.cast(renderableAttachment.Spine$IHasRendererObject$RendererObject, Spine.AtlasRegion), replacementMaterials);
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*Spine.Unity.BlendModeMaterials.ApplyMaterials end.*/

            /*Spine.Unity.BlendModeMaterials.CloneAtlasRegionWithMaterial start.*/
            CloneAtlasRegionWithMaterial: function (originalRegion, replacementMaterials) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#CloneAtlasRegionWithMaterial", this ); }

                var $t;
                var newRegion = originalRegion.Clone();
                var material = null;
                $t = Bridge.getEnumerator(replacementMaterials);
                try {
                    while ($t.moveNext()) {
                        var replacement = $t.Current;
                        if (Bridge.referenceEquals(replacement.pageName, originalRegion.page.name)) {
                            material = replacement.material;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                var originalPage = originalRegion.page;
                var newPage = originalPage.Clone();
                newPage.rendererObject = material;
                newRegion.page = newPage;
                return newRegion;
            },
            /*Spine.Unity.BlendModeMaterials.CloneAtlasRegionWithMaterial end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterials end.*/

    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial start.*/
    Bridge.define("Spine.Unity.BlendModeMaterials.ReplacementMaterial", {
        $kind: 1002,
        fields: {
            pageName: null,
            material: null
        }
    });
    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial end.*/

    /*Spine.Unity.SkeletonDataModifierAsset start.*/
    /**
     * Can be stored by SkeletonDataAsset to automatically apply modifications to loaded SkeletonData.
     *
     * @abstract
     * @public
     * @class Spine.Unity.SkeletonDataModifierAsset
     * @augments UnityEngine.ScriptableObject
     */
    Bridge.define("Spine.Unity.SkeletonDataModifierAsset", {
        inherits: [UnityEngine.ScriptableObject]
    });
    /*Spine.Unity.SkeletonDataModifierAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache start.*/
    Bridge.define("Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache", {
        inherits: [System.IDisposable],
        $kind: 1002,
        fields: {
            cache: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#init", this ); }

                this.cache = new (System.Collections.Generic.Dictionary$2(System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material),Spine.AtlasPage)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.CloneAtlasRegionWithMaterial start.*/
            /**
             * Creates a clone of an AtlasRegion that uses different Material settings, while retaining the original texture.
             *
             * @instance
             * @public
             * @this Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache
             * @memberof Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache
             * @param   {Spine.AtlasRegion}       originalRegion      
             * @param   {UnityEngine.Material}    materialTemplate
             * @return  {Spine.AtlasRegion}
             */
            CloneAtlasRegionWithMaterial: function (originalRegion, materialTemplate) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#CloneAtlasRegionWithMaterial", this ); }

                var newRegion = originalRegion.Clone();
                newRegion.page = this.GetAtlasPageWithMaterial(originalRegion.page, materialTemplate);
                return newRegion;
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.CloneAtlasRegionWithMaterial end.*/

            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.GetAtlasPageWithMaterial start.*/
            GetAtlasPageWithMaterial: function (originalPage, materialTemplate) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#GetAtlasPageWithMaterial", this ); }

                var $t;
                if (originalPage == null) {
                    throw new System.ArgumentNullException.$ctor1("originalPage");
                }

                var newPage = { v : null };
                var key = new (System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material)).$ctor1(originalPage, materialTemplate);
                this.cache.tryGetValue(key, newPage);

                if (newPage.v == null) {
                    newPage.v = originalPage.Clone();
                    var originalMaterial = Bridge.as(originalPage.rendererObject, UnityEngine.Material);
                    newPage.v.rendererObject = ($t = new UnityEngine.Material.$ctor1(materialTemplate), $t.name = (originalMaterial.name || "") + " " + (materialTemplate.name || ""), $t.mainTexture = originalMaterial.mainTexture, $t);
                    this.cache.add(key, newPage.v);
                }

                return newPage.v;
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.GetAtlasPageWithMaterial end.*/

            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#Dispose", this ); }

                this.cache.clear();
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.Dispose end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache end.*/

    /*Spine.Unity.BoneFollower start.*/
    /**
     * Sets a GameObject's transform to match a bone on a Spine skeleton.
     *
     * @public
     * @class Spine.Unity.BoneFollower
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.BoneFollower", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            /**
             * If a bone isn't set in code, boneName is used to find the bone at the beginning. For runtime switching by name, use SetBoneByName. You can also set the BoneFollower.bone field directly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.BoneFollower
             * @type string
             */
            boneName: null,
            followXYPosition: false,
            followZPosition: false,
            followBoneRotation: false,
            followSkeletonFlip: false,
            followLocalScale: false,
            followParentWorldScale: false,
            maintainedAxisOrientation: 0,
            initializeOnAwake: false,
            valid: false,
            bone: null,
            skeletonTransform: null,
            skeletonTransformIsParent: false
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SkeletonRenderer#set", this ); }

                    this.skeletonRenderer = value;
                    this.Initialize();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#init", this ); }

                this.followXYPosition = true;
                this.followZPosition = true;
                this.followBoneRotation = true;
                this.followSkeletonFlip = true;
                this.followLocalScale = false;
                this.followParentWorldScale = false;
                this.maintainedAxisOrientation = Spine.Unity.BoneFollower.AxisOrientation.XAxis;
                this.initializeOnAwake = true;
            }
        },
        methods: {
            /*Spine.Unity.BoneFollower.SetBone start.*/
            /**
             * Sets the target bone by its bone name. Returns false if no bone was found. To set the bone by reference, use BoneFollower.bone directly.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoneFollower
             * @memberof Spine.Unity.BoneFollower
             * @param   {string}     name
             * @return  {boolean}
             */
            SetBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SetBone", this ); }

                this.bone = this.skeletonRenderer.skeleton.findBone(name);
                if (this.bone == null) {
                    UnityEngine.Debug.LogError$2("Bone not found: " + (name || ""), this);
                    return false;
                }
                this.boneName = name;
                return true;
            },
            /*Spine.Unity.BoneFollower.SetBone end.*/

            /*Spine.Unity.BoneFollower.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#Awake", this ); }

                if (this.initializeOnAwake) {
                    this.Initialize();
                }
            },
            /*Spine.Unity.BoneFollower.Awake end.*/

            /*Spine.Unity.BoneFollower.HandleRebuildRenderer start.*/
            HandleRebuildRenderer: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#HandleRebuildRenderer", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoneFollower.HandleRebuildRenderer end.*/

            /*Spine.Unity.BoneFollower.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#Initialize", this ); }

                this.bone = null;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid;
                if (!this.valid) {
                    return;
                }

                this.skeletonTransform = this.skeletonRenderer.transform;
                this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                if (!System.String.isNullOrEmpty(this.boneName)) {
                    this.bone = this.skeletonRenderer.skeleton.findBone(this.boneName);
                }

            },
            /*Spine.Unity.BoneFollower.Initialize end.*/

            /*Spine.Unity.BoneFollower.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#OnDestroy", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                }
            },
            /*Spine.Unity.BoneFollower.OnDestroy end.*/

            /*Spine.Unity.BoneFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#LateUpdate", this ); }

                var $t, $t1;
                if (!this.valid) {
                    this.Initialize();
                    return;
                }


                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = this.skeletonRenderer.skeleton.findBone(this.boneName);
                    if (!this.SetBone(this.boneName)) {
                        return;
                    }
                }

                var thisTransform = this.transform;
                var additionalFlipScale = 1;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( this.followXYPosition ? this.bone.worldX : thisTransform.localPosition.x, this.followXYPosition ? this.bone.worldY : thisTransform.localPosition.y, this.followZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followBoneRotation) {
                        var halfRotation = Math.atan2(this.bone.c, this.bone.a) * 0.5;
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            halfRotation += 1.57079637;
                        }

                        var q = Bridge.getDefaultValue(UnityEngine.Quaternion);
                        q.z = Math.sin(halfRotation);
                        q.w = Math.cos(halfRotation);
                        thisTransform.localRotation = q.$clone();
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( this.bone.worldX, this.bone.worldY, 0.0 ));
                    if (!this.followZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }
                    if (!this.followXYPosition) {
                        targetWorldPosition.x = thisTransform.position.x;
                        targetWorldPosition.y = thisTransform.position.y;
                    }

                    var skeletonLossyScale = this.skeletonTransform.lossyScale.$clone();
                    var transformParent = thisTransform.parent;
                    var parentLossyScale = UnityEngine.Component.op_Inequality(transformParent, null) ? transformParent.lossyScale.$clone() : new pc.Vec3( 1, 1, 1 );
                    if (this.followBoneRotation) {
                        var boneWorldRotation = this.bone.getWorldRotationX();

                        if ((skeletonLossyScale.x * skeletonLossyScale.y) < 0) {
                            boneWorldRotation = -boneWorldRotation;
                        }

                        if (this.followSkeletonFlip || this.maintainedAxisOrientation === Spine.Unity.BoneFollower.AxisOrientation.XAxis) {
                            if ((skeletonLossyScale.x * parentLossyScale.x < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        } else {
                            if ((skeletonLossyScale.y * parentLossyScale.y < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        }

                        var worldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            boneWorldRotation += 180.0;
                        }
                        thisTransform.SetPositionAndRotation(targetWorldPosition, new pc.Quat().setFromEulerAngles_Unity( worldRotation.x, worldRotation.y, worldRotation.z + boneWorldRotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }

                    additionalFlipScale = ($t = skeletonLossyScale.x * parentLossyScale.x * skeletonLossyScale.y * parentLossyScale.y, ($t === 0 ? 1 : Math.sign($t)));
                }

                var parentBone = this.bone.parent;
                var localScale = new pc.Vec3( 1.0, 1.0, 1.0 );
                if (this.followParentWorldScale && parentBone != null) {
                    localScale = new pc.Vec3( parentBone.getWorldScaleX(), parentBone.getWorldScaleY(), 1.0 );
                }
                if (this.followLocalScale) {
                    localScale.mul( new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 ) );
                }
                if (this.followSkeletonFlip) {
                    localScale.y *= ($t1 = this.bone.skeleton.scaleX * this.bone.skeleton.scaleY, ($t1 === 0 ? 1 : Math.sign($t1))) * additionalFlipScale;
                }
                thisTransform.localScale = localScale.$clone();
            },
            /*Spine.Unity.BoneFollower.LateUpdate end.*/


        }
    });
    /*Spine.Unity.BoneFollower end.*/

    /*Spine.Unity.BoneFollower+AxisOrientation start.*/
    Bridge.define("Spine.Unity.BoneFollower.AxisOrientation", {
        $kind: 1006,
        statics: {
            fields: {
                XAxis: 1,
                YAxis: 2
            }
        }
    });
    /*Spine.Unity.BoneFollower+AxisOrientation end.*/

    /*Spine.Unity.BoneFollowerGraphic start.*/
    Bridge.define("Spine.Unity.BoneFollowerGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            initializeOnAwake: false,
            /**
             * If a bone isn't set in code, boneName is used to find the bone at the beginning. For runtime switching by name, use SetBoneByName. You can also set the BoneFollower.bone field directly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.BoneFollowerGraphic
             * @type string
             */
            boneName: null,
            followBoneRotation: false,
            followSkeletonFlip: false,
            followLocalScale: false,
            followParentWorldScale: false,
            followXYPosition: false,
            followZPosition: false,
            maintainedAxisOrientation: 0,
            bone: null,
            skeletonTransform: null,
            skeletonTransformIsParent: false,
            valid: false
        },
        props: {
            SkeletonGraphic: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#get", this ); }

                    return this.skeletonGraphic;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#set", this ); }

                    this.skeletonGraphic = value;
                    this.Initialize();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#init", this ); }

                this.initializeOnAwake = true;
                this.followBoneRotation = true;
                this.followSkeletonFlip = true;
                this.followLocalScale = false;
                this.followParentWorldScale = false;
                this.followXYPosition = true;
                this.followZPosition = true;
                this.maintainedAxisOrientation = Spine.Unity.BoneFollower.AxisOrientation.XAxis;
            }
        },
        methods: {
            /*Spine.Unity.BoneFollowerGraphic.SetBone start.*/
            /**
             * Sets the target bone by its bone name. Returns false if no bone was found.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoneFollowerGraphic
             * @memberof Spine.Unity.BoneFollowerGraphic
             * @param   {string}     name
             * @return  {boolean}
             */
            SetBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SetBone", this ); }

                this.bone = this.skeletonGraphic.Skeleton.findBone(name);
                if (this.bone == null) {
                    UnityEngine.Debug.LogError$2("Bone not found: " + (name || ""), this);
                    return false;
                }
                this.boneName = name;
                return true;
            },
            /*Spine.Unity.BoneFollowerGraphic.SetBone end.*/

            /*Spine.Unity.BoneFollowerGraphic.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#Awake", this ); }

                if (this.initializeOnAwake) {
                    this.Initialize();
                }
            },
            /*Spine.Unity.BoneFollowerGraphic.Awake end.*/

            /*Spine.Unity.BoneFollowerGraphic.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#Initialize", this ); }

                this.bone = null;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) && this.skeletonGraphic.IsValid;
                if (!this.valid) {
                    return;
                }

                this.skeletonTransform = this.skeletonGraphic.transform;
                //			skeletonGraphic.OnRebuild -= HandleRebuildRenderer;
                //			skeletonGraphic.OnRebuild += HandleRebuildRenderer;
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                if (!System.String.isNullOrEmpty(this.boneName)) {
                    this.bone = this.skeletonGraphic.Skeleton.findBone(this.boneName);
                }

            },
            /*Spine.Unity.BoneFollowerGraphic.Initialize end.*/

            /*Spine.Unity.BoneFollowerGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#LateUpdate", this ); }

                var $t, $t1;
                if (!this.valid) {
                    this.Initialize();
                    return;
                }


                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = this.skeletonGraphic.Skeleton.findBone(this.boneName);
                    if (!this.SetBone(this.boneName)) {
                        return;
                    }
                }

                var thisTransform = Bridge.as(this.transform, UnityEngine.RectTransform);
                if (UnityEngine.Component.op_Equality(thisTransform, null)) {
                    return;
                }

                var canvas = this.skeletonGraphic.canvas;
                if (UnityEngine.Component.op_Equality(canvas, null)) {
                    canvas = this.skeletonGraphic.GetComponentInParent(UnityEngine.Canvas);
                }
                var scale = UnityEngine.Component.op_Inequality(canvas, null) ? canvas.referencePixelsPerUnit : 100.0;

                var additionalFlipScale = 1;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( this.followXYPosition ? this.bone.worldX * scale : thisTransform.localPosition.x, this.followXYPosition ? this.bone.worldY * scale : thisTransform.localPosition.y, this.followZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followBoneRotation) {
                        thisTransform.localRotation = Spine.Unity.SkeletonExtensions.GetQuaternion(this.bone);
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( this.bone.worldX * scale, this.bone.worldY * scale, 0.0 ));
                    if (!this.followZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }
                    if (!this.followXYPosition) {
                        targetWorldPosition.x = thisTransform.position.x;
                        targetWorldPosition.y = thisTransform.position.y;
                    }

                    var skeletonLossyScale = this.skeletonTransform.lossyScale.$clone();
                    var transformParent = thisTransform.parent;
                    var parentLossyScale = UnityEngine.Component.op_Inequality(transformParent, null) ? transformParent.lossyScale.$clone() : new pc.Vec3( 1, 1, 1 );
                    if (this.followBoneRotation) {
                        var boneWorldRotation = this.bone.getWorldRotationX();

                        if ((skeletonLossyScale.x * skeletonLossyScale.y) < 0) {
                            boneWorldRotation = -boneWorldRotation;
                        }

                        if (this.followSkeletonFlip || this.maintainedAxisOrientation === Spine.Unity.BoneFollower.AxisOrientation.XAxis) {
                            if ((skeletonLossyScale.x * parentLossyScale.x < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        } else {
                            if ((skeletonLossyScale.y * parentLossyScale.y < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        }

                        var worldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            boneWorldRotation += 180.0;
                        }
                        thisTransform.SetPositionAndRotation(targetWorldPosition, new pc.Quat().setFromEulerAngles_Unity( worldRotation.x, worldRotation.y, worldRotation.z + boneWorldRotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }

                    additionalFlipScale = ($t = skeletonLossyScale.x * parentLossyScale.x * skeletonLossyScale.y * parentLossyScale.y, ($t === 0 ? 1 : Math.sign($t)));
                }

                var parentBone = this.bone.parent;
                var localScale = new pc.Vec3( 1.0, 1.0, 1.0 );
                if (this.followParentWorldScale && parentBone != null) {
                    localScale = new pc.Vec3( parentBone.getWorldScaleX(), parentBone.getWorldScaleY(), 1.0 );
                }
                if (this.followLocalScale) {
                    localScale.mul( new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 ) );
                }
                if (this.followSkeletonFlip) {
                    localScale.y *= ($t1 = this.bone.skeleton.scaleX * this.bone.skeleton.scaleY, ($t1 === 0 ? 1 : Math.sign($t1))) * additionalFlipScale;
                }
                thisTransform.localScale = localScale.$clone();
            },
            /*Spine.Unity.BoneFollowerGraphic.LateUpdate end.*/


        }
    });
    /*Spine.Unity.BoneFollowerGraphic end.*/

    /*Spine.Unity.BoundingBoxFollower start.*/
    Bridge.define("Spine.Unity.BoundingBoxFollower", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DebugMessages: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#init", this ); }

                    this.DebugMessages = true;
                }
            }
        },
        fields: {
            skeletonRenderer: null,
            slotName: null,
            isTrigger: false,
            usedByEffector: false,
            usedByComposite: false,
            clearStateOnDisable: false,
            slot: null,
            currentAttachment: null,
            currentAttachmentName: null,
            currentCollider: null,
            colliderTable: null,
            nameTable: null
        },
        props: {
            Slot: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Slot#get", this ); }

                    return this.slot;
                }
            },
            CurrentAttachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentAttachment#get", this ); }

                    return this.currentAttachment;
                }
            },
            CurrentAttachmentName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentAttachmentName#get", this ); }

                    return this.currentAttachmentName;
                }
            },
            CurrentCollider: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentCollider#get", this ); }

                    return this.currentCollider;
                }
            },
            IsTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#IsTrigger#get", this ); }

                    return this.isTrigger;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#init", this ); }

                this.clearStateOnDisable = true;
                this.colliderTable = new (System.Collections.Generic.Dictionary$2(spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D)).ctor();
                this.nameTable = new (System.Collections.Generic.Dictionary$2(spine.BoundingBoxAttachment,System.String)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BoundingBoxFollower.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Start", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.Start end.*/

            /*Spine.Unity.BoundingBoxFollower.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                    this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.OnEnable end.*/

            /*Spine.Unity.BoundingBoxFollower.HandleRebuild start.*/
            HandleRebuild: function (sr) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#HandleRebuild", this ); }

                //if (BoundingBoxFollower.DebugMessages) Debug.Log("Skeleton was rebuilt. Repopulating BoundingBoxFollower.");
                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.HandleRebuild end.*/

            /*Spine.Unity.BoundingBoxFollower.Initialize start.*/
            /**
             * Initialize and instantiate the BoundingBoxFollower colliders. This is method checks if the BoundingBoxFollower has already been initialized for the skeleton instance and slotName and prevents overwriting unless it detects a new setup.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoundingBoxFollower
             * @memberof Spine.Unity.BoundingBoxFollower
             * @param   {boolean}    overwrite
             * @return  {void}
             */
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Initialize", this ); }

                var $t;
                if (overwrite === void 0) { overwrite = false; }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }

                this.skeletonRenderer.Initialize(false);

                if (System.String.isNullOrEmpty(this.slotName)) {
                    return;
                }

                // Don't reinitialize if the setup did not change.
                if (!overwrite && this.colliderTable.Count > 0 && this.slot != null && Bridge.referenceEquals(this.skeletonRenderer.skeleton, this.slot.getSkeleton()) && Bridge.referenceEquals(this.slotName, this.slot.data.name)) {
                    return;
                }

                this.slot = null;
                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
                this.colliderTable.clear();
                this.nameTable.clear();

                var skeleton = this.skeletonRenderer.skeleton;
                if (skeleton == null) {
                    return;
                }
                this.slot = skeleton.findSlot(this.slotName);
                if (this.slot == null) {
                    if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                        UnityEngine.Debug.LogWarning$1(System.String.format("Slot '{0}' not found for BoundingBoxFollower on '{1}'. (Previous colliders were disposed.)", this.slotName, this.gameObject.name));
                    }
                    return;
                }
                var slotIndex = this.slot.data.index;

                var requiredCollidersCount = { v : 0 };
                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (this.gameObject.activeInHierarchy) {
                    $t = Bridge.getEnumerator(skeleton.data.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            this.AddCollidersForSkin(skin, slotIndex, colliders, requiredCollidersCount);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (skeleton.skin != null) {
                        this.AddCollidersForSkin(skeleton.skin, slotIndex, colliders, requiredCollidersCount);
                    }
                }
                this.DisposeExcessCollidersAfter(requiredCollidersCount.v);

                if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                    var valid = this.colliderTable.Count !== 0;
                    if (!valid) {
                        if (this.gameObject.activeInHierarchy) {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower not valid! Slot [" + (this.slotName || "") + "] does not contain any Bounding Box Attachments!");
                        } else {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower tried to rebuild as a prefab.");
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.Initialize end.*/

            /*Spine.Unity.BoundingBoxFollower.AddCollidersForSkin start.*/
            AddCollidersForSkin: function (skin, slotIndex, previousColliders, collidersCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#AddCollidersForSkin", this ); }

                var $t;
                if (skin == null) {
                    return;
                }
                var skinEntries = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                ( skinEntries._items.length = 0, skin.getAttachmentsForSlot( slotIndex, skinEntries._items ), skinEntries._size = skinEntries._items.length );

                $t = Bridge.getEnumerator(skinEntries);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var attachment = skin.getAttachment(slotIndex, entry.name);
                        var boundingBoxAttachment = Bridge.as(attachment, spine.BoundingBoxAttachment);

                        if (Spine.Unity.BoundingBoxFollower.DebugMessages && attachment != null && boundingBoxAttachment == null) {
                            UnityEngine.Debug.Log$1("BoundingBoxFollower tried to follow a slot that contains non-boundingbox attachments: " + (this.slotName || ""));
                        }

                        if (boundingBoxAttachment != null) {
                            if (!this.colliderTable.containsKey(boundingBoxAttachment)) {
                                var bbCollider = collidersCount.v < previousColliders.length ? previousColliders[collidersCount.v] : this.gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                                collidersCount.v = (collidersCount.v + 1) | 0;
                                Spine.Unity.SkeletonUtility.SetColliderPointsLocal(bbCollider, this.slot, boundingBoxAttachment);
                                bbCollider.isTrigger = this.isTrigger;
                                bbCollider.usedByEffector = this.usedByEffector;
                                bbCollider.usedByComposite = this.usedByComposite;
                                bbCollider.enabled = false;
                                bbCollider.hideFlags = UnityEngine.HideFlags.NotEditable;
                                this.colliderTable.add(boundingBoxAttachment, bbCollider);
                                this.nameTable.add(boundingBoxAttachment, entry.name);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.AddCollidersForSkin end.*/

            /*Spine.Unity.BoundingBoxFollower.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#OnDisable", this ); }

                if (this.clearStateOnDisable) {
                    this.ClearState();
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }
            },
            /*Spine.Unity.BoundingBoxFollower.OnDisable end.*/

            /*Spine.Unity.BoundingBoxFollower.ClearState start.*/
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#ClearState", this ); }

                var $t;
                if (this.colliderTable != null) {
                    $t = Bridge.getEnumerator(this.colliderTable.Values);
                    try {
                        while ($t.moveNext()) {
                            var col = $t.Current;
                            col.enabled = false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
            },
            /*Spine.Unity.BoundingBoxFollower.ClearState end.*/

            /*Spine.Unity.BoundingBoxFollower.DisposeExcessCollidersAfter start.*/
            DisposeExcessCollidersAfter: function (requiredCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#DisposeExcessCollidersAfter", this ); }

                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (colliders.length === 0) {
                    return;
                }

                for (var i = requiredCount; i < colliders.length; i = (i + 1) | 0) {
                    var collider = colliders[i];
                    if (UnityEngine.Component.op_Inequality(collider, null)) {
                        UnityEngine.Object.Destroy(collider);
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.DisposeExcessCollidersAfter end.*/

            /*Spine.Unity.BoundingBoxFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#LateUpdate", this ); }

                if (this.slot != null && !Bridge.referenceEquals(this.slot.getAttachment(), this.currentAttachment)) {
                    this.MatchAttachment(this.slot.getAttachment());
                }
            },
            /*Spine.Unity.BoundingBoxFollower.LateUpdate end.*/

            /*Spine.Unity.BoundingBoxFollower.MatchAttachment start.*/
            /**
             * Sets the current collider to match attachment.
             *
             * @instance
             * @private
             * @this Spine.Unity.BoundingBoxFollower
             * @memberof Spine.Unity.BoundingBoxFollower
             * @param   {spine.Attachment}    attachment    If the attachment is not a bounding box, it will be treated as null.
             * @return  {void}
             */
            MatchAttachment: function (attachment) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#MatchAttachment", this ); }

                var bbAttachment = Bridge.as(attachment, spine.BoundingBoxAttachment);

                if (Spine.Unity.BoundingBoxFollower.DebugMessages && attachment != null && bbAttachment == null) {
                    UnityEngine.Debug.LogWarning$1("BoundingBoxFollower tried to match a non-boundingbox attachment. It will treat it as null.");
                }

                if (UnityEngine.Component.op_Inequality(this.currentCollider, null)) {
                    this.currentCollider.enabled = false;
                }

                if (bbAttachment == null) {
                    this.currentCollider = null;
                    this.currentAttachment = null;
                    this.currentAttachmentName = null;
                } else {
                    var foundCollider = { };
                    this.colliderTable.tryGetValue(bbAttachment, foundCollider);
                    if (UnityEngine.Component.op_Inequality(foundCollider.v, null)) {
                        this.currentCollider = foundCollider.v;
                        this.currentCollider.enabled = true;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = this.nameTable.getItem(bbAttachment);
                    } else {
                        this.currentCollider = null;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = null;
                        if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                            UnityEngine.Debug.LogFormat("Collider for BoundingBoxAttachment named '{0}' was not initialized. It is possibly from a new skin. currentAttachmentName will be null. You may need to call BoundingBoxFollower.Initialize(overwrite: true);", [bbAttachment.name]);
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.MatchAttachment end.*/


        }
    });
    /*Spine.Unity.BoundingBoxFollower end.*/

    /*Spine.Unity.BoundingBoxFollowerGraphic start.*/
    Bridge.define("Spine.Unity.BoundingBoxFollowerGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DebugMessages: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#init", this ); }

                    this.DebugMessages = true;
                }
            }
        },
        fields: {
            skeletonGraphic: null,
            slotName: null,
            isTrigger: false,
            usedByEffector: false,
            usedByComposite: false,
            clearStateOnDisable: false,
            slot: null,
            currentAttachment: null,
            currentAttachmentName: null,
            currentCollider: null,
            colliderTable: null,
            nameTable: null
        },
        props: {
            Slot: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Slot#get", this ); }

                    return this.slot;
                }
            },
            CurrentAttachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachment#get", this ); }

                    return this.currentAttachment;
                }
            },
            CurrentAttachmentName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachmentName#get", this ); }

                    return this.currentAttachmentName;
                }
            },
            CurrentCollider: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentCollider#get", this ); }

                    return this.currentCollider;
                }
            },
            IsTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#IsTrigger#get", this ); }

                    return this.isTrigger;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#init", this ); }

                this.clearStateOnDisable = true;
                this.colliderTable = new (System.Collections.Generic.Dictionary$2(spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D)).ctor();
                this.nameTable = new (System.Collections.Generic.Dictionary$2(spine.BoundingBoxAttachment,System.String)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BoundingBoxFollowerGraphic.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Start", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.Start end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                    this.skeletonGraphic.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.OnEnable end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.HandleRebuild start.*/
            HandleRebuild: function (sr) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#HandleRebuild", this ); }

                //if (BoundingBoxFollowerGraphic.DebugMessages) Debug.Log("Skeleton was rebuilt. Repopulating BoundingBoxFollowerGraphic.");
                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.HandleRebuild end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.Initialize start.*/
            /**
             * Initialize and instantiate the BoundingBoxFollowerGraphic colliders. This is method checks if the BoundingBoxFollowerGraphic has already been initialized for the skeleton instance and slotName and prevents overwriting unless it detects a new setup.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoundingBoxFollowerGraphic
             * @memberof Spine.Unity.BoundingBoxFollowerGraphic
             * @param   {boolean}    overwrite
             * @return  {void}
             */
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Initialize", this ); }

                var $t;
                if (overwrite === void 0) { overwrite = false; }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    return;
                }

                this.skeletonGraphic.Initialize(false);

                if (System.String.isNullOrEmpty(this.slotName)) {
                    return;
                }

                // Don't reinitialize if the setup did not change.
                if (!overwrite && this.colliderTable.Count > 0 && this.slot != null && Bridge.referenceEquals(this.skeletonGraphic.Skeleton, this.slot.getSkeleton()) && Bridge.referenceEquals(this.slotName, this.slot.data.name)) {
                    return;
                }

                this.slot = null;
                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
                this.colliderTable.clear();
                this.nameTable.clear();

                var skeleton = this.skeletonGraphic.Skeleton;
                if (skeleton == null) {
                    return;
                }
                this.slot = skeleton.findSlot(this.slotName);
                if (this.slot == null) {
                    if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                        UnityEngine.Debug.LogWarning$1(System.String.format("Slot '{0}' not found for BoundingBoxFollowerGraphic on '{1}'. (Previous colliders were disposed.)", this.slotName, this.gameObject.name));
                    }
                    return;
                }
                var slotIndex = this.slot.data.index;

                var requiredCollidersCount = { v : 0 };
                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (this.gameObject.activeInHierarchy) {
                    var canvas = this.skeletonGraphic.canvas;
                    if (UnityEngine.Component.op_Equality(canvas, null)) {
                        canvas = this.skeletonGraphic.GetComponentInParent(UnityEngine.Canvas);
                    }
                    var scale = UnityEngine.Component.op_Inequality(canvas, null) ? canvas.referencePixelsPerUnit : 100.0;

                    $t = Bridge.getEnumerator(skeleton.data.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            this.AddCollidersForSkin(skin, slotIndex, colliders, scale, requiredCollidersCount);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (skeleton.skin != null) {
                        this.AddCollidersForSkin(skeleton.skin, slotIndex, colliders, scale, requiredCollidersCount);
                    }
                }
                this.DisposeExcessCollidersAfter(requiredCollidersCount.v);

                if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                    var valid = this.colliderTable.Count !== 0;
                    if (!valid) {
                        if (this.gameObject.activeInHierarchy) {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower not valid! Slot [" + (this.slotName || "") + "] does not contain any Bounding Box Attachments!");
                        } else {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower tried to rebuild as a prefab.");
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.Initialize end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.AddCollidersForSkin start.*/
            AddCollidersForSkin: function (skin, slotIndex, previousColliders, scale, collidersCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#AddCollidersForSkin", this ); }

                var $t;
                if (skin == null) {
                    return;
                }
                var skinEntries = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                ( skinEntries._items.length = 0, skin.getAttachmentsForSlot( slotIndex, skinEntries._items ), skinEntries._size = skinEntries._items.length );

                $t = Bridge.getEnumerator(skinEntries);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var attachment = skin.getAttachment(slotIndex, entry.name);
                        var boundingBoxAttachment = Bridge.as(attachment, spine.BoundingBoxAttachment);

                        if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages && attachment != null && boundingBoxAttachment == null) {
                            UnityEngine.Debug.Log$1("BoundingBoxFollowerGraphic tried to follow a slot that contains non-boundingbox attachments: " + (this.slotName || ""));
                        }

                        if (boundingBoxAttachment != null) {
                            if (!this.colliderTable.containsKey(boundingBoxAttachment)) {
                                var bbCollider = collidersCount.v < previousColliders.length ? previousColliders[collidersCount.v] : this.gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                                collidersCount.v = (collidersCount.v + 1) | 0;
                                Spine.Unity.SkeletonUtility.SetColliderPointsLocal(bbCollider, this.slot, boundingBoxAttachment, scale);
                                bbCollider.isTrigger = this.isTrigger;
                                bbCollider.usedByEffector = this.usedByEffector;
                                bbCollider.usedByComposite = this.usedByComposite;
                                bbCollider.enabled = false;
                                bbCollider.hideFlags = UnityEngine.HideFlags.NotEditable;
                                this.colliderTable.add(boundingBoxAttachment, bbCollider);
                                this.nameTable.add(boundingBoxAttachment, entry.name);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.AddCollidersForSkin end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#OnDisable", this ); }

                if (this.clearStateOnDisable) {
                    this.ClearState();
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.OnDisable end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.ClearState start.*/
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#ClearState", this ); }

                var $t;
                if (this.colliderTable != null) {
                    $t = Bridge.getEnumerator(this.colliderTable.Values);
                    try {
                        while ($t.moveNext()) {
                            var col = $t.Current;
                            col.enabled = false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.ClearState end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.DisposeExcessCollidersAfter start.*/
            DisposeExcessCollidersAfter: function (requiredCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#DisposeExcessCollidersAfter", this ); }

                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (colliders.length === 0) {
                    return;
                }

                for (var i = requiredCount; i < colliders.length; i = (i + 1) | 0) {
                    var collider = colliders[i];
                    if (UnityEngine.Component.op_Inequality(collider, null)) {
                        UnityEngine.Object.Destroy(collider);
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.DisposeExcessCollidersAfter end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#LateUpdate", this ); }

                if (this.slot != null && !Bridge.referenceEquals(this.slot.getAttachment(), this.currentAttachment)) {
                    this.MatchAttachment(this.slot.getAttachment());
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.LateUpdate end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.MatchAttachment start.*/
            /**
             * Sets the current collider to match attachment.
             *
             * @instance
             * @private
             * @this Spine.Unity.BoundingBoxFollowerGraphic
             * @memberof Spine.Unity.BoundingBoxFollowerGraphic
             * @param   {spine.Attachment}    attachment    If the attachment is not a bounding box, it will be treated as null.
             * @return  {void}
             */
            MatchAttachment: function (attachment) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#MatchAttachment", this ); }

                var bbAttachment = Bridge.as(attachment, spine.BoundingBoxAttachment);

                if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages && attachment != null && bbAttachment == null) {
                    UnityEngine.Debug.LogWarning$1("BoundingBoxFollowerGraphic tried to match a non-boundingbox attachment. It will treat it as null.");
                }

                if (UnityEngine.Component.op_Inequality(this.currentCollider, null)) {
                    this.currentCollider.enabled = false;
                }

                if (bbAttachment == null) {
                    this.currentCollider = null;
                    this.currentAttachment = null;
                    this.currentAttachmentName = null;
                } else {
                    var foundCollider = { };
                    this.colliderTable.tryGetValue(bbAttachment, foundCollider);
                    if (UnityEngine.Component.op_Inequality(foundCollider.v, null)) {
                        this.currentCollider = foundCollider.v;
                        this.currentCollider.enabled = true;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = this.nameTable.getItem(bbAttachment);
                    } else {
                        this.currentCollider = null;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = null;
                        if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                            UnityEngine.Debug.LogFormat("Collider for BoundingBoxAttachment named '{0}' was not initialized. It is possibly from a new skin. currentAttachmentName will be null. You may need to call BoundingBoxFollowerGraphic.Initialize(overwrite: true);", [bbAttachment.name]);
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.MatchAttachment end.*/


        }
    });
    /*Spine.Unity.BoundingBoxFollowerGraphic end.*/

    /*Spine.Unity.DoubleBuffered$1 start.*/
    Bridge.define("Spine.Unity.DoubleBuffered$1", function (T) { return {
        fields: {
            a: null,
            b: null,
            usingA: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#init", this ); }

                this.a = Bridge.createInstance(T);
                this.b = Bridge.createInstance(T);
            }
        },
        methods: {
            /*Spine.Unity.DoubleBuffered$1.GetCurrent start.*/
            GetCurrent: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#GetCurrent", this ); }

                return this.usingA ? Bridge.rValue(this.a) : Bridge.rValue(this.b);
            },
            /*Spine.Unity.DoubleBuffered$1.GetCurrent end.*/

            /*Spine.Unity.DoubleBuffered$1.GetNext start.*/
            GetNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#GetNext", this ); }

                this.usingA = !this.usingA;
                return this.usingA ? Bridge.rValue(this.a) : Bridge.rValue(this.b);
            },
            /*Spine.Unity.DoubleBuffered$1.GetNext end.*/


        }
    }; });
    /*Spine.Unity.DoubleBuffered$1 end.*/

    /*Spine.Unity.EventDataReferenceAsset start.*/
    Bridge.define("Spine.Unity.EventDataReferenceAsset", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            fields: {
                QuietSkeletonData: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#init", this ); }

                    this.QuietSkeletonData = true;
                }
            },
            methods: {
                op_Implicit: function (asset) {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#op_Implicit", this ); }

                    return asset.EventData;
                }
            }
        },
        fields: {
            skeletonDataAsset: null,
            eventName: null,
            eventData: null
        },
        props: {
            EventData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#EventData#get", this ); }

                    if (this.eventData == null) {
                        this.Initialize();
                    }
                    return this.eventData;
                }
            }
        },
        methods: {
            /*Spine.Unity.EventDataReferenceAsset.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#Initialize", this ); }

                if (this.skeletonDataAsset == null) {
                    return;
                }
                this.eventData = this.skeletonDataAsset.GetSkeletonData(Spine.Unity.EventDataReferenceAsset.QuietSkeletonData).findEvent(this.eventName);
                if (this.eventData == null) {
                    UnityEngine.Debug.LogWarningFormat("Event Data '{0}' not found in SkeletonData : {1}.", [this.eventName, this.skeletonDataAsset.name]);
                }
            },
            /*Spine.Unity.EventDataReferenceAsset.Initialize end.*/


        }
    });
    /*Spine.Unity.EventDataReferenceAsset end.*/

    /*Spine.Unity.ISpineComponentExtensions start.*/
    Bridge.define("Spine.Unity.ISpineComponentExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.ISpineComponentExtensions.IsNullOrDestroyed:static start.*/
                IsNullOrDestroyed: function (component) {
if ( TRACE ) { TRACE( "Spine.Unity.ISpineComponentExtensions#IsNullOrDestroyed", this ); }

                    if (component == null) {
                        return true;
                    }
                    return Bridge.cast(component, UnityEngine.Object) == null;
                },
                /*Spine.Unity.ISpineComponentExtensions.IsNullOrDestroyed:static end.*/


            }
        }
    });
    /*Spine.Unity.ISpineComponentExtensions end.*/

    /*Spine.Unity.MaterialsTextureLoader start.*/
    Bridge.define("Spine.Unity.MaterialsTextureLoader", {
        inherits: [Spine.TextureLoader],
        fields: {
            atlasAsset: null
        },
        alias: [
            "Load", "Spine$TextureLoader$Load",
            "Unload", "Spine$TextureLoader$Unload"
        ],
        ctors: {
            ctor: function (atlasAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#ctor", this ); }

                this.$initialize();
                this.atlasAsset = atlasAsset;
            }
        },
        methods: {
            /*Spine.Unity.MaterialsTextureLoader.Load start.*/
            Load: function (page, path) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#Load", this ); }

                var $t;
                var name = System.IO.Path.GetFileNameWithoutExtension(path);
                var material = null;
                $t = Bridge.getEnumerator(this.atlasAsset.materials);
                try {
                    while ($t.moveNext()) {
                        var other = $t.Current;
                        if (other.mainTexture == null) {
                            UnityEngine.Debug.LogError$2("Material is missing texture: " + (other.name || ""), other);
                            return;
                        }
                        if (Bridge.referenceEquals(other.mainTexture.name, name)) {
                            material = other;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                if (material == null) {
                    UnityEngine.Debug.LogError$2("Material with texture name \"" + (name || "") + "\" not found for atlas asset: " + (this.atlasAsset.name || ""), this.atlasAsset);
                    return;
                }
                page.rendererObject = material;

                // Very old atlas files expected the texture's actual size to be used at runtime.
                if (page.width === 0 || page.height === 0) {
                    page.width = material.mainTexture.width;
                    page.height = material.mainTexture.height;
                }
            },
            /*Spine.Unity.MaterialsTextureLoader.Load end.*/

            /*Spine.Unity.MaterialsTextureLoader.Unload start.*/
            Unload: function (texture) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#Unload", this ); }
 },
            /*Spine.Unity.MaterialsTextureLoader.Unload end.*/


        }
    });
    /*Spine.Unity.MaterialsTextureLoader end.*/

    /*Spine.Unity.MeshGenerator start.*/
    /**
     * Holds several methods to prepare and generate a UnityEngine mesh based on a skeleton. Contains buffers needed to perform the operation, and serializes settings for mesh generation.
     *
     * @public
     * @class Spine.Unity.MeshGenerator
     */
    Bridge.define("Spine.Unity.MeshGenerator", {
        statics: {
            fields: {
                BoundsMinDefault: 0,
                BoundsMaxDefault: 0,
                AttachmentVerts: null,
                AttachmentUVs: null,
                AttachmentColors32: null,
                AttachmentIndices: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#init", this ); }

                    this.BoundsMinDefault = Number.POSITIVE_INFINITY;
                    this.BoundsMaxDefault = Number.NEGATIVE_INFINITY;
                    this.AttachmentVerts = new (System.Collections.Generic.List$1(UnityEngine.Vector3)).ctor();
                    this.AttachmentUVs = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                    this.AttachmentColors32 = new (System.Collections.Generic.List$1(UnityEngine.Color32)).ctor();
                    this.AttachmentIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                }
            },
            methods: {
                /*Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction:static start.*/
                /**
                 * A specialized variant of {@link }.
                 Generates renderer instructions using a single submesh, using only a single material and texture.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Spine.Unity.SkeletonRendererInstruction}    instructionOutput    The resulting instructions.
                 * @param   {Spine.Skeleton}                             skeleton             The skeleton to generate renderer instructions for.
                 * @param   {UnityEngine.Material}                       material             Material to be set at the renderer instruction. When null, the last attachment
                 in the draw order list is assigned as the instruction's material.
                 * @return  {void}
                 */
                GenerateSingleSubmeshInstruction: function (instructionOutput, skeleton, material) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GenerateSingleSubmeshInstruction", this ); }

                    var $t;
                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;

                    // Clear last state of attachments and submeshes
                    instructionOutput.Clear(); // submeshInstructions.Clear(); attachments.Clear();
                    var workingSubmeshInstructions = instructionOutput.submeshInstructions;

                    instructionOutput.attachments.Resize(drawOrderCount);
                    var workingAttachmentsItems = instructionOutput.attachments.Items;
                    var totalRawVertexCount = 0;

                    var current = ($t = new Spine.Unity.SubmeshInstruction(), $t.skeleton = skeleton, $t.preActiveClippingSlotSource = -1, $t.startSlot = 0, $t.rawFirstVertexIndex = 0, $t.material = material, $t.forceSeparate = false, $t.endSlot = drawOrderCount, $t);

                    var rendererObject = null;
                    var skeletonHasClipping = false;
                    var drawOrderItems = drawOrder.Items;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.isActive()) {
                            workingAttachmentsItems[i] = null;
                            continue;
                        }
                        if (slot.data.blendMode === spine.BlendMode.Additive) {
                            current.hasPMAAdditiveSlot = true;
                        }
                        var attachment = slot.getAttachment();

                        workingAttachmentsItems[i] = attachment;
                        var attachmentTriangleCount;
                        var attachmentVertexCount;

                        var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            rendererObject = regionAttachment.rendererObject;
                            attachmentVertexCount = 4;
                            attachmentTriangleCount = 6;
                        } else {
                            var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                            if (meshAttachment != null) {
                                rendererObject = meshAttachment.RendererObject;
                                attachmentVertexCount = meshAttachment.worldVerticesLength >> 1;
                                attachmentTriangleCount = meshAttachment.triangles.length;
                            } else {
                                var clippingAttachment = Bridge.as(attachment, spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    current.hasClipping = true;
                                    skeletonHasClipping = true;
                                }
                                attachmentVertexCount = 0;
                                attachmentTriangleCount = 0;
                            }
                        }
                        current.rawTriangleCount = (current.rawTriangleCount + attachmentTriangleCount) | 0;
                        current.rawVertexCount = (current.rawVertexCount + attachmentVertexCount) | 0;
                        totalRawVertexCount = (totalRawVertexCount + attachmentVertexCount) | 0;
                    }

                    if (material == null && rendererObject != null) {
                        current.material = Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                    }

                    instructionOutput.hasActiveClipping = skeletonHasClipping;
                    instructionOutput.rawVertexCount = totalRawVertexCount;

                    if (totalRawVertexCount > 0) {
                        workingSubmeshInstructions.Resize(1);
                        workingSubmeshInstructions.Items[0] = current.$clone();
                    } else {
                        workingSubmeshInstructions.Resize(0);
                    }
                },
                /*Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction:static end.*/

                /*Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder:static start.*/
                RequiresMultipleSubmeshesByDrawOrder: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#RequiresMultipleSubmeshesByDrawOrder", this ); }


                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;
                    var drawOrderItems = drawOrder.Items;

                    var lastRendererMaterial = null;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.isActive()) {
                            continue;
                        }
                        var attachment = slot.getAttachment();
                        var rendererAttachment = Bridge.as(attachment, Spine.IHasRendererObject);
                        if (rendererAttachment != null) {
                            var atlasRegion = Bridge.cast(rendererAttachment.Spine$IHasRendererObject$RendererObject, Spine.AtlasRegion);
                            var material = Bridge.cast(atlasRegion.page.rendererObject, UnityEngine.Material);
                            if (!Bridge.referenceEquals(lastRendererMaterial, material)) {
                                if (lastRendererMaterial != null) {
                                    return true;
                                } else {
                                    lastRendererMaterial = material;
                                }
                            }
                        }
                    }
                    return false;
                },
                /*Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder:static end.*/

                /*Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction:static start.*/
                GenerateSkeletonRendererInstruction: function (instructionOutput, skeleton, customSlotMaterials, separatorSlots, generateMeshOverride, immutableTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GenerateSkeletonRendererInstruction", this ); }

                    var $t;
                    if (immutableTriangles === void 0) { immutableTriangles = false; }
                    //			if (skeleton == null) throw new ArgumentNullException("skeleton");
                    //			if (instructionOutput == null) throw new ArgumentNullException("instructionOutput");

                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;

                    // Clear last state of attachments and submeshes
                    instructionOutput.Clear(); // submeshInstructions.Clear(); attachments.Clear();
                    var workingSubmeshInstructions = instructionOutput.submeshInstructions;
                    instructionOutput.attachments.Resize(drawOrderCount);
                    var workingAttachmentsItems = instructionOutput.attachments.Items;
                    var totalRawVertexCount = 0;
                    var skeletonHasClipping = false;

                    var current = ($t = new Spine.Unity.SubmeshInstruction(), $t.skeleton = skeleton, $t.preActiveClippingSlotSource = -1, $t);

                    var isCustomSlotMaterialsPopulated = customSlotMaterials != null && customSlotMaterials.Count > 0;

                    var separatorCount = separatorSlots == null ? 0 : separatorSlots.Count;
                    var hasSeparators = separatorCount > 0;

                    var clippingAttachmentSource = -1;
                    var lastPreActiveClipping = -1; // The index of the last slot that had an active ClippingAttachment.
                    var clippingEndSlot = null;
                    var submeshIndex = 0;
                    var drawOrderItems = drawOrder.Items;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.isActive()) {
                            workingAttachmentsItems[i] = null;
                            continue;
                        }
                        if (slot.data.blendMode === spine.BlendMode.Additive) {
                            current.hasPMAAdditiveSlot = true;
                        }
                        var attachment = slot.getAttachment();
                        workingAttachmentsItems[i] = attachment;
                        var attachmentVertexCount = 0, attachmentTriangleCount = 0;

                        var rendererObject = null; // An AtlasRegion in plain Spine-Unity. Spine-TK2D hooks into TK2D's system. eventual source of Material object.
                        var noRender = false; // Using this allows empty slots as separators, and keeps separated parts more stable despite slots being reordered

                        var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            rendererObject = regionAttachment.rendererObject;
                            attachmentVertexCount = 4;
                            attachmentTriangleCount = 6;
                        } else {
                            var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                            if (meshAttachment != null) {
                                rendererObject = meshAttachment.RendererObject;
                                attachmentVertexCount = meshAttachment.worldVerticesLength >> 1;
                                attachmentTriangleCount = meshAttachment.triangles.length;
                            } else {
                                var clippingAttachment = Bridge.as(attachment, spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    clippingEndSlot = clippingAttachment.endSlot;
                                    clippingAttachmentSource = i;
                                    current.hasClipping = true;
                                    skeletonHasClipping = true;
                                }
                                noRender = true;
                            }
                        }

                        // Create a new SubmeshInstruction when material changes. (or when forced to separate by a submeshSeparator)
                        // Slot with a separator/new material will become the starting slot of the next new instruction.
                        if (hasSeparators) { //current.forceSeparate = hasSeparators && separatorSlots.Contains(slot);
                            current.forceSeparate = false;
                            for (var s = 0; s < separatorCount; s = (s + 1) | 0) {
                                if (Bridge.referenceEquals(slot, separatorSlots.getItem(s))) {
                                    current.forceSeparate = true;
                                    break;
                                }
                            }
                        }

                        if (noRender) {
                            if (current.forceSeparate && generateMeshOverride) { // && current.rawVertexCount > 0) {
                                { // Add
                                    current.endSlot = i;
                                    current.preActiveClippingSlotSource = lastPreActiveClipping;

                                    workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                                    workingSubmeshInstructions.Items[submeshIndex] = current.$clone();

                                    submeshIndex = (submeshIndex + 1) | 0;
                                }

                                current.startSlot = i;
                                lastPreActiveClipping = clippingAttachmentSource;
                                current.rawTriangleCount = 0;
                                current.rawVertexCount = 0;
                                current.rawFirstVertexIndex = totalRawVertexCount;
                                current.hasClipping = clippingAttachmentSource >= 0;
                            }
                        } else {
                            var material = { };
                            if (isCustomSlotMaterialsPopulated) {
                                if (!customSlotMaterials.tryGetValue(slot, material)) {
                                    material.v = Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                                }
                            } else {
                                material.v = Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                            }

                            if (current.forceSeparate || (current.rawVertexCount > 0 && !Bridge.referenceEquals(current.material, material.v))) { // Material changed. Add the previous submesh.
                                { // Add
                                    current.endSlot = i;
                                    current.preActiveClippingSlotSource = lastPreActiveClipping;

                                    workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                                    workingSubmeshInstructions.Items[submeshIndex] = current.$clone();
                                    submeshIndex = (submeshIndex + 1) | 0;
                                }
                                current.startSlot = i;
                                lastPreActiveClipping = clippingAttachmentSource;
                                current.rawTriangleCount = 0;
                                current.rawVertexCount = 0;
                                current.rawFirstVertexIndex = totalRawVertexCount;
                                current.hasClipping = clippingAttachmentSource >= 0;
                            }

                            // Update state for the next Attachment.
                            current.material = material.v;
                            current.rawTriangleCount = (current.rawTriangleCount + attachmentTriangleCount) | 0;
                            current.rawVertexCount = (current.rawVertexCount + attachmentVertexCount) | 0;
                            current.rawFirstVertexIndex = totalRawVertexCount;
                            totalRawVertexCount = (totalRawVertexCount + attachmentVertexCount) | 0;
                        }

                        if (clippingEndSlot != null && Bridge.referenceEquals(slot.data, clippingEndSlot) && i !== clippingAttachmentSource) {
                            clippingEndSlot = null;
                            clippingAttachmentSource = -1;
                        }
                    }

                    if (current.rawVertexCount > 0) {
                        { // Add last or only submesh.
                            current.endSlot = drawOrderCount;
                            current.preActiveClippingSlotSource = lastPreActiveClipping;
                            current.forceSeparate = false;

                            workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                            workingSubmeshInstructions.Items[submeshIndex] = current.$clone();
                            //submeshIndex++;
                        }
                    }

                    instructionOutput.hasActiveClipping = skeletonHasClipping;
                    instructionOutput.rawVertexCount = totalRawVertexCount;
                    instructionOutput.immutableTriangles = immutableTriangles;
                },
                /*Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction:static end.*/

                /*Spine.Unity.MeshGenerator.TryReplaceMaterials:static start.*/
                TryReplaceMaterials: function (workingSubmeshInstructions, customMaterialOverride) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#TryReplaceMaterials", this ); }

                    // Material overrides are done here so they can be applied per submesh instead of per slot
                    // but they will still be passed through the GenerateMeshOverride delegate,
                    // and will still go through the normal material match check step in STEP 3.
                    var wsii = workingSubmeshInstructions.Items;
                    for (var i = 0; i < workingSubmeshInstructions.Count; i = (i + 1) | 0) {
                        var m = wsii[i].material;
                        var mo = { };
                        if (customMaterialOverride.tryGetValue(m, mo)) {
                            wsii[i].material = mo.v;
                        }
                    }
                },
                /*Spine.Unity.MeshGenerator.TryReplaceMaterials:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize:static start.*/
                /**
                 * Step 1 of solving tangents. Ensure you have buffers of the correct size.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {UnityEngine.Vector4}    tangentBuffer         Eventual Vector4[] tangent buffer to assign to Mesh.tangents.
                 * @param   {UnityEngine.Vector2}    tempTanBuffer         Temporary Vector2 buffer for calculating directions.
                 * @param   {number}                 vertexCount           Number of vertices that require tangents (or the size of the vertex array)
                 * @param   {number}                 vertexBufferLength
                 * @return  {void}
                 */
                SolveTangents2DEnsureSize: function (tangentBuffer, tempTanBuffer, vertexCount, vertexBufferLength) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DEnsureSize", this ); }

                    if (tangentBuffer.v == null || tangentBuffer.v.length !== vertexBufferLength) {
                        tangentBuffer.v = System.Array.init(vertexBufferLength, function (){
                            return new UnityEngine.Vector4();
                        }, UnityEngine.Vector4);
                    }

                    if (tempTanBuffer.v == null || tempTanBuffer.v.length < Bridge.Int.mul(vertexCount, 2)) {
                        tempTanBuffer.v = System.Array.init(Bridge.Int.mul(vertexCount, 2), function (){
                            return new UnityEngine.Vector2();
                        }, UnityEngine.Vector2);
                    } // two arrays in one.
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DTriangles:static start.*/
                /**
                 * Step 2 of solving tangents. Fills (part of) a temporary tangent-solution buffer based on the vertices and uvs defined by a submesh's triangle buffer. Only needs to be called once for single-submesh meshes.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Array.<UnityEngine.Vector2>}    tempTanBuffer    A temporary Vector3[] for calculating tangents.
                 * @param   {Array.<number>}                 triangles        The mesh's current triangles buffer.
                 * @param   {number}                         triangleCount    The number of triangle indexes in the triangle array to be used.
                 * @param   {Array.<UnityEngine.Vector3>}    vertices         The mesh's current vertex position buffer.
                 * @param   {Array.<UnityEngine.Vector2>}    uvs              The mesh's current uvs buffer.
                 * @param   {number}                         vertexCount      Number of vertices that require tangents (or the size of the vertex array)
                 * @return  {void}
                 */
                SolveTangents2DTriangles: function (tempTanBuffer, triangles, triangleCount, vertices, uvs, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DTriangles", this ); }

                    var $t, $t1;
                    var sdir = new UnityEngine.Vector2();
                    var tdir = new UnityEngine.Vector2();
                    for (var t = 0; t < triangleCount; t = (t + 3) | 0) {
                        var i1 = triangles[((t + 0) | 0)];
                        var i2 = triangles[((t + 1) | 0)];
                        var i3 = triangles[((t + 2) | 0)];

                        var v1 = vertices[i1].$clone();
                        var v2 = vertices[i2].$clone();
                        var v3 = vertices[i3].$clone();

                        var w1 = uvs[i1].$clone();
                        var w2 = uvs[i2].$clone();
                        var w3 = uvs[i3].$clone();

                        var x1 = v2.x - v1.x;
                        var x2 = v3.x - v1.x;
                        var y1 = v2.y - v1.y;
                        var y2 = v3.y - v1.y;

                        var s1 = w2.x - w1.x;
                        var s2 = w3.x - w1.x;
                        var t1 = w2.y - w1.y;
                        var t2 = w3.y - w1.y;

                        var div = s1 * t2 - s2 * t1;
                        var r = (div === 0.0) ? 0.0 : 1.0 / div;

                        sdir.x = (t2 * x1 - t1 * x2) * r;
                        sdir.y = (t2 * y1 - t1 * y2) * r;
                        tempTanBuffer[i1] = ($t = (tempTanBuffer[i3] = sdir.$clone(), sdir.$clone()), tempTanBuffer[i2] = $t.$clone(), $t);

                        tdir.x = (s1 * x2 - s2 * x1) * r;
                        tdir.y = (s1 * y2 - s2 * y1) * r;
                        tempTanBuffer[((vertexCount + i1) | 0)] = ($t1 = (tempTanBuffer[((vertexCount + i3) | 0)] = tdir.$clone(), tdir.$clone()), tempTanBuffer[((vertexCount + i2) | 0)] = $t1.$clone(), $t1);
                    }
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DTriangles:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DBuffer:static start.*/
                /**
                 * Step 3 of solving tangents. Fills a Vector4[] tangents array according to values calculated in step 2.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Array.<UnityEngine.Vector4>}    tangents         A Vector4[] that will eventually be used to set Mesh.tangents
                 * @param   {Array.<UnityEngine.Vector2>}    tempTanBuffer    A temporary Vector3[] for calculating tangents.
                 * @param   {number}                         vertexCount      Number of vertices that require tangents (or the size of the vertex array)
                 * @return  {void}
                 */
                SolveTangents2DBuffer: function (tangents, tempTanBuffer, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DBuffer", this ); }

                    var tangent = new UnityEngine.Vector4();
                    tangent.z = 0;
                    for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                        var t = tempTanBuffer[i].$clone();

                        // t.Normalize() (aggressively inlined). Even better if offloaded to GPU via vertex shader.
                        var magnitude = Math.sqrt(t.x * t.x + t.y * t.y);
                        if (magnitude > 1E-05) {
                            var reciprocalMagnitude = 1.0 / magnitude;
                            t.x *= reciprocalMagnitude;
                            t.y *= reciprocalMagnitude;
                        }

                        var t2 = tempTanBuffer[((vertexCount + i) | 0)].$clone();
                        tangent.x = t.x;
                        tangent.y = t.y;
                        //tangent.z = 0;
                        tangent.w = (t.y * t2.x > t.x * t2.y) ? 1 : -1; // 2D direction calculation. Used for binormals.
                        tangents[i] = tangent.$clone();
                    }
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DBuffer:static end.*/

                /*Spine.Unity.MeshGenerator.FillMeshLocal$1:static start.*/
                /**
                 * Fills mesh vertex data to render a RegionAttachment.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {UnityEngine.Mesh}          mesh                
                 * @param   {Spine.RegionAttachment}    regionAttachment
                 * @return  {void}
                 */
                FillMeshLocal$1: function (mesh, regionAttachment) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillMeshLocal$1", this ); }

                    if (mesh == null) {
                        return;
                    }
                    if (regionAttachment == null) {
                        return;
                    }

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    var offsets = regionAttachment.offset;
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[Spine.RegionAttachment.BLX], offsets[Spine.RegionAttachment.BLY], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[Spine.RegionAttachment.ULX], offsets[Spine.RegionAttachment.ULY], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[Spine.RegionAttachment.URX], offsets[Spine.RegionAttachment.URY], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[Spine.RegionAttachment.BRX], offsets[Spine.RegionAttachment.BRY], 0 ));

                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    var uvs = regionAttachment.uvs;
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[Spine.RegionAttachment.ULX], uvs[Spine.RegionAttachment.ULY] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[Spine.RegionAttachment.URX], uvs[Spine.RegionAttachment.URY] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[Spine.RegionAttachment.BRX], uvs[Spine.RegionAttachment.BRY] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[Spine.RegionAttachment.BLX], uvs[Spine.RegionAttachment.BLY] ));

                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    var c = UnityEngine.Color32.op_Implicit$1((new pc.Color( regionAttachment.color.r, regionAttachment.color.g, regionAttachment.color.b, regionAttachment.color.a )));
                    for (var i = 0; i < 4; i = (i + 1) | 0) {
                        Spine.Unity.MeshGenerator.AttachmentColors32.add(c.$clone());
                    }

                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.AddRange(System.Array.init([0, 2, 1, 0, 3, 2], System.Int32));

                    mesh.Clear();
                    mesh.name = regionAttachment.name;
                    mesh.SetVertices(Spine.Unity.MeshGenerator.AttachmentVerts);
                    mesh.SetUVs(0, Spine.Unity.MeshGenerator.AttachmentUVs);
                    mesh.SetColors$1(Spine.Unity.MeshGenerator.AttachmentColors32);
                    mesh.SetTriangles(Spine.Unity.MeshGenerator.AttachmentIndices, 0);
                    mesh.RecalculateBounds();

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                },
                /*Spine.Unity.MeshGenerator.FillMeshLocal$1:static end.*/

                /*Spine.Unity.MeshGenerator.FillMeshLocal:static start.*/
                FillMeshLocal: function (mesh, meshAttachment, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillMeshLocal", this ); }

                    var $t;
                    if (mesh == null) {
                        return;
                    }
                    if (meshAttachment == null) {
                        return;
                    }
                    var vertexCount = (Bridge.Int.div(meshAttachment.worldVerticesLength, 2)) | 0;

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    if (Spine.SpineSkeletonExtensions.IsWeighted(meshAttachment)) {
                        var count = meshAttachment.worldVerticesLength;
                        var meshAttachmentBones = meshAttachment.bones;
                        var v = 0;

                        var vertices = meshAttachment.vertices;
                        for (var w = 0, b = 0; w < count; w = (w + 2) | 0) {
                            var wx = 0, wy = 0;
                            var n = meshAttachmentBones[Bridge.identity(v, ((v = (v + 1) | 0)))];
                            n = (n + v) | 0;
                            for (; v < n; v = (v + 1) | 0, b = (b + 3) | 0) {
                                var bm = Spine.BoneMatrix.CalculateSetupWorld(($t = skeletonData.Bones.Items)[meshAttachmentBones[v]]);
                                var vx = vertices[b], vy = vertices[((b + 1) | 0)], weight = vertices[((b + 2) | 0)];
                                wx += (vx * bm.a + vy * bm.b + bm.x) * weight;
                                wy += (vx * bm.c + vy * bm.d + bm.y) * weight;
                            }
                            Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( wx, wy, 0 ));
                        }
                    } else {
                        var localVerts = meshAttachment.vertices;
                        var pos = Bridge.getDefaultValue(UnityEngine.Vector3);
                        for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                            var ii = Bridge.Int.mul(i, 2);
                            pos.x = localVerts[ii];
                            pos.y = localVerts[((ii + 1) | 0)];
                            Spine.Unity.MeshGenerator.AttachmentVerts.add(pos.$clone());
                        }
                    }

                    var uvs = meshAttachment.uvs;
                    var uv = Bridge.getDefaultValue(UnityEngine.Vector2);
                    var c = UnityEngine.Color32.op_Implicit$1((new pc.Color( meshAttachment.color.r, meshAttachment.color.g, meshAttachment.color.b, meshAttachment.color.a )));
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    for (var i1 = 0; i1 < vertexCount; i1 = (i1 + 1) | 0) {
                        var ii1 = Bridge.Int.mul(i1, 2);
                        uv.x = uvs[ii1];
                        uv.y = uvs[((ii1 + 1) | 0)];
                        Spine.Unity.MeshGenerator.AttachmentUVs.add(uv.$clone());

                        Spine.Unity.MeshGenerator.AttachmentColors32.add(c.$clone());
                    }

                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.AddRange(meshAttachment.triangles);

                    mesh.Clear();
                    mesh.name = meshAttachment.name;
                    mesh.SetVertices(Spine.Unity.MeshGenerator.AttachmentVerts);
                    mesh.SetUVs(0, Spine.Unity.MeshGenerator.AttachmentUVs);
                    mesh.SetColors$1(Spine.Unity.MeshGenerator.AttachmentColors32);
                    mesh.SetTriangles(Spine.Unity.MeshGenerator.AttachmentIndices, 0);
                    mesh.RecalculateBounds();

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                },
                /*Spine.Unity.MeshGenerator.FillMeshLocal:static end.*/


            }
        },
        fields: {
            settings: null,
            vertexBuffer: null,
            uvBuffer: null,
            colorBuffer: null,
            submeshes: null,
            meshBoundsMin: null,
            meshBoundsMax: null,
            meshBoundsThickness: 0,
            submeshIndex: 0,
            clipper: null,
            tempVerts: null,
            regionTriangles: null,
            normals: null,
            tangents: null,
            tempTanBuffer: null,
            uv2: null,
            uv3: null
        },
        props: {
            VertexCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#VertexCount#get", this ); }

                    return this.vertexBuffer.Count;
                }
            },
            /**
             * A set of mesh arrays whose values are modifiable by the user. Modify these values before they are passed to the UnityEngine mesh object in order to see the effect.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.MeshGenerator
             * @function Buffers
             * @type Spine.Unity.MeshGeneratorBuffers
             */
            Buffers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#Buffers#get", this ); }

                    var $t;
                    return ($t = new Spine.Unity.MeshGeneratorBuffers(), $t.vertexCount = this.VertexCount, $t.vertexBuffer = this.vertexBuffer.Items, $t.uvBuffer = this.uvBuffer.Items, $t.colorBuffer = this.colorBuffer.Items, $t.meshGenerator = this, $t);
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#init", this ); }

                this.settings = new Spine.Unity.MeshGenerator.Settings();
                this.meshBoundsMin = new UnityEngine.Vector2();
                this.meshBoundsMax = new UnityEngine.Vector2();
                this.settings = Spine.Unity.MeshGenerator.Settings.Default.$clone();
                this.vertexBuffer = new (Spine.ExposedList$1(UnityEngine.Vector3)).$ctor3(4);
                this.uvBuffer = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(4);
                this.colorBuffer = new (Spine.ExposedList$1(UnityEngine.Color32)).$ctor3(4);
                this.submeshes = function (_o1) {
                        _o1.Add(new (Spine.ExposedList$1(System.Int32)).$ctor3(6));
                        return _o1;
                    }(new (Spine.ExposedList$1(Spine.ExposedList$1(System.Int32))).ctor());
                this.submeshIndex = 0;
                this.clipper = new Spine.SkeletonClipping();
                this.tempVerts = System.Array.init(8, 0, System.Single);
                this.regionTriangles = System.Array.init([
                    0, 
                    1, 
                    2, 
                    2, 
                    3, 
                    0
                ], System.Int32);
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#ctor", this ); }

                this.$initialize();
                this.submeshes.TrimExcess();
            }
        },
        methods: {
            /*Spine.Unity.MeshGenerator.SubmeshIndexCount start.*/
            SubmeshIndexCount: function (submeshIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SubmeshIndexCount", this ); }

                var $t;
                return ($t = this.submeshes.Items)[submeshIndex].Count;
            },
            /*Spine.Unity.MeshGenerator.SubmeshIndexCount end.*/

            /*Spine.Unity.MeshGenerator.Begin start.*/
            Begin: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#Begin", this ); }

                this.vertexBuffer.Clear(false);
                this.colorBuffer.Clear(false);
                this.uvBuffer.Clear(false);
                this.clipper.clipEnd();

                {
                    this.meshBoundsMin.x = Spine.Unity.MeshGenerator.BoundsMinDefault;
                    this.meshBoundsMin.y = Spine.Unity.MeshGenerator.BoundsMinDefault;
                    this.meshBoundsMax.x = Spine.Unity.MeshGenerator.BoundsMaxDefault;
                    this.meshBoundsMax.y = Spine.Unity.MeshGenerator.BoundsMaxDefault;
                    this.meshBoundsThickness = 0.0;
                }

                this.submeshIndex = 0;
                this.submeshes.Count = 1;
                //submeshes.Items[0].Clear(false);
            },
            /*Spine.Unity.MeshGenerator.Begin end.*/

            /*Spine.Unity.MeshGenerator.AddSubmesh start.*/
            AddSubmesh: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#AddSubmesh", this ); }

                var $t, $t1, $t2;
                if (updateTriangles === void 0) { updateTriangles = true; }
                var settings = this.settings.$clone();

                var newSubmeshCount = (this.submeshIndex + 1) | 0;
                if (this.submeshes.Items.length < newSubmeshCount) {
                    this.submeshes.Resize(newSubmeshCount);
                }
                this.submeshes.Count = newSubmeshCount;
                var submesh = ($t = this.submeshes.Items)[this.submeshIndex];
                if (submesh == null) {
                    ($t1 = this.submeshes.Items)[this.submeshIndex] = (submesh = new (Spine.ExposedList$1(System.Int32)).ctor());
                }
                submesh.Clear(false);

                var skeleton = instruction.skeleton;
                var drawOrderItems = skeleton.DrawOrder.Items;

                var color = Bridge.getDefaultValue(UnityEngine.Color32);
                var skeletonA = skeleton.color.a, skeletonR = skeleton.color.r, skeletonG = skeleton.color.g, skeletonB = skeleton.color.b;
                var meshBoundsMin = this.meshBoundsMin.$clone(), meshBoundsMax = this.meshBoundsMax.$clone();

                // Settings
                var zSpacing = settings.zSpacing;
                var pmaVertexColors = settings.pmaVertexColors;
                var tintBlack = settings.tintBlack;
                var useClipping = settings.useClipping && instruction.hasClipping;
                var canvasGroupTintBlack = settings.tintBlack && settings.canvasGroupTintBlack;

                if (useClipping) {
                    if (instruction.preActiveClippingSlotSource >= 0) {
                        var slot = drawOrderItems[instruction.preActiveClippingSlotSource];
                        this.clipper.clipStart(slot, Bridge.as(slot.getAttachment(), spine.ClippingAttachment));
                    }
                }

                for (var slotIndex = instruction.startSlot; slotIndex < instruction.endSlot; slotIndex = (slotIndex + 1) | 0) {
                    var slot1 = drawOrderItems[slotIndex];
                    if (!slot1.bone.isActive()) {
                        this.clipper.clipEndWithSlot( slot1 );
                        continue;
                    }
                    var attachment = slot1.getAttachment();
                    var z = zSpacing * slotIndex;

                    var workingVerts = this.tempVerts;
                    var uvs;
                    var attachmentTriangleIndices;
                    var attachmentVertexCount;
                    var attachmentIndexCount;

                    var c = Bridge.getDefaultValue(UnityEngine.Color);

                    // Identify and prepare values.
                    var region = Bridge.as(attachment, Spine.RegionAttachment);
                    if (region != null) {
                        region.computeWorldVertices(slot1.bone, workingVerts, 0);
                        uvs = region.uvs;
                        attachmentTriangleIndices = this.regionTriangles;
                        c.r = region.color.r;
                        c.g = region.color.g;
                        c.b = region.color.b;
                        c.a = region.color.a;
                        attachmentVertexCount = 4;
                        attachmentIndexCount = 6;
                    } else {
                        var mesh = Bridge.as(attachment, Spine.MeshAttachment);
                        if (mesh != null) {
                            var meshVerticesLength = mesh.worldVerticesLength;
                            if (workingVerts.length < meshVerticesLength) {
                                workingVerts = System.Array.init(meshVerticesLength, 0, System.Single);
                                this.tempVerts = workingVerts;
                            }
                            mesh.computeWorldVertices( slot1, 0, meshVerticesLength, workingVerts, 0, 2 || 2 ); //meshAttachment.ComputeWorldVertices(slot, tempVerts);
                            uvs = mesh.uvs;
                            attachmentTriangleIndices = mesh.triangles;
                            c.r = mesh.color.r;
                            c.g = mesh.color.g;
                            c.b = mesh.color.b;
                            c.a = mesh.color.a;
                            attachmentVertexCount = meshVerticesLength >> 1; // meshVertexCount / 2;
                            attachmentIndexCount = mesh.triangles.length;
                        } else {
                            if (useClipping) {
                                var clippingAttachment = Bridge.as(attachment, spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    this.clipper.clipStart(slot1, clippingAttachment);
                                    continue;
                                }
                            }

                            // If not any renderable attachment.
                            this.clipper.clipEndWithSlot( slot1 );
                            continue;
                        }
                    }

                    var tintBlackAlpha = 1.0;
                    if (pmaVertexColors) {
                        var colorA = skeletonA * slot1.color.a * c.a;
                        color.a = Bridge.Int.clipu8(colorA * 255);
                        color.r = Bridge.Int.clipu8(skeletonR * slot1.color.r * c.r * color.a);
                        color.g = Bridge.Int.clipu8(skeletonG * slot1.color.g * c.g * color.a);
                        color.b = Bridge.Int.clipu8(skeletonB * slot1.color.b * c.b * color.a);
                        if (slot1.data.blendMode === spine.BlendMode.Additive) {
                            if (canvasGroupTintBlack) {
                                tintBlackAlpha = 0;
                            } else {
                                color.a = 0;
                            }
                        } else if (canvasGroupTintBlack) { // other blend modes
                            tintBlackAlpha = colorA;
                        }
                    } else {
                        color.a = Bridge.Int.clipu8(skeletonA * slot1.color.a * c.a * 255);
                        color.r = Bridge.Int.clipu8(skeletonR * slot1.color.r * c.r * 255);
                        color.g = Bridge.Int.clipu8(skeletonG * slot1.color.g * c.g * 255);
                        color.b = Bridge.Int.clipu8(skeletonB * slot1.color.b * c.b * 255);
                    }

                    if (useClipping && this.clipper.isClipping()) {
                        this.clipper.ClipTriangles(workingVerts, attachmentVertexCount << 1, attachmentTriangleIndices, attachmentIndexCount, uvs);
                        workingVerts = this.clipper.ClippedVertices.Items;
                        attachmentVertexCount = this.clipper.ClippedVertices.Count >> 1;
                        attachmentTriangleIndices = this.clipper.ClippedTriangles.Items;
                        attachmentIndexCount = this.clipper.ClippedTriangles.Count;
                        uvs = this.clipper.ClippedUVs.Items;
                    }

                    // Actually add slot/attachment data into buffers.
                    if (attachmentVertexCount !== 0 && attachmentIndexCount !== 0) {
                        if (tintBlack) {
                            var r2 = slot1.darkColor.r || 0;
                            var g2 = slot1.darkColor.g || 0;
                            var b2 = slot1.darkColor.b || 0;
                            if (pmaVertexColors) {
                                var alpha = skeletonA * slot1.color.a * c.a;
                                r2 *= alpha;
                                g2 *= alpha;
                                b2 *= alpha;
                            }
                            this.AddAttachmentTintBlack(r2, g2, b2, tintBlackAlpha, attachmentVertexCount);
                        }

                        //AddAttachment(workingVerts, uvs, color, attachmentTriangleIndices, attachmentVertexCount, attachmentIndexCount, ref meshBoundsMin, ref meshBoundsMax, z);
                        var ovc = this.vertexBuffer.Count;
                        // Add data to vertex buffers
                        {
                            var newVertexCount = (ovc + attachmentVertexCount) | 0;
                            var oldArraySize = this.vertexBuffer.Items.length;
                            if (newVertexCount > oldArraySize) {
                                var newArraySize = Bridge.Int.clip32(oldArraySize * 1.3);
                                if (newArraySize < newVertexCount) {
                                    newArraySize = newVertexCount;
                                }
                                System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector3);
                                }, UnityEngine.Vector3);
                                System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Color32);
                                }, UnityEngine.Color32);
                            }
                            this.vertexBuffer.Count = ($t2 = (this.colorBuffer.Count = newVertexCount, newVertexCount), this.uvBuffer.Count = $t2, $t2);
                        }

                        var vbi = this.vertexBuffer.Items;
                        var ubi = this.uvBuffer.Items;
                        var cbi = this.colorBuffer.Items;
                        if (ovc === 0) {
                            for (var i = 0; i < attachmentVertexCount; i = (i + 1) | 0) {
                                var vi = (ovc + i) | 0;
                                var i2 = i << 1; // i * 2
                                var x = workingVerts[i2];
                                var y = workingVerts[((i2 + 1) | 0)];

                                vbi[vi].x = x;
                                vbi[vi].y = y;
                                vbi[vi].z = z;
                                ubi[vi].x = uvs[i2];
                                ubi[vi].y = uvs[((i2 + 1) | 0)];
                                cbi[vi] = color.$clone();

                                // Calculate bounds.
                                if (x < meshBoundsMin.x) {
                                    meshBoundsMin.x = x;
                                }
                                if (x > meshBoundsMax.x) {
                                    meshBoundsMax.x = x;
                                }
                                if (y < meshBoundsMin.y) {
                                    meshBoundsMin.y = y;
                                }
                                if (y > meshBoundsMax.y) {
                                    meshBoundsMax.y = y;
                                }
                            }
                        } else {
                            for (var i1 = 0; i1 < attachmentVertexCount; i1 = (i1 + 1) | 0) {
                                var vi1 = (ovc + i1) | 0;
                                var i21 = i1 << 1; // i * 2
                                var x1 = workingVerts[i21];
                                var y1 = workingVerts[((i21 + 1) | 0)];

                                vbi[vi1].x = x1;
                                vbi[vi1].y = y1;
                                vbi[vi1].z = z;
                                ubi[vi1].x = uvs[i21];
                                ubi[vi1].y = uvs[((i21 + 1) | 0)];
                                cbi[vi1] = color.$clone();

                                // Calculate bounds.
                                if (x1 < meshBoundsMin.x) {
                                    meshBoundsMin.x = x1;
                                } else {
                                    if (x1 > meshBoundsMax.x) {
                                        meshBoundsMax.x = x1;
                                    }
                                }
                                if (y1 < meshBoundsMin.y) {
                                    meshBoundsMin.y = y1;
                                } else {
                                    if (y1 > meshBoundsMax.y) {
                                        meshBoundsMax.y = y1;
                                    }
                                }
                            }
                        }


                        // Add data to triangle buffer
                        if (updateTriangles) {
                            var oldTriangleCount = submesh.Count;
                            { //submesh.Resize(oldTriangleCount + attachmentIndexCount);
                                var newTriangleCount = (oldTriangleCount + attachmentIndexCount) | 0;
                                if (newTriangleCount > submesh.Items.length) {
                                    System.Array.resize(Bridge.ref(submesh, "Items"), newTriangleCount, 0, System.Int32);
                                }
                                submesh.Count = newTriangleCount;
                            }
                            var submeshItems = submesh.Items;
                            for (var i2 = 0; i2 < attachmentIndexCount; i2 = (i2 + 1) | 0) {
                                submeshItems[((oldTriangleCount + i2) | 0)] = (attachmentTriangleIndices[i2] + ovc) | 0;
                            }
                        }
                    }

                    this.clipper.clipEndWithSlot( slot1 );
                }
                this.clipper.clipEnd();

                this.meshBoundsMin = meshBoundsMin.$clone();
                this.meshBoundsMax = meshBoundsMax.$clone();
                this.meshBoundsThickness = instruction.endSlot * zSpacing;

                // Trim or zero submesh triangles.
                var currentSubmeshItems = submesh.Items;
                for (var i3 = submesh.Count, n = currentSubmeshItems.length; i3 < n; i3 = (i3 + 1) | 0) {
                    currentSubmeshItems[i3] = 0;
                }

                this.submeshIndex = (this.submeshIndex + 1) | 0; // Next AddSubmesh will use a new submeshIndex value.
            },
            /*Spine.Unity.MeshGenerator.AddSubmesh end.*/

            /*Spine.Unity.MeshGenerator.BuildMesh start.*/
            BuildMesh: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#BuildMesh", this ); }

                var wsii = instruction.submeshInstructions.Items;
                for (var i = 0, n = instruction.submeshInstructions.Count; i < n; i = (i + 1) | 0) {
                    this.AddSubmesh(wsii[i], updateTriangles);
                }
            },
            /*Spine.Unity.MeshGenerator.BuildMesh end.*/

            /*Spine.Unity.MeshGenerator.BuildMeshWithArrays start.*/
            BuildMeshWithArrays: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#BuildMeshWithArrays", this ); }

                var $t, $t1, $t2, $t3, $t4;
                var settings = this.settings.$clone();
                var canvasGroupTintBlack = settings.tintBlack && settings.canvasGroupTintBlack;
                var totalVertexCount = instruction.rawVertexCount;

                // Add data to vertex buffers
                {
                    if (totalVertexCount > this.vertexBuffer.Items.length) { // Manual ExposedList.Resize()
                        System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector3);
                        }, UnityEngine.Vector3);
                        System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                        System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Color32);
                        }, UnityEngine.Color32);
                    }
                    this.vertexBuffer.Count = ($t = (this.colorBuffer.Count = totalVertexCount, totalVertexCount), this.uvBuffer.Count = $t, $t);
                }

                // Populate Verts
                var color = Bridge.getDefaultValue(UnityEngine.Color32);

                var vertexIndex = 0;
                var tempVerts = this.tempVerts;
                var bmin = this.meshBoundsMin.$clone();
                var bmax = this.meshBoundsMax.$clone();

                var vbi = this.vertexBuffer.Items;
                var ubi = this.uvBuffer.Items;
                var cbi = this.colorBuffer.Items;
                var lastSlotIndex = 0;

                // drawOrder[endSlot] is excluded
                for (var si = 0, n = instruction.submeshInstructions.Count; si < n; si = (si + 1) | 0) {
                    var submesh = ($t1 = instruction.submeshInstructions.Items)[si].$clone();
                    var skeleton = submesh.skeleton;
                    var drawOrderItems = skeleton.DrawOrder.Items;
                    var a = skeleton.color.a, r = skeleton.color.r, g = skeleton.color.g, b = skeleton.color.b;

                    var endSlot = submesh.endSlot;
                    var startSlot = submesh.startSlot;
                    lastSlotIndex = endSlot;

                    if (settings.tintBlack) {
                        var rg = new UnityEngine.Vector2(), b2 = new UnityEngine.Vector2();
                        var vi = vertexIndex;
                        b2.y = 1.0;

                        {
                            if (this.uv2 == null) {
                                this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                                this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                            }
                            if (totalVertexCount > this.uv2.Items.length) { // Manual ExposedList.Resize()
                                System.Array.resize(Bridge.ref(this.uv2, "Items"), totalVertexCount, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.uv3, "Items"), totalVertexCount, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                            }
                            this.uv2.Count = (this.uv3.Count = totalVertexCount, totalVertexCount);
                        }

                        var uv2i = this.uv2.Items;
                        var uv3i = this.uv3.Items;

                        for (var slotIndex = startSlot; slotIndex < endSlot; slotIndex = (slotIndex + 1) | 0) {
                            var slot = drawOrderItems[slotIndex];
                            if (!slot.bone.isActive()) {
                                continue;
                            }
                            var attachment = slot.getAttachment();

                            rg.x = slot.darkColor.r || 0; //r
                            rg.y = slot.darkColor.g || 0; //g
                            b2.x = slot.darkColor.b || 0; //b
                            b2.y = 1.0;

                            var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                            if (regionAttachment != null) {
                                if (settings.pmaVertexColors) {
                                    var alpha = a * slot.color.a * regionAttachment.color.a;
                                    rg.x *= alpha;
                                    rg.y *= alpha;
                                    b2.x *= alpha;
                                    b2.y = slot.data.blendMode === spine.BlendMode.Additive ? 0 : alpha;
                                }
                                uv2i[vi] = rg.$clone();
                                uv2i[((vi + 1) | 0)] = rg.$clone();
                                uv2i[((vi + 2) | 0)] = rg.$clone();
                                uv2i[((vi + 3) | 0)] = rg.$clone();
                                uv3i[vi] = b2.$clone();
                                uv3i[((vi + 1) | 0)] = b2.$clone();
                                uv3i[((vi + 2) | 0)] = b2.$clone();
                                uv3i[((vi + 3) | 0)] = b2.$clone();
                                vi = (vi + 4) | 0;
                            } else { //} if (settings.renderMeshes) {
                                var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                                if (meshAttachment != null) {
                                    if (settings.pmaVertexColors) {
                                        var alpha1 = a * slot.color.a * meshAttachment.color.a;
                                        rg.x *= alpha1;
                                        rg.y *= alpha1;
                                        b2.x *= alpha1;
                                        b2.y = slot.data.blendMode === spine.BlendMode.Additive ? 0 : alpha1;
                                    }
                                    var meshVertexCount = meshAttachment.worldVerticesLength;
                                    for (var iii = 0; iii < meshVertexCount; iii = (iii + 2) | 0) {
                                        uv2i[vi] = rg.$clone();
                                        uv3i[vi] = b2.$clone();
                                        vi = (vi + 1) | 0;
                                    }
                                }
                            }
                        }
                    }

                    for (var slotIndex1 = startSlot; slotIndex1 < endSlot; slotIndex1 = (slotIndex1 + 1) | 0) {
                        var slot1 = drawOrderItems[slotIndex1];
                        if (!slot1.bone.isActive()) {
                            continue;
                        }
                        var attachment1 = slot1.getAttachment();
                        var z = slotIndex1 * settings.zSpacing;

                        var regionAttachment1 = Bridge.as(attachment1, Spine.RegionAttachment);
                        if (regionAttachment1 != null) {
                            regionAttachment1.computeWorldVertices(slot1.bone, tempVerts, 0);

                            var x1 = tempVerts[Spine.RegionAttachment.BLX], y1 = tempVerts[Spine.RegionAttachment.BLY];
                            var x2 = tempVerts[Spine.RegionAttachment.ULX], y2 = tempVerts[Spine.RegionAttachment.ULY];
                            var x3 = tempVerts[Spine.RegionAttachment.URX], y3 = tempVerts[Spine.RegionAttachment.URY];
                            var x4 = tempVerts[Spine.RegionAttachment.BRX], y4 = tempVerts[Spine.RegionAttachment.BRY];
                            vbi[vertexIndex].x = x1;
                            vbi[vertexIndex].y = y1;
                            vbi[vertexIndex].z = z;
                            vbi[((vertexIndex + 1) | 0)].x = x4;
                            vbi[((vertexIndex + 1) | 0)].y = y4;
                            vbi[((vertexIndex + 1) | 0)].z = z;
                            vbi[((vertexIndex + 2) | 0)].x = x2;
                            vbi[((vertexIndex + 2) | 0)].y = y2;
                            vbi[((vertexIndex + 2) | 0)].z = z;
                            vbi[((vertexIndex + 3) | 0)].x = x3;
                            vbi[((vertexIndex + 3) | 0)].y = y3;
                            vbi[((vertexIndex + 3) | 0)].z = z;

                            if (settings.pmaVertexColors) {
                                color.a = Bridge.Int.clipu8(a * slot1.color.a * regionAttachment1.color.a * 255);
                                color.r = Bridge.Int.clipu8(r * slot1.color.r * regionAttachment1.color.r * color.a);
                                color.g = Bridge.Int.clipu8(g * slot1.color.g * regionAttachment1.color.g * color.a);
                                color.b = Bridge.Int.clipu8(b * slot1.color.b * regionAttachment1.color.b * color.a);
                                if (slot1.data.blendMode === spine.BlendMode.Additive && !canvasGroupTintBlack) {
                                    color.a = 0;
                                }
                            } else {
                                color.a = Bridge.Int.clipu8(a * slot1.color.a * regionAttachment1.color.a * 255);
                                color.r = Bridge.Int.clipu8(r * slot1.color.r * regionAttachment1.color.r * 255);
                                color.g = Bridge.Int.clipu8(g * slot1.color.g * regionAttachment1.color.g * 255);
                                color.b = Bridge.Int.clipu8(b * slot1.color.b * regionAttachment1.color.b * 255);
                            }

                            cbi[vertexIndex] = color.$clone();
                            cbi[((vertexIndex + 1) | 0)] = color.$clone();
                            cbi[((vertexIndex + 2) | 0)] = color.$clone();
                            cbi[((vertexIndex + 3) | 0)] = color.$clone();

                            var regionUVs = regionAttachment1.uvs;
                            ubi[vertexIndex].x = regionUVs[Spine.RegionAttachment.BLX];
                            ubi[vertexIndex].y = regionUVs[Spine.RegionAttachment.BLY];
                            ubi[((vertexIndex + 1) | 0)].x = regionUVs[Spine.RegionAttachment.BRX];
                            ubi[((vertexIndex + 1) | 0)].y = regionUVs[Spine.RegionAttachment.BRY];
                            ubi[((vertexIndex + 2) | 0)].x = regionUVs[Spine.RegionAttachment.ULX];
                            ubi[((vertexIndex + 2) | 0)].y = regionUVs[Spine.RegionAttachment.ULY];
                            ubi[((vertexIndex + 3) | 0)].x = regionUVs[Spine.RegionAttachment.URX];
                            ubi[((vertexIndex + 3) | 0)].y = regionUVs[Spine.RegionAttachment.URY];

                            if (x1 < bmin.x) {
                                bmin.x = x1;
                            } // Potential first attachment bounds initialization. Initial min should not block initial max. Same for Y below.
                            if (x1 > bmax.x) {
                                bmax.x = x1;
                            }
                            if (x2 < bmin.x) {
                                bmin.x = x2;
                            } else {
                                if (x2 > bmax.x) {
                                    bmax.x = x2;
                                }
                            }
                            if (x3 < bmin.x) {
                                bmin.x = x3;
                            } else {
                                if (x3 > bmax.x) {
                                    bmax.x = x3;
                                }
                            }
                            if (x4 < bmin.x) {
                                bmin.x = x4;
                            } else {
                                if (x4 > bmax.x) {
                                    bmax.x = x4;
                                }
                            }

                            if (y1 < bmin.y) {
                                bmin.y = y1;
                            }
                            if (y1 > bmax.y) {
                                bmax.y = y1;
                            }
                            if (y2 < bmin.y) {
                                bmin.y = y2;
                            } else {
                                if (y2 > bmax.y) {
                                    bmax.y = y2;
                                }
                            }
                            if (y3 < bmin.y) {
                                bmin.y = y3;
                            } else {
                                if (y3 > bmax.y) {
                                    bmax.y = y3;
                                }
                            }
                            if (y4 < bmin.y) {
                                bmin.y = y4;
                            } else {
                                if (y4 > bmax.y) {
                                    bmax.y = y4;
                                }
                            }

                            vertexIndex = (vertexIndex + 4) | 0;
                        } else { //if (settings.renderMeshes) {
                            var meshAttachment1 = Bridge.as(attachment1, Spine.MeshAttachment);
                            if (meshAttachment1 != null) {
                                var meshVertexCount1 = meshAttachment1.worldVerticesLength;
                                if (tempVerts.length < meshVertexCount1) {
                                    this.tempVerts = (tempVerts = System.Array.init(meshVertexCount1, 0, System.Single));
                                }
                                meshAttachment1.computeWorldVertices( slot1, 0, meshAttachment1.worldVerticesLength, tempVerts, 0, 2 );

                                if (settings.pmaVertexColors) {
                                    color.a = Bridge.Int.clipu8(a * slot1.color.a * meshAttachment1.color.a * 255);
                                    color.r = Bridge.Int.clipu8(r * slot1.color.r * meshAttachment1.color.r * color.a);
                                    color.g = Bridge.Int.clipu8(g * slot1.color.g * meshAttachment1.color.g * color.a);
                                    color.b = Bridge.Int.clipu8(b * slot1.color.b * meshAttachment1.color.b * color.a);
                                    if (slot1.data.blendMode === spine.BlendMode.Additive && !canvasGroupTintBlack) {
                                        color.a = 0;
                                    }
                                } else {
                                    color.a = Bridge.Int.clipu8(a * slot1.color.a * meshAttachment1.color.a * 255);
                                    color.r = Bridge.Int.clipu8(r * slot1.color.r * meshAttachment1.color.r * 255);
                                    color.g = Bridge.Int.clipu8(g * slot1.color.g * meshAttachment1.color.g * 255);
                                    color.b = Bridge.Int.clipu8(b * slot1.color.b * meshAttachment1.color.b * 255);
                                }

                                var attachmentUVs = meshAttachment1.uvs;

                                // Potential first attachment bounds initialization. See conditions in RegionAttachment logic.
                                if (vertexIndex === 0) {
                                    // Initial min should not block initial max.
                                    // vi == vertexIndex does not always mean the bounds are fresh. It could be a submesh. Do not nuke old values by omitting the check.
                                    // Should know that this is the first attachment in the submesh. slotIndex == startSlot could be an empty slot.
                                    var fx = tempVerts[0], fy = tempVerts[1];
                                    if (fx < bmin.x) {
                                        bmin.x = fx;
                                    }
                                    if (fx > bmax.x) {
                                        bmax.x = fx;
                                    }
                                    if (fy < bmin.y) {
                                        bmin.y = fy;
                                    }
                                    if (fy > bmax.y) {
                                        bmax.y = fy;
                                    }
                                }

                                for (var iii1 = 0; iii1 < meshVertexCount1; iii1 = (iii1 + 2) | 0) {
                                    var x = tempVerts[iii1], y = tempVerts[((iii1 + 1) | 0)];
                                    vbi[vertexIndex].x = x;
                                    vbi[vertexIndex].y = y;
                                    vbi[vertexIndex].z = z;
                                    cbi[vertexIndex] = color.$clone();
                                    ubi[vertexIndex].x = attachmentUVs[iii1];
                                    ubi[vertexIndex].y = attachmentUVs[((iii1 + 1) | 0)];

                                    if (x < bmin.x) {
                                        bmin.x = x;
                                    } else {
                                        if (x > bmax.x) {
                                            bmax.x = x;
                                        }
                                    }

                                    if (y < bmin.y) {
                                        bmin.y = y;
                                    } else {
                                        if (y > bmax.y) {
                                            bmax.y = y;
                                        }
                                    }

                                    vertexIndex = (vertexIndex + 1) | 0;
                                }
                            }
                        }
                    }
                }

                this.meshBoundsMin = bmin.$clone();
                this.meshBoundsMax = bmax.$clone();
                this.meshBoundsThickness = lastSlotIndex * settings.zSpacing;

                var submeshInstructionCount = instruction.submeshInstructions.Count;
                this.submeshes.Count = submeshInstructionCount;

                // Add triangles
                if (updateTriangles) {
                    // Match submesh buffers count with submeshInstruction count.
                    if (this.submeshes.Items.length < submeshInstructionCount) {
                        this.submeshes.Resize(submeshInstructionCount);
                        for (var i = 0, n1 = submeshInstructionCount; i < n1; i = (i + 1) | 0) {
                            var submeshBuffer = ($t2 = this.submeshes.Items)[i];
                            if (submeshBuffer == null) {
                                ($t3 = this.submeshes.Items)[i] = new (Spine.ExposedList$1(System.Int32)).ctor();
                            } else {
                                submeshBuffer.Clear(false);
                            }
                        }
                    }

                    var submeshInstructionsItems = instruction.submeshInstructions.Items; // This relies on the resize above.

                    // Fill the buffers.
                    var attachmentFirstVertex = 0;
                    for (var smbi = 0; smbi < submeshInstructionCount; smbi = (smbi + 1) | 0) {
                        var submeshInstruction = submeshInstructionsItems[smbi].$clone();
                        var currentSubmeshBuffer = ($t4 = this.submeshes.Items)[smbi];
                        { //submesh.Resize(submesh.rawTriangleCount);
                            var newTriangleCount = submeshInstruction.rawTriangleCount;
                            if (newTriangleCount > currentSubmeshBuffer.Items.length) {
                                System.Array.resize(Bridge.ref(currentSubmeshBuffer, "Items"), newTriangleCount, 0, System.Int32);
                            } else {
                                if (newTriangleCount < currentSubmeshBuffer.Items.length) {
                                    // Zero the extra.
                                    var sbi = currentSubmeshBuffer.Items;
                                    for (var ei = newTriangleCount, nn = sbi.length; ei < nn; ei = (ei + 1) | 0) {
                                        sbi[ei] = 0;
                                    }
                                }
                            }
                            currentSubmeshBuffer.Count = newTriangleCount;
                        }

                        var tris = currentSubmeshBuffer.Items;
                        var triangleIndex = 0;
                        var skeleton1 = submeshInstruction.skeleton;
                        var drawOrderItems1 = skeleton1.DrawOrder.Items;
                        for (var slotIndex2 = submeshInstruction.startSlot, endSlot1 = submeshInstruction.endSlot; slotIndex2 < endSlot1; slotIndex2 = (slotIndex2 + 1) | 0) {
                            var slot2 = drawOrderItems1[slotIndex2];
                            if (!slot2.bone.isActive()) {
                                continue;
                            }

                            var attachment2 = drawOrderItems1[slotIndex2].getAttachment();
                            if (Bridge.is(attachment2, Spine.RegionAttachment)) {
                                tris[triangleIndex] = attachmentFirstVertex;
                                tris[((triangleIndex + 1) | 0)] = (attachmentFirstVertex + 2) | 0;
                                tris[((triangleIndex + 2) | 0)] = (attachmentFirstVertex + 1) | 0;
                                tris[((triangleIndex + 3) | 0)] = (attachmentFirstVertex + 2) | 0;
                                tris[((triangleIndex + 4) | 0)] = (attachmentFirstVertex + 3) | 0;
                                tris[((triangleIndex + 5) | 0)] = (attachmentFirstVertex + 1) | 0;
                                triangleIndex = (triangleIndex + 6) | 0;
                                attachmentFirstVertex = (attachmentFirstVertex + 4) | 0;
                                continue;
                            }
                            var meshAttachment2 = Bridge.as(attachment2, Spine.MeshAttachment);
                            if (meshAttachment2 != null) {
                                var attachmentTriangles = meshAttachment2.triangles;
                                for (var ii = 0, nn1 = attachmentTriangles.length; ii < nn1; ii = (ii + 1) | 0, triangleIndex = (triangleIndex + 1) | 0) {
                                    tris[triangleIndex] = (attachmentFirstVertex + attachmentTriangles[ii]) | 0;
                                }
                                attachmentFirstVertex = (attachmentFirstVertex + (meshAttachment2.worldVerticesLength >> 1)) | 0; // length/2;
                            }
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.BuildMeshWithArrays end.*/

            /*Spine.Unity.MeshGenerator.ScaleVertexData start.*/
            ScaleVertexData: function (scale) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#ScaleVertexData", this ); }

                var vbi = this.vertexBuffer.Items;
                for (var i = 0, n = this.vertexBuffer.Count; i < n; i = (i + 1) | 0) {
                    vbi[i] = vbi[i].$clone().clone().scale( scale ); // vbi[i].x *= scale; vbi[i].y *= scale;
                }

                this.meshBoundsMin = this.meshBoundsMin.$clone().scale( scale );
                this.meshBoundsMax = this.meshBoundsMax.$clone().scale( scale );
                this.meshBoundsThickness *= scale;
            },
            /*Spine.Unity.MeshGenerator.ScaleVertexData end.*/

            /*Spine.Unity.MeshGenerator.GetMeshBounds start.*/
            GetMeshBounds: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GetMeshBounds", this ); }

                var $t;
                if ((Math.abs(this.meshBoundsMin.x) === Number.POSITIVE_INFINITY)) { // meshBoundsMin.x == BoundsMinDefault // == doesn't work on float Infinity constants.
                    return new pc.BoundingBox.ctor();
                } else {
                    //mesh.bounds = ArraysMeshGenerator.ToBounds(meshBoundsMin, meshBoundsMax);
                    var halfWidth = (this.meshBoundsMax.x - this.meshBoundsMin.x) * 0.5;
                    var halfHeight = (this.meshBoundsMax.y - this.meshBoundsMin.y) * 0.5;
                    return ($t = new pc.BoundingBox.ctor(), $t.center = new pc.Vec3( this.meshBoundsMin.x + halfWidth, this.meshBoundsMin.y + halfHeight, 0 ), $t.halfExtents = new pc.Vec3( halfWidth, halfHeight, this.meshBoundsThickness * 0.5 ), $t);
                }
            },
            /*Spine.Unity.MeshGenerator.GetMeshBounds end.*/

            /*Spine.Unity.MeshGenerator.AddAttachmentTintBlack start.*/
            AddAttachmentTintBlack: function (r2, g2, b2, a, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#AddAttachmentTintBlack", this ); }

                var rg = new pc.Vec2( r2, g2 );
                var bo = new pc.Vec2( b2, a );

                var ovc = this.vertexBuffer.Count;
                var newVertexCount = (ovc + vertexCount) | 0;
                {
                    if (this.uv2 == null) {
                        this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                        this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                    }
                    if (newVertexCount > this.uv2.Items.length) { // Manual ExposedList.Resize()
                        System.Array.resize(Bridge.ref(this.uv2, "Items"), newVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                        System.Array.resize(Bridge.ref(this.uv3, "Items"), newVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                    }
                    this.uv2.Count = (this.uv3.Count = newVertexCount, newVertexCount);
                }

                var uv2i = this.uv2.Items;
                var uv3i = this.uv3.Items;
                for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                    uv2i[((ovc + i) | 0)] = rg.$clone();
                    uv3i[((ovc + i) | 0)] = bo.$clone();
                }
            },
            /*Spine.Unity.MeshGenerator.AddAttachmentTintBlack end.*/

            /*Spine.Unity.MeshGenerator.FillVertexData start.*/
            FillVertexData: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillVertexData", this ); }

                var vbi = this.vertexBuffer.Items;
                var ubi = this.uvBuffer.Items;
                var cbi = this.colorBuffer.Items;
                var vbiLength = vbi.length;

                // Zero the extra.
                {
                    var listCount = this.vertexBuffer.Count;
                    var vector3zero = pc.Vec3.ZERO.clone();
                    for (var i = listCount; i < vbiLength; i = (i + 1) | 0) {
                        vbi[i] = vector3zero.$clone();
                    }
                }

                // Set the vertex buffer.
                {
                    mesh.vertices = vbi;
                    mesh.uv = ubi;
                    mesh.colors32 = cbi;
                    mesh.bounds = this.GetMeshBounds();
                }

                {
                    if (this.settings.addNormals) {
                        var oldLength = 0;

                        if (this.normals == null) {
                            this.normals = System.Array.init(vbiLength, function (){
                                return new UnityEngine.Vector3();
                            }, UnityEngine.Vector3);
                        } else {
                            oldLength = this.normals.length;
                        }

                        if (oldLength !== vbiLength) {
                            System.Array.resize(Bridge.ref(this, "normals"), vbiLength, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector3);
                            }, UnityEngine.Vector3);
                            var localNormals = this.normals;
                            for (var i1 = oldLength; i1 < vbiLength; i1 = (i1 + 1) | 0) {
                                localNormals[i1] = new pc.Vec3( 0, 0, -1 );
                            }
                        }
                        mesh.normals = this.normals;
                    }

                    if (this.settings.tintBlack) {
                        if (this.uv2 != null) {
                            // Sometimes, the vertex buffer becomes smaller. We need to trim the size of the tint black buffers to match.
                            if (vbiLength !== this.uv2.Items.length) {
                                System.Array.resize(Bridge.ref(this.uv2, "Items"), vbiLength, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.uv3, "Items"), vbiLength, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                this.uv2.Count = (this.uv3.Count = vbiLength, vbiLength);
                            }
                            mesh.uv2 = this.uv2.Items;
                            mesh.uv3 = this.uv3.Items;
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.FillVertexData end.*/

            /*Spine.Unity.MeshGenerator.FillLateVertexData start.*/
            FillLateVertexData: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillLateVertexData", this ); }

                if (this.settings.calculateTangents) {
                    var vertexCount = this.vertexBuffer.Count;
                    var sbi = this.submeshes.Items;
                    var submeshCount = this.submeshes.Count;
                    var vbi = this.vertexBuffer.Items;
                    var ubi = this.uvBuffer.Items;

                    Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize(Bridge.ref(this, "tangents"), Bridge.ref(this, "tempTanBuffer"), vertexCount, vbi.length);
                    for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                        var submesh = sbi[i].Items;
                        var triangleCount = sbi[i].Count;
                        Spine.Unity.MeshGenerator.SolveTangents2DTriangles(this.tempTanBuffer, submesh, triangleCount, vbi, ubi, vertexCount);
                    }
                    Spine.Unity.MeshGenerator.SolveTangents2DBuffer(this.tangents, this.tempTanBuffer, vertexCount);
                    mesh.tangents = this.tangents;
                }
            },
            /*Spine.Unity.MeshGenerator.FillLateVertexData end.*/

            /*Spine.Unity.MeshGenerator.FillTriangles start.*/
            FillTriangles: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillTriangles", this ); }

                var submeshCount = this.submeshes.Count;
                var submeshesItems = this.submeshes.Items;
                mesh.subMeshCount = submeshCount;

                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    mesh.SetTriangles$4(submeshesItems[i].Items, 0, submeshesItems[i].Count, i, false);
                }
            },
            /*Spine.Unity.MeshGenerator.FillTriangles end.*/

            /*Spine.Unity.MeshGenerator.EnsureVertexCapacity start.*/
            EnsureVertexCapacity: function (minimumVertexCount, inlcudeTintBlack, includeTangents, includeNormals) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#EnsureVertexCapacity", this ); }

                if (inlcudeTintBlack === void 0) { inlcudeTintBlack = false; }
                if (includeTangents === void 0) { includeTangents = false; }
                if (includeNormals === void 0) { includeNormals = false; }
                if (minimumVertexCount > this.vertexBuffer.Items.length) {
                    System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, UnityEngine.Vector3);
                    System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector2);
                    }, UnityEngine.Vector2);
                    System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Color32);
                    }, UnityEngine.Color32);

                    if (inlcudeTintBlack) {
                        if (this.uv2 == null) {
                            this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(minimumVertexCount);
                            this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(minimumVertexCount);
                        }
                        this.uv2.Resize(minimumVertexCount);
                        this.uv3.Resize(minimumVertexCount);
                    }

                    if (includeNormals) {
                        if (this.normals == null) {
                            this.normals = System.Array.init(minimumVertexCount, function (){
                                return new UnityEngine.Vector3();
                            }, UnityEngine.Vector3);
                        } else {
                            System.Array.resize(Bridge.ref(this, "normals"), minimumVertexCount, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector3);
                            }, UnityEngine.Vector3);
                        }

                    }

                    if (includeTangents) {
                        if (this.tangents == null) {
                            this.tangents = System.Array.init(minimumVertexCount, function (){
                                return new UnityEngine.Vector4();
                            }, UnityEngine.Vector4);
                        } else {
                            System.Array.resize(Bridge.ref(this, "tangents"), minimumVertexCount, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector4);
                            }, UnityEngine.Vector4);
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.EnsureVertexCapacity end.*/

            /*Spine.Unity.MeshGenerator.TrimExcess start.*/
            /**
             * Trims internal buffers to reduce the resulting mesh data stream size.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshGenerator
             * @memberof Spine.Unity.MeshGenerator
             * @return  {void}
             */
            TrimExcess: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#TrimExcess", this ); }

                this.vertexBuffer.TrimExcess();
                this.uvBuffer.TrimExcess();
                this.colorBuffer.TrimExcess();

                if (this.uv2 != null) {
                    this.uv2.TrimExcess();
                }
                if (this.uv3 != null) {
                    this.uv3.TrimExcess();
                }

                var vbiLength = this.vertexBuffer.Items.length;
                if (this.normals != null) {
                    System.Array.resize(Bridge.ref(this, "normals"), vbiLength, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, UnityEngine.Vector3);
                }
                if (this.tangents != null) {
                    System.Array.resize(Bridge.ref(this, "tangents"), vbiLength, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector4);
                    }, UnityEngine.Vector4);
                }
            },
            /*Spine.Unity.MeshGenerator.TrimExcess end.*/


        }
    });
    /*Spine.Unity.MeshGenerator end.*/

    /*Spine.Unity.MeshGenerator+Settings start.*/
    Bridge.define("Spine.Unity.MeshGenerator.Settings", {
        $kind: 1004,
        statics: {
            props: {
                Default: {
                    get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#Default#get", this ); }

                        var $t;
                        return ($t = new Spine.Unity.MeshGenerator.Settings(), $t.pmaVertexColors = true, $t.zSpacing = 0.0, $t.useClipping = true, $t.tintBlack = false, $t.calculateTangents = false, $t.addNormals = false, $t.immutableTriangles = false, $t);
                    }
                }
            },
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#getDefaultValue", this ); }
 return new Spine.Unity.MeshGenerator.Settings(); }
            }
        },
        fields: {
            useClipping: false,
            zSpacing: 0,
            pmaVertexColors: false,
            tintBlack: false,
            canvasGroupTintBlack: false,
            calculateTangents: false,
            addNormals: false,
            immutableTriangles: false
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#getHashCode", this ); }

                var h = Bridge.addHash([3889943484, this.useClipping, this.zSpacing, this.pmaVertexColors, this.tintBlack, this.canvasGroupTintBlack, this.calculateTangents, this.addNormals, this.immutableTriangles]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.MeshGenerator.Settings)) {
                    return false;
                }
                return Bridge.equals(this.useClipping, o.useClipping) && Bridge.equals(this.zSpacing, o.zSpacing) && Bridge.equals(this.pmaVertexColors, o.pmaVertexColors) && Bridge.equals(this.tintBlack, o.tintBlack) && Bridge.equals(this.canvasGroupTintBlack, o.canvasGroupTintBlack) && Bridge.equals(this.calculateTangents, o.calculateTangents) && Bridge.equals(this.addNormals, o.addNormals) && Bridge.equals(this.immutableTriangles, o.immutableTriangles);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#$clone", this ); }

                var s = to || new Spine.Unity.MeshGenerator.Settings();
                s.useClipping = this.useClipping;
                s.zSpacing = this.zSpacing;
                s.pmaVertexColors = this.pmaVertexColors;
                s.tintBlack = this.tintBlack;
                s.canvasGroupTintBlack = this.canvasGroupTintBlack;
                s.calculateTangents = this.calculateTangents;
                s.addNormals = this.addNormals;
                s.immutableTriangles = this.immutableTriangles;
                return s;
            }
        }
    });
    /*Spine.Unity.MeshGenerator+Settings end.*/

    /*Spine.Unity.MeshGeneratorBuffers start.*/
    Bridge.define("Spine.Unity.MeshGeneratorBuffers", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#getDefaultValue", this ); }
 return new Spine.Unity.MeshGeneratorBuffers(); }
            }
        },
        fields: {
            /**
             * The vertex count that will actually be used for the mesh. The Lengths of the buffer arrays may be larger than this number.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type number
             */
            vertexCount: 0,
            /**
             * Vertex positions. To be used for UnityEngine.Mesh.vertices.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Vector3>
             */
            vertexBuffer: null,
            /**
             * Vertex UVs. To be used for UnityEngine.Mesh.uvs.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Vector2>
             */
            uvBuffer: null,
            /**
             * Vertex colors. To be used for UnityEngine.Mesh.colors32.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Color32>
             */
            colorBuffer: null,
            /**
             * The Spine rendering component's MeshGenerator.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Spine.Unity.MeshGenerator
             */
            meshGenerator: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#getHashCode", this ); }

                var h = Bridge.addHash([8979862494, this.vertexCount, this.vertexBuffer, this.uvBuffer, this.colorBuffer, this.meshGenerator]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.MeshGeneratorBuffers)) {
                    return false;
                }
                return Bridge.equals(this.vertexCount, o.vertexCount) && Bridge.equals(this.vertexBuffer, o.vertexBuffer) && Bridge.equals(this.uvBuffer, o.uvBuffer) && Bridge.equals(this.colorBuffer, o.colorBuffer) && Bridge.equals(this.meshGenerator, o.meshGenerator);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#$clone", this ); }

                var s = to || new Spine.Unity.MeshGeneratorBuffers();
                s.vertexCount = this.vertexCount;
                s.vertexBuffer = this.vertexBuffer;
                s.uvBuffer = this.uvBuffer;
                s.colorBuffer = this.colorBuffer;
                s.meshGenerator = this.meshGenerator;
                return s;
            }
        }
    });
    /*Spine.Unity.MeshGeneratorBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers start.*/
    /**
     * A double-buffered Mesh, and a shared material array, bundled for use by Spine components that need to push a Mesh and materials to a Unity MeshRenderer and MeshFilter.
     *
     * @public
     * @class Spine.Unity.MeshRendererBuffers
     * @implements  System.IDisposable
     */
    Bridge.define("Spine.Unity.MeshRendererBuffers", {
        inherits: [System.IDisposable],
        fields: {
            doubleBufferedMesh: null,
            submeshMaterials: null,
            sharedMaterials: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#init", this ); }

                this.submeshMaterials = new (Spine.ExposedList$1(UnityEngine.Material)).ctor();
                this.sharedMaterials = System.Array.init(0, null, UnityEngine.Material);
            }
        },
        methods: {
            /*Spine.Unity.MeshRendererBuffers.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Initialize", this ); }

                if (this.doubleBufferedMesh != null) {
                    this.doubleBufferedMesh.GetNext().Clear();
                    this.doubleBufferedMesh.GetNext().Clear();
                    this.submeshMaterials.Clear();
                } else {
                    this.doubleBufferedMesh = new (Spine.Unity.DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh))();
                }
            },
            /*Spine.Unity.MeshRendererBuffers.Initialize end.*/

            /*Spine.Unity.MeshRendererBuffers.GetUpdatedSharedMaterialsArray start.*/
            /**
             * Returns a sharedMaterials array for use on a MeshRenderer.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @return  {Array.<UnityEngine.Material>}
             */
            GetUpdatedSharedMaterialsArray: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#GetUpdatedSharedMaterialsArray", this ); }

                if (this.submeshMaterials.Count === this.sharedMaterials.length) {
                    this.submeshMaterials.CopyTo(this.sharedMaterials);
                } else {
                    this.sharedMaterials = this.submeshMaterials.ToArray();
                }

                return this.sharedMaterials;
            },
            /*Spine.Unity.MeshRendererBuffers.GetUpdatedSharedMaterialsArray end.*/

            /*Spine.Unity.MeshRendererBuffers.MaterialsChangedInLastUpdate start.*/
            /**
             * Returns true if the materials were modified since the buffers were last updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @return  {boolean}
             */
            MaterialsChangedInLastUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#MaterialsChangedInLastUpdate", this ); }

                var newSubmeshMaterials = this.submeshMaterials.Count;
                var sharedMaterials = this.sharedMaterials;
                if (newSubmeshMaterials !== sharedMaterials.length) {
                    return true;
                }

                var submeshMaterialsItems = this.submeshMaterials.Items;
                for (var i = 0; i < newSubmeshMaterials; i = (i + 1) | 0) {
                    if (!Bridge.referenceEquals(submeshMaterialsItems[i], sharedMaterials[i])) {
                        return true;
                    }
                } //if (submeshMaterialsItems[i].GetInstanceID() != sharedMaterials[i].GetInstanceID()) return true;

                return false;
            },
            /*Spine.Unity.MeshRendererBuffers.MaterialsChangedInLastUpdate end.*/

            /*Spine.Unity.MeshRendererBuffers.UpdateSharedMaterials start.*/
            /**
             * Updates the internal shared materials array with the given instruction list.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @param   {Spine.ExposedList$1}    instructions
             * @return  {void}
             */
            UpdateSharedMaterials: function (instructions) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#UpdateSharedMaterials", this ); }

                var newSize = instructions.Count;
                { //submeshMaterials.Resize(instructions.Count);
                    if (newSize > this.submeshMaterials.Items.length) {
                        System.Array.resize(Bridge.ref(this.submeshMaterials, "Items"), newSize, null, UnityEngine.Material);
                    }
                    this.submeshMaterials.Count = newSize;
                }

                var submeshMaterialsItems = this.submeshMaterials.Items;
                var instructionsItems = instructions.Items;
                for (var i = 0; i < newSize; i = (i + 1) | 0) {
                    submeshMaterialsItems[i] = instructionsItems[i].material;
                }
            },
            /*Spine.Unity.MeshRendererBuffers.UpdateSharedMaterials end.*/

            /*Spine.Unity.MeshRendererBuffers.GetNextMesh start.*/
            GetNextMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#GetNextMesh", this ); }

                return this.doubleBufferedMesh.GetNext();
            },
            /*Spine.Unity.MeshRendererBuffers.GetNextMesh end.*/

            /*Spine.Unity.MeshRendererBuffers.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Clear", this ); }

                this.sharedMaterials = System.Array.init(0, null, UnityEngine.Material);
                this.submeshMaterials.Clear();
            },
            /*Spine.Unity.MeshRendererBuffers.Clear end.*/

            /*Spine.Unity.MeshRendererBuffers.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Dispose", this ); }

                if (this.doubleBufferedMesh == null) {
                    return;
                }
                this.doubleBufferedMesh.GetNext().Dispose();
                this.doubleBufferedMesh.GetNext().Dispose();
                this.doubleBufferedMesh = null;
            },
            /*Spine.Unity.MeshRendererBuffers.Dispose end.*/


        }
    });
    /*Spine.Unity.MeshRendererBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers+SmartMesh start.*/
    /**
     * This is a Mesh that also stores the instructions SkeletonRenderer generated for it.
     *
     * @public
     * @class Spine.Unity.MeshRendererBuffers.SmartMesh
     * @implements  System.IDisposable
     */
    Bridge.define("Spine.Unity.MeshRendererBuffers.SmartMesh", {
        inherits: [System.IDisposable],
        $kind: 1002,
        fields: {
            mesh: null,
            instructionUsed: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#init", this ); }

                this.mesh = Spine.Unity.SpineMesh.NewSkeletonMesh();
                this.instructionUsed = new Spine.Unity.SkeletonRendererInstruction();
            }
        },
        methods: {
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#Clear", this ); }

                this.mesh.Clear();
                this.instructionUsed.Clear();
            },
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Clear end.*/

            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#Dispose", this ); }

                if (this.mesh != null) {
                    UnityEngine.Object.Destroy(this.mesh);
                }
                this.mesh = null;
            },
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Dispose end.*/


        }
    });
    /*Spine.Unity.MeshRendererBuffers+SmartMesh end.*/

    /*Spine.Unity.NoOpTextureLoader start.*/
    Bridge.define("Spine.Unity.NoOpTextureLoader", {
        inherits: [Spine.TextureLoader],
        alias: [
            "Load", "Spine$TextureLoader$Load",
            "Unload", "Spine$TextureLoader$Unload"
        ],
        methods: {
            /*Spine.Unity.NoOpTextureLoader.Load start.*/
            Load: function (page, path) {
if ( TRACE ) { TRACE( "Spine.Unity.NoOpTextureLoader#Load", this ); }
 },
            /*Spine.Unity.NoOpTextureLoader.Load end.*/

            /*Spine.Unity.NoOpTextureLoader.Unload start.*/
            Unload: function (texture) {
if ( TRACE ) { TRACE( "Spine.Unity.NoOpTextureLoader#Unload", this ); }
 },
            /*Spine.Unity.NoOpTextureLoader.Unload end.*/


        }
    });
    /*Spine.Unity.NoOpTextureLoader end.*/

    /*Spine.Unity.RegionlessAttachmentLoader start.*/
    Bridge.define("Spine.Unity.RegionlessAttachmentLoader", {
        inherits: [Spine.AttachmentLoader],
        statics: {
            fields: {
                emptyRegion: null
            },
            props: {
                EmptyRegion: {
                    get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#EmptyRegion#get", this ); }

                        var $t, $t1, $t2;
                        if (Spine.Unity.RegionlessAttachmentLoader.emptyRegion == null) {
                            Spine.Unity.RegionlessAttachmentLoader.emptyRegion = ($t = new Spine.AtlasRegion(), $t.name = "Empty AtlasRegion", $t.page = ($t1 = new Spine.AtlasPage(), $t1.name = "Empty AtlasPage", $t1.rendererObject = ($t2 = new UnityEngine.Material.$ctor2(UnityEngine.Shader.Find("Spine/Special/HiddenPass")), $t2.name = "NoRender Material", $t2), $t1), $t);
                        }
                        return Spine.Unity.RegionlessAttachmentLoader.emptyRegion;
                    }
                }
            }
        },
        alias: [
            "NewBoundingBoxAttachment", "Spine$AttachmentLoader$NewBoundingBoxAttachment",
            "NewPathAttachment", "Spine$AttachmentLoader$NewPathAttachment",
            "NewPointAttachment", "Spine$AttachmentLoader$NewPointAttachment",
            "NewClippingAttachment", "Spine$AttachmentLoader$NewClippingAttachment"
        ],
        methods: {
            /*Spine.Unity.RegionlessAttachmentLoader.NewRegionAttachment start.*/
            NewRegionAttachment: function (skin, name, path) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewRegionAttachment", this ); }

                var $t;
                var attachment = ($t = new Spine.RegionAttachment(name), $t.rendererObject = Spine.Unity.RegionlessAttachmentLoader.EmptyRegion, $t);
                return attachment;
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewRegionAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewMeshAttachment start.*/
            NewMeshAttachment: function (skin, name, path) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewMeshAttachment", this ); }

                var $t;
                var attachment = ($t = new Spine.MeshAttachment(name), $t.RendererObject = Spine.Unity.RegionlessAttachmentLoader.EmptyRegion, $t);
                return attachment;
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewMeshAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewBoundingBoxAttachment start.*/
            NewBoundingBoxAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewBoundingBoxAttachment", this ); }

                return new spine.BoundingBoxAttachment( name );
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewBoundingBoxAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewPathAttachment start.*/
            NewPathAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewPathAttachment", this ); }

                return new spine.PathAttachment( name );
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewPathAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewPointAttachment start.*/
            NewPointAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewPointAttachment", this ); }

                return new spine.PointAttachment( name );
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewPointAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewClippingAttachment start.*/
            NewClippingAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewClippingAttachment", this ); }

                return new spine.ClippingAttachment( name );
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewClippingAttachment end.*/


        }
    });
    /*Spine.Unity.RegionlessAttachmentLoader end.*/

    /*Spine.Unity.SkeletonDataAsset start.*/
    Bridge.define("Spine.Unity.SkeletonDataAsset", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime SkeletonDataAsset.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonDataAsset
                 * @memberof Spine.Unity.SkeletonDataAsset
                 * @param   {UnityEngine.TextAsset}            skeletonDataFile    
                 * @param   {Spine.Unity.AtlasAssetBase}       atlasAsset          
                 * @param   {boolean}                          initialize          
                 * @param   {number}                           scale
                 * @return  {Spine.Unity.SkeletonDataAsset}
                 */
                CreateRuntimeInstance: function (skeletonDataFile, atlasAsset, initialize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    return Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1(skeletonDataFile, System.Array.init([atlasAsset], Spine.Unity.AtlasAssetBase), initialize, scale);
                },
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1:static start.*/
                /**
                 * Creates a runtime SkeletonDataAsset.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonDataAsset
                 * @memberof Spine.Unity.SkeletonDataAsset
                 * @param   {UnityEngine.TextAsset}                 skeletonDataFile    
                 * @param   {Array.<Spine.Unity.AtlasAssetBase>}    atlasAssets         
                 * @param   {boolean}                               initialize          
                 * @param   {number}                                scale
                 * @return  {Spine.Unity.SkeletonDataAsset}
                 */
                CreateRuntimeInstance$1: function (skeletonDataFile, atlasAssets, initialize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance$1", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    var skeletonDataAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SkeletonDataAsset);
                    skeletonDataAsset.Clear();
                    skeletonDataAsset.skeletonJSON = skeletonDataFile;
                    skeletonDataAsset.atlasAssets = atlasAssets;
                    skeletonDataAsset.scale = scale;

                    if (initialize) {
                        skeletonDataAsset.GetSkeletonData(true);
                    }

                    return skeletonDataAsset;
                },
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1:static end.*/

                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData:static start.*/
                ReadSkeletonData: function (bytes, attachmentLoader, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#ReadSkeletonData", this ); }

                    var $t;
                    var input = new System.IO.MemoryStream.$ctor1(bytes);
                    try {
                        var binary = ($t = new Spine.SkeletonBinary(attachmentLoader), $t.scale = scale, $t);
                        return binary.ReadSkeletonData(input);
                    }
                    finally {
                        if (Bridge.hasValue(input)) {
                            input.System$IDisposable$Dispose();
                        }
                    }
                },
                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData:static end.*/

                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1:static start.*/
                ReadSkeletonData$1: function (text, attachmentLoader, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#ReadSkeletonData$1", this ); }

                    var $t;
                    var input = new System.IO.StringReader(text);
                    var json = ($t = new Spine.SkeletonJson(attachmentLoader), $t.scale = scale, $t);
                    return json.ReadSkeletonData(input);
                },
                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1:static end.*/


            }
        },
        fields: {
            atlasAssets: null,
            scale: 0,
            skeletonJSON: null,
            isUpgradingBlendModeMaterials: false,
            blendModeMaterials: null,
            skeletonDataModifiers: null,
            fromAnimation: null,
            toAnimation: null,
            duration: null,
            defaultMix: 0,
            controller: null,
            skeletonData: null,
            stateData: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#IsLoaded#get", this ); }

                    return this.skeletonData != null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#init", this ); }

                this.atlasAssets = System.Array.init(0, null, Spine.Unity.AtlasAssetBase);
                this.scale = 0.01;
                this.isUpgradingBlendModeMaterials = false;
                this.blendModeMaterials = new Spine.Unity.BlendModeMaterials();
                this.skeletonDataModifiers = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonDataModifierAsset)).ctor();
                this.fromAnimation = System.Array.init(0, null, System.String);
                this.toAnimation = System.Array.init(0, null, System.String);
                this.duration = System.Array.init(0, 0, System.Single);
            }
        },
        methods: {
            /*Spine.Unity.SkeletonDataAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SkeletonDataAsset.Reset end.*/

            /*Spine.Unity.SkeletonDataAsset.Clear start.*/
            /**
             * Clears the loaded SkeletonData and AnimationStateData. Use this to force a reload for the next time GetSkeletonData is called.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonDataAsset
             * @memberof Spine.Unity.SkeletonDataAsset
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#Clear", this ); }

                this.skeletonData = null;
                this.stateData = null;
            },
            /*Spine.Unity.SkeletonDataAsset.Clear end.*/

            /*Spine.Unity.SkeletonDataAsset.GetAnimationStateData start.*/
            GetAnimationStateData: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetAnimationStateData", this ); }

                if (this.stateData != null) {
                    return this.stateData;
                }
                this.GetSkeletonData(false);
                return this.stateData;
            },
            /*Spine.Unity.SkeletonDataAsset.GetAnimationStateData end.*/

            /*Spine.Unity.SkeletonDataAsset.GetSkeletonData start.*/
            /**
             * Loads, caches and returns the SkeletonData from the skeleton data file. Returns the cached SkeletonData after the first time it is called. Pass false to prevent direct errors from being logged.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonDataAsset
             * @memberof Spine.Unity.SkeletonDataAsset
             * @param   {boolean}               quiet
             * @return  {Spine.SkeletonData}
             */
            GetSkeletonData: function (quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetSkeletonData", this ); }

                var $t;
                if (this.skeletonJSON == null) {
                    if (!quiet) {
                        UnityEngine.Debug.LogError$2("Skeleton JSON file not set for SkeletonData asset: " + (this.name || ""), this);
                    }
                    this.Clear();
                    return null;
                }

                // Disabled to support attachmentless/skinless SkeletonData.
                //			if (atlasAssets == null) {
                //				atlasAssets = new AtlasAsset[0];
                //				if (!quiet)
                //					Debug.LogError("Atlas not set for SkeletonData asset: " + name, this);
                //				Clear();
                //				return null;
                //			}
                //			#if !SPINE_TK2D
                //			if (atlasAssets.Length == 0) {
                //				Clear();
                //				return null;
                //			}
                //			#else
                //			if (atlasAssets.Length == 0 && spriteCollection == null) {
                //				Clear();
                //				return null;
                //			}
                //			#endif

                if (this.skeletonData != null) {
                    return this.skeletonData;
                }

                var attachmentLoader;
                var skeletonDataScale;
                var atlasArray = this.GetAtlasArray();

                attachmentLoader = (atlasArray.length === 0) ? Bridge.cast(new Spine.Unity.RegionlessAttachmentLoader(), Spine.AttachmentLoader) : Bridge.cast(new Spine.AtlasAttachmentLoader(atlasArray), Spine.AttachmentLoader);
                skeletonDataScale = this.scale;

                var hasBinaryExtension = System.String.contains(this.skeletonJSON.name.toLowerCase(),".skel");
                var loadedSkeletonData = null;

                try {
                    if (hasBinaryExtension) {
                        loadedSkeletonData = Spine.Unity.SkeletonDataAsset.ReadSkeletonData(this.skeletonJSON.bytes, attachmentLoader, skeletonDataScale);
                    } else {
                        loadedSkeletonData = Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1(this.skeletonJSON.text, attachmentLoader, skeletonDataScale);
                    }
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    if (!quiet) {
                        UnityEngine.Debug.LogError$2("Error reading skeleton JSON file for SkeletonData asset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this.skeletonJSON);
                    }
                }

                if (loadedSkeletonData == null) {
                    return null;
                }

                if (this.skeletonDataModifiers != null) {
                    $t = Bridge.getEnumerator(this.skeletonDataModifiers);
                    try {
                        while ($t.moveNext()) {
                            var modifier = $t.Current;
                            if (modifier != null && !(this.isUpgradingBlendModeMaterials && Bridge.is(modifier, Spine.Unity.BlendModeMaterialsAsset))) {
                                modifier.Apply(loadedSkeletonData);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                if (!this.isUpgradingBlendModeMaterials) {
                    this.blendModeMaterials.ApplyMaterials(loadedSkeletonData);
                }

                this.InitializeWithData(loadedSkeletonData);

                return this.skeletonData;
            },
            /*Spine.Unity.SkeletonDataAsset.GetSkeletonData end.*/

            /*Spine.Unity.SkeletonDataAsset.InitializeWithData start.*/
            InitializeWithData: function (sd) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#InitializeWithData", this ); }

                this.skeletonData = sd;
                this.stateData = new spine.AnimationStateData( this.skeletonData );
                this.FillStateData();
            },
            /*Spine.Unity.SkeletonDataAsset.InitializeWithData end.*/

            /*Spine.Unity.SkeletonDataAsset.FillStateData start.*/
            FillStateData: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#FillStateData", this ); }

                if (this.stateData != null) {
                    this.stateData.defaultMix = this.defaultMix;

                    for (var i = 0, n = this.fromAnimation.length; i < n; i = (i + 1) | 0) {
                        if (this.fromAnimation[i].length === 0 || this.toAnimation[i].length === 0) {
                            continue;
                        }
                        this.stateData.setMix(this.fromAnimation[i], this.toAnimation[i], this.duration[i]);
                    }
                }
            },
            /*Spine.Unity.SkeletonDataAsset.FillStateData end.*/

            /*Spine.Unity.SkeletonDataAsset.GetAtlasArray start.*/
            GetAtlasArray: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetAtlasArray", this ); }

                var returnList = new (System.Collections.Generic.List$1(Spine.Atlas)).$ctor2(this.atlasAssets.length);
                for (var i = 0; i < this.atlasAssets.length; i = (i + 1) | 0) {
                    var aa = this.atlasAssets[i];
                    if (aa == null) {
                        continue;
                    }
                    var a = aa.GetAtlas();
                    if (a == null) {
                        continue;
                    }
                    returnList.add(a);
                }
                return returnList.ToArray();
            },
            /*Spine.Unity.SkeletonDataAsset.GetAtlasArray end.*/


        }
    });
    /*Spine.Unity.SkeletonDataAsset end.*/

    /*Spine.Unity.SkeletonDataCompatibility start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility");
    /*Spine.Unity.SkeletonDataCompatibility end.*/

    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo", {
        $kind: 1002,
        fields: {
            actualVersion: null,
            compatibleVersions: null,
            explicitProblemDescription: null
        },
        methods: {
            /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo.DescriptionString start.*/
            DescriptionString: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo#DescriptionString", this ); }

                var $t, $t1, $t2;
                if (!System.String.isNullOrEmpty(this.explicitProblemDescription)) {
                    return this.explicitProblemDescription;
                }

                var compatibleVersionString = "";
                var optionalOr = null;
                $t = Bridge.getEnumerator(this.compatibleVersions);
                try {
                    while ($t.moveNext()) {
                        var version = $t.Current;
                        compatibleVersionString = (compatibleVersionString || "") + ((System.String.format("{0}{1}.{2}", optionalOr, Bridge.box(version[0], System.Int32), Bridge.box(version[1], System.Int32))) || "");
                        optionalOr = " or ";
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return System.String.format("Skeleton data could not be loaded. Data version: {0}. Required version: {1}.\nPlease re-export skeleton data with Spine {1} or change runtime to version {2}.{3}.", this.actualVersion.rawVersion, compatibleVersionString, Bridge.box(($t1 = this.actualVersion.version)[0], System.Int32), Bridge.box(($t2 = this.actualVersion.version)[1], System.Int32));
            },
            /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo.DescriptionString end.*/


        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo end.*/

    /*Spine.Unity.SkeletonDataCompatibility+SourceType start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.SourceType", {
        $kind: 1006,
        statics: {
            fields: {
                Json: 0,
                Binary: 1
            }
        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+SourceType end.*/

    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.VersionInfo", {
        $kind: 1002,
        fields: {
            rawVersion: null,
            version: null,
            sourceType: 0
        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo end.*/

    /*Spine.Unity.SkeletonExtensions start.*/
    Bridge.define("Spine.Unity.SkeletonExtensions", {
        statics: {
            fields: {
                ByteToFloat: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#init", this ); }

                    this.ByteToFloat = 0.003921569;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonExtensions.GetColor$2:static start.*/
                GetColor$2: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$2", this ); }

                    return new pc.Color( s.color.r, s.color.g, s.color.b, s.color.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor$1:static start.*/
                GetColor$1: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$1", this ); }

                    return new pc.Color( a.color.r, a.color.g, a.color.b, a.color.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor:static start.*/
                GetColor: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor", this ); }

                    return new pc.Color( a.color.r, a.color.g, a.color.b, a.color.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor$3:static start.*/
                GetColor$3: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$3", this ); }

                    return new pc.Color( s.color.r, s.color.g, s.color.b, s.color.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColorTintBlack:static start.*/
                GetColorTintBlack: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColorTintBlack", this ); }

                    return new pc.Color( s.darkColor.r || 0, s.darkColor.g || 0, s.darkColor.b || 0, 1.0 );
                },
                /*Spine.Unity.SkeletonExtensions.GetColorTintBlack:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$4:static start.*/
                SetColor$4: function (skeleton, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$4", this ); }

                    skeleton.color.a = color.a;
                    skeleton.color.r = color.r;
                    skeleton.color.g = color.g;
                    skeleton.color.b = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$4:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$5:static start.*/
                SetColor$5: function (skeleton, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$5", this ); }

                    skeleton.color.a = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.color.r = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.color.g = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.color.b = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$5:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$6:static start.*/
                SetColor$6: function (slot, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$6", this ); }

                    slot.color.a = color.a;
                    slot.color.r = color.r;
                    slot.color.g = color.g;
                    slot.color.b = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$6:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$7:static start.*/
                SetColor$7: function (slot, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$7", this ); }

                    slot.color.a = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.color.r = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.color.g = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.color.b = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$7:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$2:static start.*/
                SetColor$2: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$2", this ); }

                    attachment.color.a = color.a;
                    attachment.color.r = color.r;
                    attachment.color.g = color.g;
                    attachment.color.b = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$3:static start.*/
                SetColor$3: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$3", this ); }

                    attachment.color.a = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.r = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.g = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.b = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor:static start.*/
                SetColor: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor", this ); }

                    attachment.color.a = color.a;
                    attachment.color.r = color.r;
                    attachment.color.g = color.g;
                    attachment.color.b = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$1:static start.*/
                SetColor$1: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$1", this ); }

                    attachment.color.a = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.r = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.g = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.b = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalScale:static start.*/
                /**
                 * Sets the Skeleton's local scale using a UnityEngine.Vector2. If only individual components need to be set, set Skeleton.ScaleX or Skeleton.ScaleY.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Skeleton}         skeleton    
                 * @param   {UnityEngine.Vector2}    scale
                 * @return  {void}
                 */
                SetLocalScale: function (skeleton, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalScale", this ); }

                    skeleton.scaleX = scale.x;
                    skeleton.scaleY = scale.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalScale:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetMatrix4x4:static start.*/
                /**
                 * Gets the internal bone matrix as a Unity bonespace-to-skeletonspace transformation matrix.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}               bone
                 * @return  {UnityEngine.Matrix4x4}
                 */
                GetMatrix4x4: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetMatrix4x4", this ); }

                    var $t;
                    return ($t = new pc.Mat4.ctor(), $t.e00 = bone.a, $t.e01 = bone.b, $t.e03 = bone.worldX, $t.e10 = bone.c, $t.e11 = bone.d, $t.e13 = bone.worldY, $t.e33 = 1, $t);
                },
                /*Spine.Unity.SkeletonExtensions.GetMatrix4x4:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalPosition:static start.*/
                /**
                 * Sets the bone's (local) X and Y according to a Vector2
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone        
                 * @param   {UnityEngine.Vector2}    position
                 * @return  {void}
                 */
                SetLocalPosition: function (bone, position) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalPosition", this ); }

                    bone.x = position.x;
                    bone.y = position.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalPosition$1:static start.*/
                /**
                 * Sets the bone's (local) X and Y according to a Vector3. The z component is ignored.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone        
                 * @param   {UnityEngine.Vector3}    position
                 * @return  {void}
                 */
                SetLocalPosition$1: function (bone, position) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalPosition$1", this ); }

                    bone.x = position.x;
                    bone.y = position.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalPosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalPosition:static start.*/
                /**
                 * Gets the bone's local X and Y as a Vector2.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone
                 * @return  {UnityEngine.Vector2}
                 */
                GetLocalPosition: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalPosition", this ); }

                    return new pc.Vec2( bone.x, bone.y );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition:static start.*/
                /**
                 * Gets the position of the bone in Skeleton-space.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone
                 * @return  {UnityEngine.Vector2}
                 */
                GetSkeletonSpacePosition: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition", this ); }

                    return new pc.Vec2( bone.worldX, bone.worldY );
                },
                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition$1:static start.*/
                /**
                 * Gets a local offset from the bone and converts it into Skeleton-space.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone         
                 * @param   {UnityEngine.Vector2}    boneLocal
                 * @return  {UnityEngine.Vector2}
                 */
                GetSkeletonSpacePosition$1: function (bone, boneLocal) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition$1", this ); }

                    var o = new UnityEngine.Vector2();
                    bone.LocalToWorld(boneLocal.x, boneLocal.y, Bridge.ref(o, "x"), Bridge.ref(o, "y"));
                    return o.$clone();
                },
                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition:static start.*/
                /**
                 * Gets the bone's Unity World position using its Spine GameObject Transform. UpdateWorldTransform needs to have been called for this to return the correct, updated value.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}               bone                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition: function (bone, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition", this ); }

                    return spineGameObjectTransform.TransformPoint$1(new pc.Vec3( bone.worldX, bone.worldY, 0 ));
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$1:static start.*/
                GetWorldPosition$1: function (bone, spineGameObjectTransform, positionScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$1", this ); }

                    return spineGameObjectTransform.TransformPoint$1(new pc.Vec3( bone.worldX * positionScale, bone.worldY * positionScale, 0 ));
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$3:static start.*/
                /**
                 * Gets the PointAttachment's Unity World position using its Spine GameObject Transform.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.PointAttachment}    attachment                  
                 * @param   {Spine.Slot}               slot                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition$3: function (attachment, slot, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$3", this ); }

                    var skeletonSpacePosition = new UnityEngine.Vector3();
                    skeletonSpacePosition.z = 0;
                    attachment.ComputeWorldPosition(slot.bone, Bridge.ref(skeletonSpacePosition, "x"), Bridge.ref(skeletonSpacePosition, "y"));
                    return spineGameObjectTransform.TransformPoint$1(skeletonSpacePosition);
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$2:static start.*/
                /**
                 * Gets the PointAttachment's Unity World position using its Spine GameObject Transform.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.PointAttachment}    attachment                  
                 * @param   {Spine.Bone}               bone                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition$2: function (attachment, bone, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$2", this ); }

                    var skeletonSpacePosition = new UnityEngine.Vector3();
                    skeletonSpacePosition.z = 0;
                    attachment.ComputeWorldPosition(bone, Bridge.ref(skeletonSpacePosition, "x"), Bridge.ref(skeletonSpacePosition, "y"));
                    return spineGameObjectTransform.TransformPoint$1(skeletonSpacePosition);
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetQuaternion:static start.*/
                /**
                 * Gets a skeleton space UnityEngine.Quaternion representation of bone.WorldRotationX.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}                bone
                 * @return  {UnityEngine.Quaternion}
                 */
                GetQuaternion: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetQuaternion", this ); }

                    var halfRotation = Math.atan2(bone.c, bone.a) * 0.5;
                    return new pc.Quat( 0, 0, Math.sin(halfRotation), Math.cos(halfRotation) );
                },
                /*Spine.Unity.SkeletonExtensions.GetQuaternion:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalQuaternion:static start.*/
                /**
                 * Gets a bone-local space UnityEngine.Quaternion representation of bone.rotation.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}                bone
                 * @return  {UnityEngine.Quaternion}
                 */
                GetLocalQuaternion: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalQuaternion", this ); }

                    var halfRotation = bone.rotation * UnityEngine.Mathf.Deg2Rad * 0.5;
                    return new pc.Quat( 0, 0, Math.sin(halfRotation), Math.cos(halfRotation) );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalQuaternion:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalScale:static start.*/
                /**
                 * Returns the Skeleton's local scale as a UnityEngine.Vector2. If only individual components are needed, use Skeleton.ScaleX or Skeleton.ScaleY.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Skeleton}         skeleton
                 * @return  {UnityEngine.Vector2}
                 */
                GetLocalScale: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalScale", this ); }

                    return new pc.Vec2( skeleton.scaleX, skeleton.scaleY );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalScale:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix:static start.*/
                /**
                 * Calculates a 2x2 Transformation Matrix that can convert a skeleton-space position to a bone-local position.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}       bone    
                 * @param   {System.Single}    ia      
                 * @param   {System.Single}    ib      
                 * @param   {System.Single}    ic      
                 * @param   {System.Single}    id
                 * @return  {void}
                 */
                GetWorldToLocalMatrix: function (bone, ia, ib, ic, id) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldToLocalMatrix", this ); }

                    var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                    var invDet = 1 / (a * d - b * c);
                    ia.v = invDet * d;
                    ib.v = invDet * -b;
                    ic.v = invDet * -c;
                    id.v = invDet * a;
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix:static end.*/

                /*Spine.Unity.SkeletonExtensions.WorldToLocal:static start.*/
                /**
                 * UnityEngine.Vector2 override of Bone.WorldToLocal. This converts a skeleton-space position into a bone local position.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone             
                 * @param   {UnityEngine.Vector2}    worldPosition
                 * @return  {UnityEngine.Vector2}
                 */
                WorldToLocal: function (bone, worldPosition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#WorldToLocal", this ); }

                    var o = new UnityEngine.Vector2();
                    bone.WorldToLocal(worldPosition.x, worldPosition.y, Bridge.ref(o, "x"), Bridge.ref(o, "y"));
                    return o.$clone();
                },
                /*Spine.Unity.SkeletonExtensions.WorldToLocal:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetPositionSkeletonSpace:static start.*/
                /**
                 * Sets the skeleton-space position of a bone.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone                     
                 * @param   {UnityEngine.Vector2}    skeletonSpacePosition
                 * @return  {UnityEngine.Vector2}                             The local position in its parent bone space, or in skeleton space if it is the root bone.
                 */
                SetPositionSkeletonSpace: function (bone, skeletonSpacePosition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetPositionSkeletonSpace", this ); }

                    if (bone.parent == null) { // root bone
                        Spine.Unity.SkeletonExtensions.SetLocalPosition(bone, skeletonSpacePosition.$clone());
                        return skeletonSpacePosition.$clone();
                    } else {
                        var parent = bone.parent;
                        var parentLocal = Spine.Unity.SkeletonExtensions.WorldToLocal(parent, skeletonSpacePosition.$clone());
                        Spine.Unity.SkeletonExtensions.SetLocalPosition(bone, parentLocal.$clone());
                        return parentLocal.$clone();
                    }
                },
                /*Spine.Unity.SkeletonExtensions.SetPositionSkeletonSpace:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetMaterial:static start.*/
                GetMaterial: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetMaterial", this ); }

                    var rendererObject = null;
                    var renderableAttachment = Bridge.as(a, Spine.IHasRendererObject);
                    if (renderableAttachment != null) {
                        rendererObject = renderableAttachment.Spine$IHasRendererObject$RendererObject;
                    }

                    if (rendererObject == null) {
                        return null;
                    }

                    return Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                },
                /*Spine.Unity.SkeletonExtensions.GetMaterial:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalVertices:static start.*/
                /**
                 * Fills a Vector2 buffer with local vertices.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {spine.VertexAttachment}         va        The VertexAttachment
                 * @param   {Spine.Slot}                     slot      Slot where the attachment belongs.
                 * @param   {Array.<UnityEngine.Vector2>}    buffer    Correctly-sized buffer. Use attachment's .WorldVerticesLength to get the correct size. If null, a new Vector2[] of the correct size will be allocated.
                 * @return  {Array.<UnityEngine.Vector2>}
                 */
                GetLocalVertices: function (va, slot, buffer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalVertices", this ); }

                    var floatsCount = va.worldVerticesLength;
                    var bufferTargetSize = floatsCount >> 1;
                    buffer = buffer || System.Array.init(bufferTargetSize, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    if (buffer.length < bufferTargetSize) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Vector2 buffer too small. {0} requires an array of size {1}. Use the attachment's .WorldVerticesLength to get the correct size.", va.name, Bridge.box(floatsCount, System.Int32)), "buffer");
                    }

                    if (va.bones == null && slot.Deform.Count === 0) {
                        var localVerts = va.vertices;
                        for (var i = 0; i < bufferTargetSize; i = (i + 1) | 0) {
                            var j = Bridge.Int.mul(i, 2);
                            buffer[i] = new pc.Vec2( localVerts[j], localVerts[((j + 1) | 0)] );
                        }
                    } else {
                        var floats = System.Array.init(floatsCount, 0, System.Single);
                        va.computeWorldVertices( slot, 0, va.worldVerticesLength, floats, 0, 2 );

                        var sb = slot.bone;
                        var ia = { }, ib = { }, ic = { }, id = { }, bwx = sb.worldX, bwy = sb.worldY;
                        Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix(sb, ia, ib, ic, id);

                        for (var i1 = 0; i1 < bufferTargetSize; i1 = (i1 + 1) | 0) {
                            var j1 = Bridge.Int.mul(i1, 2);
                            var x = floats[j1] - bwx, y = floats[((j1 + 1) | 0)] - bwy;
                            buffer[i1] = new pc.Vec2( x * ia.v + y * ib.v, x * ic.v + y * id.v );
                        }
                    }

                    return buffer;
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalVertices:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldVertices:static start.*/
                /**
                 * Calculates world vertices and fills a Vector2 buffer.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {spine.VertexAttachment}         a         The VertexAttachment
                 * @param   {Spine.Slot}                     slot      Slot where the attachment belongs.
                 * @param   {Array.<UnityEngine.Vector2>}    buffer    Correctly-sized buffer. Use attachment's .WorldVerticesLength to get the correct size. If null, a new Vector2[] of the correct size will be allocated.
                 * @return  {Array.<UnityEngine.Vector2>}
                 */
                GetWorldVertices: function (a, slot, buffer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldVertices", this ); }

                    var worldVertsLength = a.worldVerticesLength;
                    var bufferTargetSize = worldVertsLength >> 1;
                    buffer = buffer || System.Array.init(bufferTargetSize, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    if (buffer.length < bufferTargetSize) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Vector2 buffer too small. {0} requires an array of size {1}. Use the attachment's .WorldVerticesLength to get the correct size.", a.name, Bridge.box(worldVertsLength, System.Int32)), "buffer");
                    }

                    var floats = System.Array.init(worldVertsLength, 0, System.Single);
                    a.computeWorldVertices( slot, 0, a.worldVerticesLength, floats, 0, 2 );

                    for (var i = 0, n = worldVertsLength >> 1; i < n; i = (i + 1) | 0) {
                        var j = Bridge.Int.mul(i, 2);
                        buffer[i] = new pc.Vec2( floats[j], floats[((j + 1) | 0)] );
                    }

                    return buffer;
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldVertices:static end.*/


            }
        }
    });
    /*Spine.Unity.SkeletonExtensions end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            customMaterialOverrides: null,
            customTextureOverrides: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#init", this ); }

                this.customMaterialOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride)).ctor();
                this.customTextureOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomMaterialOverrides start.*/
            SetCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    if (atlasMaterialOverride.overrideEnabled) {
                        this.skeletonGraphic.CustomMaterialOverride.setItem(atlasMaterialOverride.originalTexture, atlasMaterialOverride.replacementMaterial);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomMaterialOverrides start.*/
            RemoveCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    var currentMaterial = { };

                    if (!this.skeletonGraphic.CustomMaterialOverride.tryGetValue(atlasMaterialOverride.originalTexture, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, atlasMaterialOverride.replacementMaterial)) {
                        continue;
                    }

                    this.skeletonGraphic.CustomMaterialOverride.remove(atlasMaterialOverride.originalTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomTextureOverrides start.*/
            SetCustomTextureOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomTextureOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customTextureOverrides.Count; i = (i + 1) | 0) {
                    var atlasTextureOverride = this.customTextureOverrides.getItem(i).$clone();
                    if (atlasTextureOverride.overrideEnabled) {
                        this.skeletonGraphic.CustomTextureOverride.setItem(atlasTextureOverride.originalTexture, atlasTextureOverride.replacementTexture);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomTextureOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomTextureOverrides start.*/
            RemoveCustomTextureOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomTextureOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customTextureOverrides.Count; i = (i + 1) | 0) {
                    var atlasTextureOverride = this.customTextureOverrides.getItem(i).$clone();
                    var currentTexture = { };

                    if (!this.skeletonGraphic.CustomTextureOverride.tryGetValue(atlasTextureOverride.originalTexture, currentTexture)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentTexture.v, atlasTextureOverride.replacementTexture)) {
                        continue;
                    }

                    this.skeletonGraphic.CustomTextureOverride.remove(atlasTextureOverride.originalTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomTextureOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                this.skeletonGraphic.Initialize(false);
                this.SetCustomMaterialOverrides();
                this.SetCustomTextureOverrides();
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnEnable end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                this.RemoveCustomMaterialOverrides();
                this.RemoveCustomTextureOverrides();
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride(); }
            }
        },
        fields: {
            overrideEnabled: false,
            originalTexture: null,
            replacementMaterial: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonGraphicCustomMaterials$AtlasMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#equalsT", this ); }

                return this.overrideEnabled === other.overrideEnabled && Bridge.referenceEquals(this.originalTexture, other.originalTexture) && Bridge.referenceEquals(this.replacementMaterial, other.replacementMaterial);
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([8608216668, this.overrideEnabled, this.originalTexture, this.replacementMaterial]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride();
                s.overrideEnabled = this.overrideEnabled;
                s.originalTexture = this.originalTexture;
                s.replacementMaterial = this.replacementMaterial;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride(); }
            }
        },
        fields: {
            overrideEnabled: false,
            originalTexture: null,
            replacementTexture: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonGraphicCustomMaterials$AtlasTextureOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#equalsT", this ); }

                return this.overrideEnabled === other.overrideEnabled && Bridge.referenceEquals(this.originalTexture, other.originalTexture) && Bridge.referenceEquals(this.replacementTexture, other.replacementTexture);
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getHashCode", this ); }

                var h = Bridge.addHash([8976735721, this.overrideEnabled, this.originalTexture, this.replacementTexture]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride();
                s.overrideEnabled = this.overrideEnabled;
                s.originalTexture = this.originalTexture;
                s.replacementTexture = this.replacementTexture;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasTextureOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator", {
        $kind: 1002,
        statics: {
            fields: {
                WeightEpsilon: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#init", this ); }

                    this.WeightEpsilon = 0.0001;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime$1:static start.*/
                AnimationTime$1: function (normalizedTime, clipLength, loop, reversed) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime$1", this ); }

                    var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(normalizedTime, clipLength, reversed);
                    if (loop) {
                        return time;
                    }
                    var EndSnapEpsilon = 0.0333333351; // Workaround for end-duration keys not being applied.
                    return (clipLength - time < EndSnapEpsilon) ? clipLength : time; // return a time snapped to clipLength;
                },
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime$1:static end.*/

                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime:static start.*/
                AnimationTime: function (normalizedTime, clipLength, reversed) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime", this ); }

                    if (reversed) {
                        normalizedTime = (1 - normalizedTime);
                    }
                    if (normalizedTime < 0.0) {
                        normalizedTime = (normalizedTime % 1.0) + 1.0;
                    }
                    return normalizedTime * clipLength;
                },
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime:static end.*/


            }
        },
        fields: {
            autoReset: false,
            useCustomMixMode: false,
            layerMixModes: null,
            layerBlendModes: null,
            animationTable: null,
            clipNameHashCodeTable: null,
            previousAnimations: null,
            layerClipInfos: null,
            animator: null
        },
        events: {
            _OnClipApplied: null
        },
        props: {
            Animator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Animator#get", this ); }

                    return this.animator;
                }
            },
            MecanimLayerCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerCount#get", this ); }

                    if (!UnityEngine.Object.op_Implicit(this.animator)) {
                        return 0;
                    }
                    return this.animator.layerCount;
                }
            },
            MecanimLayerNames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerNames#get", this ); }

                    if (!UnityEngine.Object.op_Implicit(this.animator)) {
                        return System.Array.init(0, null, System.String);
                    }
                    var layerNames = System.Array.init(this.animator.layerCount, null, System.String);
                    for (var i = 0; i < this.animator.layerCount; i = (i + 1) | 0) {
                        layerNames[i] = this.animator.GetLayerName(i);
                    }
                    return layerNames;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#init", this ); }

                this.autoReset = true;
                this.useCustomMixMode = true;
                this.layerMixModes = System.Array.init(0, 0, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode);
                this.layerBlendModes = System.Array.init(0, 0, spine.MixBlend);
                this.animationTable = new (System.Collections.Generic.Dictionary$2(System.Int32,Spine.Animation)).$ctor3(Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer.Instance);
                this.clipNameHashCodeTable = new (System.Collections.Generic.Dictionary$2(UnityEngine.AnimationClip,System.Int32)).$ctor3(Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer.Instance);
                this.previousAnimations = new (System.Collections.Generic.List$1(Spine.Animation)).ctor();
                this.layerClipInfos = System.Array.init(0, null, Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos);
            }
        },
        methods: {
            addOnClipApplied: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#addOnClipApplied", this ); }

                this.add_OnClipApplied(value);
            },
            removeOnClipApplied: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#removeOnClipApplied", this ); }

                this.remove_OnClipApplied(value);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Initialize start.*/
            Initialize: function (animator, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Initialize", this ); }

                var $t;
                this.animator = animator;

                this.previousAnimations.clear();

                this.animationTable.clear();
                var data = skeletonDataAsset.GetSkeletonData(true);
                $t = Bridge.getEnumerator(data.Animations);
                try {
                    while ($t.moveNext()) {
                        var a = $t.Current;
                        this.animationTable.add(Bridge.getHashCode(a.name), a);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.clipNameHashCodeTable.clear();
                this.ClearClipInfosForLayers();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Initialize end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyAnimation start.*/
            ApplyAnimation: function (skeleton, info, stateInfo, layerIndex, layerWeight, layerBlendMode, useClipWeight1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyAnimation", this ); }

                if (useClipWeight1 === void 0) { useClipWeight1 = false; }
                var weight = info.weight * layerWeight;
                if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                    return false;
                }

                var clip = this.GetAnimation(info.clip);
                if (clip == null) {
                    return false;
                }

                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime$1(stateInfo.normalizedTime, info.clip.length, info.clip.isLooping, stateInfo.speed < 0);
                weight = useClipWeight1 ? layerWeight : weight;
                clip.apply(skeleton, 0, time, info.clip.isLooping, null, weight, layerBlendMode, spine.MixDirection.mixIn);
                if (!Bridge.staticEquals(this._OnClipApplied, null)) {
                    this.OnClipAppliedCallback(clip, stateInfo, layerIndex, time, info.clip.isLooping, weight);
                }
                return true;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyInterruptionAnimation start.*/
            ApplyInterruptionAnimation: function (skeleton, interpolateWeightTo1, info, stateInfo, layerIndex, layerWeight, layerBlendMode, interruptingClipTimeAddition, useClipWeight1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyInterruptionAnimation", this ); }

                if (useClipWeight1 === void 0) { useClipWeight1 = false; }

                var clipWeight = interpolateWeightTo1 ? (info.weight + 1.0) * 0.5 : info.weight;
                var weight = clipWeight * layerWeight;
                if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                    return false;
                }

                var clip = this.GetAnimation(info.clip);
                if (clip == null) {
                    return false;
                }

                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime + interruptingClipTimeAddition, info.clip.length, stateInfo.speed < 0);
                weight = useClipWeight1 ? layerWeight : weight;
                clip.apply(skeleton, 0, time, info.clip.isLooping, null, weight, layerBlendMode, spine.MixDirection.mixIn);
                if (!Bridge.staticEquals(this._OnClipApplied, null)) {
                    this.OnClipAppliedCallback(clip, stateInfo, layerIndex, time, info.clip.isLooping, weight);
                }
                return true;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyInterruptionAnimation end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.OnClipAppliedCallback start.*/
            OnClipAppliedCallback: function (clip, stateInfo, layerIndex, time, isLooping, weight) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#OnClipAppliedCallback", this ); }


                var speedFactor = stateInfo.speedMultiplier * stateInfo.speed;
                var lastTime = time - (UnityEngine.Time.deltaTime * speedFactor);
                var clipDuration = clip.duration;
                if (isLooping && clipDuration !== 0) {
                    time %= clipDuration;
                    lastTime %= clipDuration;
                }
                this._OnClipApplied(clip, layerIndex, weight, time, lastTime, speedFactor < 0);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.OnClipAppliedCallback end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Apply start.*/
            Apply: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Apply", this ); }


                if (this.layerMixModes.length < this.animator.layerCount) {
                    var oldSize = this.layerMixModes.length;
                    System.Array.resize(Bridge.ref(this, "layerMixModes"), this.animator.layerCount, 0, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode);
                    for (var layer = oldSize; layer < this.animator.layerCount; layer = (layer + 1) | 0) {
                        var isAdditiveLayer = false;
                        if (layer < this.layerBlendModes.length) {
                            isAdditiveLayer = this.layerBlendModes[layer] === spine.MixBlend.add;
                        }
                        this.layerMixModes[layer] = isAdditiveLayer ? Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix : Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext;
                    }
                }

                this.InitClipInfosForLayers();
                for (var layer1 = 0, n = this.animator.layerCount; layer1 < n; layer1 = (layer1 + 1) | 0) {
                    this.GetStateUpdatesFromAnimator(layer1);
                }

                // Clear Previous
                if (this.autoReset) {
                    var previousAnimations = this.previousAnimations;
                    for (var i = 0, n1 = previousAnimations.Count; i < n1; i = (i + 1) | 0) {
                        previousAnimations.getItem(i).apply(skeleton, 0, 0, false, null, 0, spine.MixBlend.setup, spine.MixDirection.mixOut);
                    } // SetKeyedItemsToSetupPose

                    previousAnimations.clear();
                    for (var layer2 = 0, n2 = this.animator.layerCount; layer2 < n2; layer2 = (layer2 + 1) | 0) {
                        var layerWeight = (layer2 === 0) ? 1 : this.animator.GetLayerWeight(layer2); // Animator.GetLayerWeight always returns 0 on the first layer. Should be interpreted as 1.
                        if (layerWeight <= 0) {
                            continue;
                        }

                        var nextStateInfo = this.animator.GetNextAnimatorStateInfo(layer2);

                        var hasNext = nextStateInfo.fullPathHash !== 0;

                        var clipInfoCount = { }, nextClipInfoCount = { }, interruptingClipInfoCount = { };
                        var clipInfo = { }, nextClipInfo = { }, interruptingClipInfo = { };
                        var isInterruptionActive = { }, shallInterpolateWeightTo1 = { };
                        this.GetAnimatorClipInfos(layer2, isInterruptionActive, clipInfoCount, nextClipInfoCount, interruptingClipInfoCount, clipInfo, nextClipInfo, interruptingClipInfo, shallInterpolateWeightTo1);

                        for (var c = 0; c < clipInfoCount.v; c = (c + 1) | 0) {
                            var info = System.Array.getItem(clipInfo.v, c, UnityEngine.AnimatorClipInfo).$clone();
                            var weight = info.weight * layerWeight;
                            if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                continue;
                            }
                            var clip = this.GetAnimation(info.clip);
                            if (clip != null) {
                                previousAnimations.add(clip);
                            }
                        }

                        if (hasNext) {
                            for (var c1 = 0; c1 < nextClipInfoCount.v; c1 = (c1 + 1) | 0) {
                                var info1 = System.Array.getItem(nextClipInfo.v, c1, UnityEngine.AnimatorClipInfo).$clone();
                                var weight1 = info1.weight * layerWeight;
                                if (weight1 < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                    continue;
                                }
                                var clip1 = this.GetAnimation(info1.clip);
                                if (clip1 != null) {
                                    previousAnimations.add(clip1);
                                }
                            }
                        }

                        if (isInterruptionActive.v) {
                            for (var c2 = 0; c2 < interruptingClipInfoCount.v; c2 = (c2 + 1) | 0) {
                                var info2 = System.Array.getItem(interruptingClipInfo.v, c2, UnityEngine.AnimatorClipInfo).$clone();
                                var clipWeight = shallInterpolateWeightTo1.v ? (info2.weight + 1.0) * 0.5 : info2.weight;
                                var weight2 = clipWeight * layerWeight;
                                if (weight2 < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                    continue;
                                }
                                var clip2 = this.GetAnimation(info2.clip);
                                if (clip2 != null) {
                                    previousAnimations.add(clip2);
                                }
                            }
                        }
                    }
                }

                // Apply
                for (var layer3 = 0, n3 = this.animator.layerCount; layer3 < n3; layer3 = (layer3 + 1) | 0) {
                    var layerWeight1 = (layer3 === 0) ? 1 : this.animator.GetLayerWeight(layer3); // Animator.GetLayerWeight always returns 0 on the first layer. Should be interpreted as 1.

                    var isInterruptionActive1 = { };
                    var stateInfo = { };
                    var nextStateInfo1 = { };
                    var interruptingStateInfo = { };
                    var interruptingClipTimeAddition = { };
                    this.GetAnimatorStateInfos(layer3, isInterruptionActive1, stateInfo, nextStateInfo1, interruptingStateInfo, interruptingClipTimeAddition);

                    var hasNext1 = nextStateInfo1.v.fullPathHash !== 0;

                    var clipInfoCount1 = { }, nextClipInfoCount1 = { }, interruptingClipInfoCount1 = { };
                    var clipInfo1 = { }, nextClipInfo1 = { }, interruptingClipInfo1 = { };
                    var interpolateWeightTo1 = { };
                    this.GetAnimatorClipInfos(layer3, isInterruptionActive1, clipInfoCount1, nextClipInfoCount1, interruptingClipInfoCount1, clipInfo1, nextClipInfo1, interruptingClipInfo1, interpolateWeightTo1);

                    var layerBlendMode = (layer3 < this.layerBlendModes.length) ? this.layerBlendModes[layer3] : spine.MixBlend.replace;
                    var mode = this.GetMixMode(layer3, layerBlendMode);
                    if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix) {
                        // Always use Mix instead of Applying the first non-zero weighted clip.
                        for (var c3 = 0; c3 < clipInfoCount1.v; c3 = (c3 + 1) | 0) {
                            this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c3, UnityEngine.AnimatorClipInfo), stateInfo.v, layer3, layerWeight1, layerBlendMode);
                        }
                        if (hasNext1) {
                            for (var c4 = 0; c4 < nextClipInfoCount1.v; c4 = (c4 + 1) | 0) {
                                this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c4, UnityEngine.AnimatorClipInfo), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode);
                            }
                        }
                        if (isInterruptionActive1.v) {
                            for (var c5 = 0; c5 < interruptingClipInfoCount1.v; c5 = (c5 + 1) | 0) {
                                this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c5, UnityEngine.AnimatorClipInfo), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v);
                            }
                        }
                    } else { // case MixNext || Hard
                        // Apply first non-zero weighted clip
                        var c6 = 0;
                        for (; c6 < clipInfoCount1.v; c6 = (c6 + 1) | 0) {
                            if (!this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c6, UnityEngine.AnimatorClipInfo), stateInfo.v, layer3, layerWeight1, layerBlendMode, true)) {
                                continue;
                            }
                            c6 = (c6 + 1) | 0;
                            break;
                        }
                        // Mix the rest
                        for (; c6 < clipInfoCount1.v; c6 = (c6 + 1) | 0) {
                            this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c6, UnityEngine.AnimatorClipInfo), stateInfo.v, layer3, layerWeight1, layerBlendMode);
                        }

                        c6 = 0;
                        if (hasNext1) {
                            // Apply next clip directly instead of mixing (ie: no crossfade, ignores mecanim transition weights)
                            if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.Hard) {
                                for (; c6 < nextClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                    if (!this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c6, UnityEngine.AnimatorClipInfo), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode, true)) {
                                        continue;
                                    }
                                    c6 = (c6 + 1) | 0;
                                    break;
                                }
                            }
                            // Mix the rest
                            for (; c6 < nextClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                if (!this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c6, UnityEngine.AnimatorClipInfo), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode)) {
                                    continue;
                                }
                            }
                        }

                        c6 = 0;
                        if (isInterruptionActive1.v) {
                            // Apply next clip directly instead of mixing (ie: no crossfade, ignores mecanim transition weights)
                            if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.Hard) {
                                for (; c6 < interruptingClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                    if (this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c6, UnityEngine.AnimatorClipInfo), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v, true)) {

                                        c6 = (c6 + 1) | 0;
                                        break;
                                    }
                                }
                            }
                            // Mix the rest
                            for (; c6 < interruptingClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c6, UnityEngine.AnimatorClipInfo), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v);
                            }
                        }
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Apply end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetActiveAnimationAndTime start.*/
            GetActiveAnimationAndTime: function (layer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetActiveAnimationAndTime", this ); }

                if (layer >= this.layerClipInfos.length) {
                    return new (System.Collections.Generic.KeyValuePair$2(Spine.Animation,System.Single)).$ctor1(null, 0);
                }

                var layerInfos = this.layerClipInfos[layer];
                var isInterruptionActive = layerInfos.isInterruptionActive;
                var clip = null;
                var animation = null;
                var stateInfo;
                if (isInterruptionActive && layerInfos.interruptingClipInfoCount > 0) {
                    clip = layerInfos.interruptingClipInfos.getItem(0).$clone().clip;
                    stateInfo = layerInfos.interruptingStateInfo;
                } else {
                    clip = layerInfos.clipInfos.getItem(0).$clone().clip;
                    stateInfo = layerInfos.stateInfo;
                }
                animation = this.GetAnimation(clip);
                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime$1(stateInfo.normalizedTime, clip.length, clip.isLooping, stateInfo.speed < 0);
                return new (System.Collections.Generic.KeyValuePair$2(Spine.Animation,System.Single)).$ctor1(animation, time);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetActiveAnimationAndTime end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.InitClipInfosForLayers start.*/
            InitClipInfosForLayers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#InitClipInfosForLayers", this ); }

                if (this.layerClipInfos.length < this.animator.layerCount) {
                    System.Array.resize(Bridge.ref(this, "layerClipInfos"), this.animator.layerCount, null, Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos);
                    for (var layer = 0, n = this.animator.layerCount; layer < n; layer = (layer + 1) | 0) {
                        if (this.layerClipInfos[layer] == null) {
                            this.layerClipInfos[layer] = new Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos();
                        }
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.InitClipInfosForLayers end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ClearClipInfosForLayers start.*/
            ClearClipInfosForLayers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ClearClipInfosForLayers", this ); }

                for (var layer = 0, n = this.layerClipInfos.length; layer < n; layer = (layer + 1) | 0) {
                    if (this.layerClipInfos[layer] == null) {
                        this.layerClipInfos[layer] = new Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos();
                    } else {
                        this.layerClipInfos[layer].isInterruptionActive = false;
                        this.layerClipInfos[layer].isLastFrameOfInterruption = false;
                        this.layerClipInfos[layer].clipInfos.clear();
                        this.layerClipInfos[layer].nextClipInfos.clear();
                        this.layerClipInfos[layer].interruptingClipInfos.clear();
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ClearClipInfosForLayers end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetMixMode start.*/
            GetMixMode: function (layer, layerBlendMode) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetMixMode", this ); }

                if (this.useCustomMixMode) {
                    var mode = this.layerMixModes[layer];
                    // Note: at additive blending it makes no sense to use constant weight 1 at a fadeout anim add1 as
                    // with override layers, so we use AlwaysMix instead to use the proper weights.
                    // AlwaysMix leads to the expected result = lower_layer + lerp(add1, add2, transition_weight).
                    if (layerBlendMode === spine.MixBlend.add && mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext) {
                        mode = Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix;
                        this.layerMixModes[layer] = mode;
                    }
                    return mode;
                } else {
                    return layerBlendMode === spine.MixBlend.add ? Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix : Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext;
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetMixMode end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetStateUpdatesFromAnimator start.*/
            GetStateUpdatesFromAnimator: function (layer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetStateUpdatesFromAnimator", this ); }


                var layerInfos = this.layerClipInfos[layer];
                var clipInfoCount = this.animator.GetCurrentAnimatorClipInfoCount(layer);
                var nextClipInfoCount = this.animator.GetNextAnimatorClipInfoCount(layer);

                var clipInfos = layerInfos.clipInfos;
                var nextClipInfos = layerInfos.nextClipInfos;
                var interruptingClipInfos = layerInfos.interruptingClipInfos;

                layerInfos.isInterruptionActive = (clipInfoCount === 0 && clipInfos.Count !== 0 && nextClipInfoCount === 0 && nextClipInfos.Count !== 0);

                // Note: during interruption, GetCurrentAnimatorClipInfoCount and GetNextAnimatorClipInfoCount
                // are returning 0 in calls above. Therefore we keep previous clipInfos and nextClipInfos
                // until the interruption is over.
                if (layerInfos.isInterruptionActive) {

                    // Note: The last frame of a transition interruption
                    // will have fullPathHash set to 0, therefore we have to use previous
                    // frame's infos about interruption clips and correct some values
                    // accordingly (normalizedTime and weight).
                    var interruptingStateInfo = this.animator.GetNextAnimatorStateInfo(layer);
                    layerInfos.isLastFrameOfInterruption = interruptingStateInfo.fullPathHash === 0;
                    if (!layerInfos.isLastFrameOfInterruption) {
                        this.animator.GetNextAnimatorClipInfo(layer, interruptingClipInfos);
                        layerInfos.interruptingClipInfoCount = interruptingClipInfos.Count;
                        var oldTime = layerInfos.interruptingStateInfo.normalizedTime;
                        var newTime = interruptingStateInfo.normalizedTime;
                        layerInfos.interruptingClipTimeAddition = newTime - oldTime;
                        layerInfos.interruptingStateInfo = interruptingStateInfo;
                    }
                } else {
                    layerInfos.clipInfoCount = clipInfoCount;
                    layerInfos.nextClipInfoCount = nextClipInfoCount;
                    layerInfos.interruptingClipInfoCount = 0;
                    layerInfos.isLastFrameOfInterruption = false;

                    if (clipInfos.Capacity < clipInfoCount) {
                        clipInfos.Capacity = clipInfoCount;
                    }
                    if (nextClipInfos.Capacity < nextClipInfoCount) {
                        nextClipInfos.Capacity = nextClipInfoCount;
                    }

                    this.animator.GetCurrentAnimatorClipInfo(layer, clipInfos);
                    this.animator.GetNextAnimatorClipInfo(layer, nextClipInfos);

                    layerInfos.stateInfo = this.animator.GetCurrentAnimatorStateInfo(layer);
                    layerInfos.nextStateInfo = this.animator.GetNextAnimatorStateInfo(layer);
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetStateUpdatesFromAnimator end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorClipInfos start.*/
            GetAnimatorClipInfos: function (layer, isInterruptionActive, clipInfoCount, nextClipInfoCount, interruptingClipInfoCount, clipInfo, nextClipInfo, interruptingClipInfo, shallInterpolateWeightTo1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorClipInfos", this ); }


                var layerInfos = this.layerClipInfos[layer];
                isInterruptionActive.v = layerInfos.isInterruptionActive;

                clipInfoCount.v = layerInfos.clipInfoCount;
                nextClipInfoCount.v = layerInfos.nextClipInfoCount;
                interruptingClipInfoCount.v = layerInfos.interruptingClipInfoCount;

                clipInfo.v = layerInfos.clipInfos;
                nextClipInfo.v = layerInfos.nextClipInfos;
                interruptingClipInfo.v = isInterruptionActive.v ? layerInfos.interruptingClipInfos : null;
                shallInterpolateWeightTo1.v = layerInfos.isLastFrameOfInterruption;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorClipInfos end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorStateInfos start.*/
            GetAnimatorStateInfos: function (layer, isInterruptionActive, stateInfo, nextStateInfo, interruptingStateInfo, interruptingClipTimeAddition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorStateInfos", this ); }


                var layerInfos = this.layerClipInfos[layer];
                isInterruptionActive.v = layerInfos.isInterruptionActive;

                stateInfo.v = layerInfos.stateInfo;
                nextStateInfo.v = layerInfos.nextStateInfo;
                interruptingStateInfo.v = layerInfos.interruptingStateInfo;
                interruptingClipTimeAddition.v = layerInfos.isLastFrameOfInterruption ? layerInfos.interruptingClipTimeAddition : 0;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorStateInfos end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimation start.*/
            GetAnimation: function (clip) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimation", this ); }

                var clipNameHashCode = { };
                if (!this.clipNameHashCodeTable.tryGetValue(clip, clipNameHashCode)) {
                    clipNameHashCode.v = Bridge.getHashCode(clip.name);
                    this.clipNameHashCodeTable.add(clip, clipNameHashCode.v);
                }
                var animation = { };
                this.animationTable.tryGetValue(clipNameHashCode.v, animation);
                return animation.v;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimation end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(UnityEngine.AnimationClip)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#init", this ); }

                    this.Instance = new Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer();
                }
            }
        },
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$UnityEngine$AnimationClip$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$UnityEngine$AnimationClip$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        methods: {
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.equals2 start.*/
            equals2: function (x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#equals2", this ); }

                return x.GetInstanceID() === y.GetInstanceID();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.equals2 end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.getHashCode2 start.*/
            getHashCode2: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#getHashCode2", this ); }

                return o.GetInstanceID();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.getHashCode2 end.*/


        },
        overloads: {
            "Equals(AnimationClip, AnimationClip)": "equals2",
            "GetHashCode(AnimationClip)": "getHashCode2"
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos", {
        $kind: 1002,
        fields: {
            isInterruptionActive: false,
            isLastFrameOfInterruption: false,
            clipInfoCount: 0,
            nextClipInfoCount: 0,
            interruptingClipInfoCount: 0,
            clipInfos: null,
            nextClipInfos: null,
            interruptingClipInfos: null,
            stateInfo: null,
            nextStateInfo: null,
            interruptingStateInfo: null,
            interruptingClipTimeAddition: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos#init", this ); }

                this.isInterruptionActive = false;
                this.isLastFrameOfInterruption = false;
                this.clipInfoCount = 0;
                this.nextClipInfoCount = 0;
                this.interruptingClipInfoCount = 0;
                this.clipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.nextClipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.interruptingClipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.interruptingClipTimeAddition = 0;
            }
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(System.Int32)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#init", this ); }

                    this.Instance = new Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer();
                }
            }
        },
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$System$Int32$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$System$Int32$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        methods: {
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.equals2 start.*/
            equals2: function (x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#equals2", this ); }

                return x === y;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.equals2 end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.getHashCode2 start.*/
            getHashCode2: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#getHashCode2", this ); }

                return o;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.getHashCode2 end.*/


        },
        overloads: {
            "Equals(int, int)": "equals2",
            "GetHashCode(int)": "getHashCode2"
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode", {
        $kind: 1006,
        statics: {
            fields: {
                AlwaysMix: 0,
                MixNext: 1,
                Hard: 2
            }
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode end.*/

    /*Spine.Unity.SkeletonRootMotionBase start.*/
    /**
     * Base class for skeleton root motion components.
     *
     * @abstract
     * @public
     * @class Spine.Unity.SkeletonRootMotionBase
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.SkeletonRootMotionBase", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            rootMotionBoneName: null,
            transformPositionX: false,
            transformPositionY: false,
            rootMotionScaleX: 0,
            rootMotionScaleY: 0,
            /**
             * Skeleton space X translation per skeleton space Y translation root motion.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default 0
             * @type number
             */
            rootMotionTranslateXPerY: 0,
            /**
             * Skeleton space Y translation per skeleton space X translation root motion.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default 0
             * @type number
             */
            rootMotionTranslateYPerX: 0,
            rigidBody2D: null,
            applyRigidbody2DGravity: false,
            rigidBody: null,
            skeletonComponent: null,
            rootMotionBone: null,
            rootMotionBoneIndex: 0,
            topLevelBones: null,
            initialOffset: null,
            tempSkeletonDisplacement: null,
            rigidbodyDisplacement: null
        },
        props: {
            UsesRigidbody: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#UsesRigidbody#get", this ); }

                    return UnityEngine.Component.op_Inequality(this.rigidBody, null) || UnityEngine.Component.op_Inequality(this.rigidBody2D, null);
                }
            },
            AdditionalScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdditionalScale#get", this ); }

                    return 1.0;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#init", this ); }

                this.initialOffset = new UnityEngine.Vector2();
                this.tempSkeletonDisplacement = new UnityEngine.Vector2();
                this.rigidbodyDisplacement = new UnityEngine.Vector2();
                this.rootMotionBoneName = "root";
                this.transformPositionX = true;
                this.transformPositionY = true;
                this.rootMotionScaleX = 1;
                this.rootMotionScaleY = 1;
                this.rootMotionTranslateXPerY = 0;
                this.rootMotionTranslateYPerX = 0;
                this.applyRigidbody2DGravity = false;
                this.topLevelBones = new (System.Collections.Generic.List$1(Spine.Bone)).ctor();
                this.initialOffset = pc.Vec2.ZERO.clone();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRootMotionBase.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#Reset", this ); }

                this.FindRigidbodyComponent();
            },
            /*Spine.Unity.SkeletonRootMotionBase.Reset end.*/

            /*Spine.Unity.SkeletonRootMotionBase.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#Start", this ); }

                this.skeletonComponent = this.GetComponent(Spine.Unity.ISkeletonComponent);
                this.GatherTopLevelBones();
                this.SetRootMotionBone(this.rootMotionBoneName);
                if (this.rootMotionBone != null) {
                    this.initialOffset = new pc.Vec2( this.rootMotionBone.x, this.rootMotionBone.y );
                }

                var skeletonAnimation = Bridge.as(this.skeletonComponent, Spine.Unity.ISkeletonAnimation);
                if (skeletonAnimation != null) {
                    skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.HandleUpdateLocal));
                    skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateLocal(Bridge.fn.cacheBind(this, this.HandleUpdateLocal));
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.Start end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FixedUpdate", this ); }

                if (!this.isActiveAndEnabled) {
                    return;
                } // Root motion is only applied when component is enabled.

                if (UnityEngine.Component.op_Inequality(this.rigidBody2D, null)) {

                    var gravityAndVelocityMovement = pc.Vec2.ZERO.clone();
                    if (this.applyRigidbody2DGravity) {
                        var deltaTime = UnityEngine.Time.fixedDeltaTime;
                        var deltaTimeSquared = (deltaTime * deltaTime);

                        this.rigidBody2D.velocity = this.rigidBody2D.velocity.$clone().add( UnityEngine.Physics2D.gravity.$clone().scale( this.rigidBody2D.gravityScale ).scale( deltaTime ) );
                        gravityAndVelocityMovement = UnityEngine.Physics2D.gravity.$clone().scale( 0.5 * this.rigidBody2D.gravityScale ).scale( deltaTimeSquared ).add( this.rigidBody2D.velocity.$clone().scale( deltaTime ) );
                    }

                    this.rigidBody2D.MovePosition(gravityAndVelocityMovement.$clone().add( new pc.Vec2( this.transform.position.x, this.transform.position.y ) ).add( this.rigidbodyDisplacement ));
                }
                if (UnityEngine.Component.op_Inequality(this.rigidBody, null)) {
                    this.rigidBody.MovePosition(this.transform.position.$clone().add( new pc.Vec3( this.rigidbodyDisplacement.x, this.rigidbodyDisplacement.y, 0 ) ));
                }
                var parentBoneScale = { v : new UnityEngine.Vector2() };
                this.GetScaleAffectingRootMotion$1(parentBoneScale);
                this.ClearEffectiveBoneOffsets(parentBoneScale.v);
                this.rigidbodyDisplacement = pc.Vec2.ZERO.clone();
                this.tempSkeletonDisplacement = pc.Vec2.ZERO.clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.FixedUpdate end.*/

            /*Spine.Unity.SkeletonRootMotionBase.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#OnDisable", this ); }

                this.rigidbodyDisplacement = pc.Vec2.ZERO.clone();
                this.tempSkeletonDisplacement = pc.Vec2.ZERO.clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.OnDisable end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FindRigidbodyComponent start.*/
            FindRigidbodyComponent: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FindRigidbodyComponent", this ); }

                this.rigidBody2D = this.GetComponent(UnityEngine.Rigidbody2D);
                if (!UnityEngine.Object.op_Implicit(this.rigidBody2D)) {
                    this.rigidBody = this.GetComponent(UnityEngine.Rigidbody);
                }

                if (!UnityEngine.Object.op_Implicit(this.rigidBody2D) && !UnityEngine.Object.op_Implicit(this.rigidBody)) {
                    this.rigidBody2D = this.GetComponentInParent(UnityEngine.Rigidbody2D);
                    if (!UnityEngine.Object.op_Implicit(this.rigidBody2D)) {
                        this.rigidBody = this.GetComponentInParent(UnityEngine.Rigidbody);
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FindRigidbodyComponent end.*/

            /*Spine.Unity.SkeletonRootMotionBase.SetRootMotionBone start.*/
            SetRootMotionBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SetRootMotionBone", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var bone = skeleton.findBone(name);
                if (bone != null) {
                    this.rootMotionBoneIndex = bone.data.index;
                    this.rootMotionBone = bone;
                } else {
                    UnityEngine.Debug.Log$1("Bone named \"" + (name || "") + "\" could not be found.");
                    this.rootMotionBoneIndex = 0;
                    this.rootMotionBone = skeleton.getRootBone();
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.SetRootMotionBone end.*/

            /*Spine.Unity.SkeletonRootMotionBase.AdjustRootMotionToDistance start.*/
            AdjustRootMotionToDistance: function (distanceToTarget, trackIndex, adjustX, adjustY, minX, maxX, minY, maxY, allowXTranslation, allowYTranslation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdjustRootMotionToDistance", this ); }

                if (trackIndex === void 0) { trackIndex = 0; }
                if (adjustX === void 0) { adjustX = true; }
                if (adjustY === void 0) { adjustY = true; }
                if (minX === void 0) { minX = 0.0; }
                if (maxX === void 0) { maxX = 3.40282347E+38; }
                if (minY === void 0) { minY = 0.0; }
                if (maxY === void 0) { maxY = 3.40282347E+38; }
                if (allowXTranslation === void 0) { allowXTranslation = false; }
                if (allowYTranslation === void 0) { allowYTranslation = false; }

                var distanceToTargetSkeletonSpace = UnityEngine.Vector2.FromVector3(this.transform.InverseTransformVector(UnityEngine.Vector3.FromVector2(distanceToTarget)));
                var scaleAffectingRootMotion = this.GetScaleAffectingRootMotion();
                if (this.UsesRigidbody) {
                    distanceToTargetSkeletonSpace = distanceToTargetSkeletonSpace.$clone().sub( this.tempSkeletonDisplacement.$clone() );
                }

                var remainingRootMotionSkeletonSpace = this.GetRemainingRootMotion(trackIndex);
                remainingRootMotionSkeletonSpace.mul( scaleAffectingRootMotion );
                if (remainingRootMotionSkeletonSpace.x === 0) {
                    remainingRootMotionSkeletonSpace.x = 0.0001;
                }
                if (remainingRootMotionSkeletonSpace.y === 0) {
                    remainingRootMotionSkeletonSpace.y = 0.0001;
                }

                if (adjustX) {
                    this.rootMotionScaleX = Math.min(maxX, Math.max(minX, distanceToTargetSkeletonSpace.x / remainingRootMotionSkeletonSpace.x));
                }
                if (adjustY) {
                    this.rootMotionScaleY = Math.min(maxY, Math.max(minY, distanceToTargetSkeletonSpace.y / remainingRootMotionSkeletonSpace.y));
                }

                if (allowXTranslation) {
                    this.rootMotionTranslateXPerY = (distanceToTargetSkeletonSpace.x - remainingRootMotionSkeletonSpace.x * this.rootMotionScaleX) / remainingRootMotionSkeletonSpace.y;
                }
                if (allowYTranslation) {
                    this.rootMotionTranslateYPerX = (distanceToTargetSkeletonSpace.y - remainingRootMotionSkeletonSpace.y * this.rootMotionScaleY) / remainingRootMotionSkeletonSpace.x;
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.AdjustRootMotionToDistance end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion start.*/
            GetAnimationRootMotion: function (animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion", this ); }

                return this.GetAnimationRootMotion$1(0, animation.duration, animation);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion$1 start.*/
            GetAnimationRootMotion$1: function (startTime, endTime, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion$1", this ); }


                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone(animation, this.rootMotionBoneIndex);
                if (timeline != null) {
                    return this.GetTimelineMovementDelta(startTime, endTime, timeline, animation);
                }
                var xTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.TranslateXTimeline, animation, this.rootMotionBoneIndex);
                var yTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.TranslateYTimeline, animation, this.rootMotionBoneIndex);
                if (xTimeline != null || yTimeline != null) {
                    return this.GetTimelineMovementDelta$1(startTime, endTime, xTimeline, yTimeline, animation);
                }
                return pc.Vec2.ZERO.clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionInfo start.*/
            GetAnimationRootMotionInfo: function (animation, currentTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionInfo", this ); }

                var rootMotion = new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                var duration = animation.duration;
                var mid = duration * 0.5;
                rootMotion.timeIsPastMid = currentTime > mid;
                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone(animation, this.rootMotionBoneIndex);
                if (timeline != null) {
                    rootMotion.start = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, 0);
                    rootMotion.current = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, currentTime);
                    rootMotion.mid = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, mid);
                    rootMotion.end = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, duration);
                    return rootMotion.$clone();
                }
                var xTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.TranslateXTimeline, animation, this.rootMotionBoneIndex);
                var yTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.TranslateYTimeline, animation, this.rootMotionBoneIndex);
                if (xTimeline != null || yTimeline != null) {
                    rootMotion.start = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(xTimeline, yTimeline, 0);
                    rootMotion.current = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(xTimeline, yTimeline, currentTime);
                    rootMotion.mid = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(xTimeline, yTimeline, mid);
                    rootMotion.end = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(xTimeline, yTimeline, duration);
                    return rootMotion.$clone();
                }
                return rootMotion.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionInfo end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetTimelineMovementDelta start.*/
            GetTimelineMovementDelta: function (startTime, endTime, timeline, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetTimelineMovementDelta", this ); }


                var currentDelta = new UnityEngine.Vector2();
                if (startTime > endTime) {
                    currentDelta = (Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, animation.duration).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, startTime) )).add( (Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, endTime).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, 0) )) );
                } else {
                    if (startTime !== endTime) {
                        currentDelta = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, endTime).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(timeline, startTime) );
                    } else {
                        currentDelta = pc.Vec2.ZERO.clone();
                    }
                }
                return currentDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetTimelineMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetTimelineMovementDelta$1 start.*/
            GetTimelineMovementDelta$1: function (startTime, endTime, xTimeline, yTimeline, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetTimelineMovementDelta$1", this ); }


                var currentDelta = new UnityEngine.Vector2();
                if (startTime > endTime) {
                    currentDelta = (Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(xTimeline, yTimeline, animation.duration).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(xTimeline, yTimeline, startTime) )).add( (Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(xTimeline, yTimeline, endTime).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(xTimeline, yTimeline, 0) )) );
                } else {
                    if (startTime !== endTime) {
                        currentDelta = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(xTimeline, yTimeline, endTime).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(xTimeline, yTimeline, startTime) );
                    } else {
                        currentDelta = pc.Vec2.ZERO.clone();
                    }
                }
                return currentDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetTimelineMovementDelta$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GatherTopLevelBones start.*/
            GatherTopLevelBones: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GatherTopLevelBones", this ); }

                var $t;
                this.topLevelBones.clear();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                $t = Bridge.getEnumerator(skeleton.bones);
                try {
                    while ($t.moveNext()) {
                        var bone = $t.Current;
                        if (bone.parent == null) {
                            this.topLevelBones.add(bone);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.GatherTopLevelBones end.*/

            /*Spine.Unity.SkeletonRootMotionBase.HandleUpdateLocal start.*/
            HandleUpdateLocal: function (animatedSkeletonComponent) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#HandleUpdateLocal", this ); }

                if (!this.isActiveAndEnabled) {
                    return;
                } // Root motion is only applied when component is enabled.

                var boneLocalDelta = this.CalculateAnimationsMovementDelta();
                var parentBoneScale = { v : new UnityEngine.Vector2() };
                var skeletonDelta = this.GetSkeletonSpaceMovementDelta(boneLocalDelta.$clone(), parentBoneScale);
                this.ApplyRootMotion(skeletonDelta, parentBoneScale.v);
            },
            /*Spine.Unity.SkeletonRootMotionBase.HandleUpdateLocal end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyRootMotion start.*/
            ApplyRootMotion: function (skeletonDelta, parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyRootMotion", this ); }

                // Apply root motion to Transform or RigidBody;
                if (this.UsesRigidbody) {
                    this.rigidbodyDisplacement = this.rigidbodyDisplacement.$clone().add( UnityEngine.Vector2.FromVector3(this.transform.TransformVector(UnityEngine.Vector3.FromVector2(skeletonDelta))) );

                    // Accumulated displacement is applied on the next Physics update in FixedUpdate.
                    // Until the next Physics update, tempBoneDisplacement is offsetting bone locations
                    // to prevent stutter which would otherwise occur if we don't move every Update.
                    this.tempSkeletonDisplacement = this.tempSkeletonDisplacement.$clone().add( skeletonDelta.$clone() );
                    this.SetEffectiveBoneOffsetsTo(this.tempSkeletonDisplacement, parentBoneScale);
                } else {
                    this.transform.position = this.transform.position.$clone().add( this.transform.TransformVector(UnityEngine.Vector3.FromVector2(skeletonDelta)) );
                    this.ClearEffectiveBoneOffsets(parentBoneScale);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion start.*/
            GetScaleAffectingRootMotion: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion", this ); }

                var parentBoneScale = { v : new UnityEngine.Vector2() };
                return this.GetScaleAffectingRootMotion$1(parentBoneScale);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion$1 start.*/
            GetScaleAffectingRootMotion$1: function (parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion$1", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var totalScale = pc.Vec2.ONE.clone();
                totalScale.x *= skeleton.scaleX;
                totalScale.y *= skeleton.scaleY;

                parentBoneScale.v = pc.Vec2.ONE.clone();
                var scaleBone = this.rootMotionBone;
                while (((scaleBone = scaleBone.parent)) != null) {
                    parentBoneScale.v.x *= scaleBone.scaleX;
                    parentBoneScale.v.y *= scaleBone.scaleY;
                }
                totalScale = new pc.Vec2( totalScale.x * parentBoneScale.v.x, totalScale.y * parentBoneScale.v.y );
                totalScale = totalScale.$clone().scale( this.AdditionalScale );
                return totalScale.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceMovementDelta start.*/
            GetSkeletonSpaceMovementDelta: function (boneLocalDelta, parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceMovementDelta", this ); }

                var skeletonDelta = boneLocalDelta.$clone();
                var totalScale = this.GetScaleAffectingRootMotion$1(parentBoneScale);
                skeletonDelta.mul( totalScale );

                var rootMotionTranslation = new pc.Vec2( this.rootMotionTranslateXPerY * skeletonDelta.y, this.rootMotionTranslateYPerX * skeletonDelta.x );

                skeletonDelta.x *= this.rootMotionScaleX;
                skeletonDelta.y *= this.rootMotionScaleY;
                skeletonDelta.x += rootMotionTranslation.x;
                skeletonDelta.y += rootMotionTranslation.y;

                if (!this.transformPositionX) {
                    skeletonDelta.x = 0.0;
                }
                if (!this.transformPositionY) {
                    skeletonDelta.y = 0.0;
                }
                return skeletonDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.SetEffectiveBoneOffsetsTo start.*/
            SetEffectiveBoneOffsetsTo: function (displacementSkeletonSpace, parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SetEffectiveBoneOffsetsTo", this ); }

                var $t;
                // Move top level bones in opposite direction of the root motion bone
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                $t = Bridge.getEnumerator(this.topLevelBones);
                try {
                    while ($t.moveNext()) {
                        var topLevelBone = $t.Current;
                        if (Bridge.referenceEquals(topLevelBone, this.rootMotionBone)) {
                            if (this.transformPositionX) {
                                topLevelBone.x = displacementSkeletonSpace.x / skeleton.scaleX;
                            }
                            if (this.transformPositionY) {
                                topLevelBone.y = displacementSkeletonSpace.y / skeleton.scaleY;
                            }
                        } else {
                            var offsetX = (this.initialOffset.x - this.rootMotionBone.x) * parentBoneScale.x;
                            var offsetY = (this.initialOffset.y - this.rootMotionBone.y) * parentBoneScale.y;
                            if (this.transformPositionX) {
                                topLevelBone.x = (displacementSkeletonSpace.x / skeleton.scaleX) + offsetX;
                            }
                            if (this.transformPositionY) {
                                topLevelBone.y = (displacementSkeletonSpace.y / skeleton.scaleY) + offsetY;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.SetEffectiveBoneOffsetsTo end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ClearEffectiveBoneOffsets start.*/
            ClearEffectiveBoneOffsets: function (parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ClearEffectiveBoneOffsets", this ); }

                this.SetEffectiveBoneOffsetsTo(pc.Vec2.ZERO.clone(), parentBoneScale);
            },
            /*Spine.Unity.SkeletonRootMotionBase.ClearEffectiveBoneOffsets end.*/


        },
        overloads: {
            "GetAnimationRootMotion(float, float, Animation)": "GetAnimationRootMotion$1",
            "GetTimelineMovementDelta(float, float, TranslateXTimeline, TranslateYTimeline, Animation)": "GetTimelineMovementDelta$1",
            "GetScaleAffectingRootMotion(Vector2)": "GetScaleAffectingRootMotion$1"
        }
    });
    /*Spine.Unity.SkeletonRootMotionBase end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate
     * @param   {Spine.Unity.SkeletonPartsRenderer}    skeletonPartsRenderer
     * @return  {void}
     */


    /*Spine.Unity.SkeletonPartsRenderer start.*/
    Bridge.define("Spine.Unity.SkeletonPartsRenderer", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject:static start.*/
                NewPartsRendererGameObject: function (parent, name, sortingOrder) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#NewPartsRendererGameObject", this ); }

                    if (sortingOrder === void 0) { sortingOrder = 0; }
                    var go = new UnityEngine.GameObject.$ctor4(name, [UnityEngine.MeshFilter, UnityEngine.MeshRenderer]);
                    go.transform.SetParent(parent, false);
                    var returnComponent = go.AddComponent(Spine.Unity.SkeletonPartsRenderer);
                    returnComponent.MeshRenderer.sortingOrder = sortingOrder;

                    return returnComponent;
                },
                /*Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject:static end.*/


            }
        },
        fields: {
            meshGenerator: null,
            meshRenderer: null,
            meshFilter: null,
            buffers: null,
            currentInstructions: null
        },
        events: {
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonPartsRenderer
             * @memberof Spine.Unity.SkeletonPartsRenderer
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonPartsRenderer
             * @memberof Spine.Unity.SkeletonPartsRenderer
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            MeshGenerator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshGenerator#get", this ); }

                    this.LazyIntialize();
                    return this.meshGenerator;
                }
            },
            MeshRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshRenderer#get", this ); }

                    this.LazyIntialize();
                    return this.meshRenderer;
                }
            },
            MeshFilter: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshFilter#get", this ); }

                    this.LazyIntialize();
                    return this.meshFilter;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#init", this ); }

                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonPartsRenderer.LazyIntialize start.*/
            LazyIntialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#LazyIntialize", this ); }

                if (this.buffers == null) {
                    this.buffers = new Spine.Unity.MeshRendererBuffers();
                    this.buffers.Initialize();

                    if (this.meshGenerator != null) {
                        return;
                    }
                    this.meshGenerator = new Spine.Unity.MeshGenerator();
                    this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                    this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                    this.currentInstructions.Clear();
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.LazyIntialize end.*/

            /*Spine.Unity.SkeletonPartsRenderer.ClearMesh start.*/
            ClearMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#ClearMesh", this ); }

                this.LazyIntialize();
                this.meshFilter.sharedMesh = null;
            },
            /*Spine.Unity.SkeletonPartsRenderer.ClearMesh end.*/

            /*Spine.Unity.SkeletonPartsRenderer.RenderParts start.*/
            RenderParts: function (instructions, startSubmesh, endSubmesh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#RenderParts", this ); }

                this.LazyIntialize();

                // STEP 1: Create instruction
                var smartMesh = this.buffers.GetNextMesh();
                this.currentInstructions.SetWithSubset(instructions, startSubmesh, endSubmesh);
                var updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(this.currentInstructions, smartMesh.instructionUsed);

                // STEP 2: Generate mesh buffers.
                var currentInstructionsSubmeshesItems = this.currentInstructions.submeshInstructions.Items;
                this.meshGenerator.Begin();
                if (this.currentInstructions.hasActiveClipping) {
                    for (var i = 0; i < this.currentInstructions.submeshInstructions.Count; i = (i + 1) | 0) {
                        this.meshGenerator.AddSubmesh(currentInstructionsSubmeshesItems[i], updateTriangles);
                    }
                } else {
                    this.meshGenerator.BuildMeshWithArrays(this.currentInstructions, updateTriangles);
                }

                this.buffers.UpdateSharedMaterials(this.currentInstructions.submeshInstructions);

                // STEP 3: modify mesh.
                var mesh = smartMesh.mesh;

                if (this.meshGenerator.VertexCount <= 0) { // Clear an empty mesh
                    updateTriangles = false;
                    mesh.Clear();
                } else {
                    this.meshGenerator.FillVertexData(mesh);
                    if (updateTriangles) {
                        this.meshGenerator.FillTriangles(mesh);
                        this.meshRenderer.sharedMaterials = this.buffers.GetUpdatedSharedMaterialsArray();
                    } else if (this.buffers.MaterialsChangedInLastUpdate()) {
                        this.meshRenderer.sharedMaterials = this.buffers.GetUpdatedSharedMaterialsArray();
                    }
                    this.meshGenerator.FillLateVertexData(mesh);
                }

                this.meshFilter.sharedMesh = mesh;
                smartMesh.instructionUsed.Set(this.currentInstructions);

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.RenderParts end.*/

            /*Spine.Unity.SkeletonPartsRenderer.SetPropertyBlock start.*/
            SetPropertyBlock: function (block) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#SetPropertyBlock", this ); }

                this.LazyIntialize();
                this.meshRenderer.SetPropertyBlock(block);
            },
            /*Spine.Unity.SkeletonPartsRenderer.SetPropertyBlock end.*/


        }
    });
    /*Spine.Unity.SkeletonPartsRenderer end.*/

    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials", {
        $kind: 1002,
        fields: {
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsMaskDisabled: null,
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsInsideMask: null,
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsOutsideMask: null
        },
        props: {
            AnyMaterialCreated: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#AnyMaterialCreated#get", this ); }

                    return this.materialsMaskDisabled.length > 0 || this.materialsInsideMask.length > 0 || this.materialsOutsideMask.length > 0;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#init", this ); }

                this.materialsMaskDisabled = System.Array.init(0, null, UnityEngine.Material);
                this.materialsInsideMask = System.Array.init(0, null, UnityEngine.Material);
                this.materialsOutsideMask = System.Array.init(0, null, UnityEngine.Material);
            }
        }
    });
    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            customSlotMaterials: null,
            customMaterialOverrides: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#init", this ); }

                this.customSlotMaterials = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride)).ctor();
                this.customMaterialOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomSlotMaterials start.*/
            SetCustomSlotMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#SetCustomSlotMaterials", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customSlotMaterials.Count; i = (i + 1) | 0) {
                    var slotMaterialOverride = this.customSlotMaterials.getItem(i).$clone();
                    if (slotMaterialOverride.overrideDisabled || System.String.isNullOrEmpty(slotMaterialOverride.slotName)) {
                        continue;
                    }

                    var slotObject = this.skeletonRenderer.skeleton.findSlot(slotMaterialOverride.slotName);
                    if (slotObject != null) {
                        this.skeletonRenderer.CustomSlotMaterials.setItem(slotObject, slotMaterialOverride.material);
                    }
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomSlotMaterials end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomSlotMaterials start.*/
            RemoveCustomSlotMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomSlotMaterials", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customSlotMaterials.Count; i = (i + 1) | 0) {
                    var slotMaterialOverride = this.customSlotMaterials.getItem(i).$clone();
                    if (System.String.isNullOrEmpty(slotMaterialOverride.slotName)) {
                        continue;
                    }

                    var slotObject = this.skeletonRenderer.skeleton.findSlot(slotMaterialOverride.slotName);
                    if (slotObject == null) {
                        continue;
                    }
                    var currentMaterial = { };
                    if (!this.skeletonRenderer.CustomSlotMaterials.tryGetValue(slotObject, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, slotMaterialOverride.material)) {
                        continue;
                    }

                    this.skeletonRenderer.CustomSlotMaterials.remove(slotObject);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomSlotMaterials end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomMaterialOverrides start.*/
            SetCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#SetCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    if (atlasMaterialOverride.overrideDisabled) {
                        continue;
                    }

                    this.skeletonRenderer.CustomMaterialOverride.setItem(atlasMaterialOverride.originalMaterial, atlasMaterialOverride.replacementMaterial);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomMaterialOverrides start.*/
            RemoveCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    var currentMaterial = { };

                    if (!this.skeletonRenderer.CustomMaterialOverride.tryGetValue(atlasMaterialOverride.originalMaterial, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, atlasMaterialOverride.replacementMaterial)) {
                        continue;
                    }

                    this.skeletonRenderer.CustomMaterialOverride.remove(atlasMaterialOverride.originalMaterial);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                this.skeletonRenderer.Initialize(false);
                this.SetCustomMaterialOverrides();
                this.SetCustomSlotMaterials();
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.OnEnable end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                this.RemoveCustomMaterialOverrides();
                this.RemoveCustomSlotMaterials();
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride(); }
            }
        },
        fields: {
            overrideDisabled: false,
            originalMaterial: null,
            replacementMaterial: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonRendererCustomMaterials$AtlasMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#equalsT", this ); }

                return this.overrideDisabled === other.overrideDisabled && Bridge.referenceEquals(this.originalMaterial, other.originalMaterial) && Bridge.referenceEquals(this.replacementMaterial, other.replacementMaterial);
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([8608216668, this.overrideDisabled, this.originalMaterial, this.replacementMaterial]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride();
                s.overrideDisabled = this.overrideDisabled;
                s.originalMaterial = this.originalMaterial;
                s.replacementMaterial = this.replacementMaterial;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride(); }
            }
        },
        fields: {
            overrideDisabled: false,
            slotName: null,
            material: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonRendererCustomMaterials$SlotMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#equalsT", this ); }

                return this.overrideDisabled === other.overrideDisabled && Bridge.referenceEquals(this.slotName, other.slotName) && Bridge.referenceEquals(this.material, other.material);
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([9094239955, this.overrideDisabled, this.slotName, this.material]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride();
                s.overrideDisabled = this.overrideDisabled;
                s.slotName = this.slotName;
                s.material = this.material;
                return s;
            }
        },
        overloads: {
            "Equals(SlotMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererInstruction start.*/
    /**
     * Instructions used by a SkeletonRenderer to render a mesh.
     *
     * @public
     * @class Spine.Unity.SkeletonRendererInstruction
     */
    Bridge.define("Spine.Unity.SkeletonRendererInstruction", {
        statics: {
            methods: {
                /*Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual:static start.*/
                GeometryNotEqual: function (a, b) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#GeometryNotEqual", this ); }


                    if (a.hasActiveClipping || b.hasActiveClipping) {
                        return true;
                    } // Triangles are unpredictable when clipping is active.

                    // Everything below assumes the raw vertex and triangle counts were used. (ie, no clipping was done)
                    if (a.rawVertexCount !== b.rawVertexCount) {
                        return true;
                    }

                    if (a.immutableTriangles !== b.immutableTriangles) {
                        return true;
                    }

                    var attachmentCountB = b.attachments.Count;
                    if (a.attachments.Count !== attachmentCountB) {
                        return true;
                    } // Bounds check for the looped storedAttachments count below.

                    // Submesh count changed
                    var submeshCountA = a.submeshInstructions.Count;
                    var submeshCountB = b.submeshInstructions.Count;
                    if (submeshCountA !== submeshCountB) {
                        return true;
                    }

                    // Submesh Instruction mismatch
                    var submeshInstructionsItemsA = a.submeshInstructions.Items;
                    var submeshInstructionsItemsB = b.submeshInstructions.Items;

                    var attachmentsA = a.attachments.Items;
                    var attachmentsB = b.attachments.Items;
                    for (var i = 0; i < attachmentCountB; i = (i + 1) | 0) {
                        if (!Bridge.referenceEquals(attachmentsA[i], attachmentsB[i])) {
                            return true;
                        }
                    }

                    for (var i1 = 0; i1 < submeshCountB; i1 = (i1 + 1) | 0) {
                        var submeshA = submeshInstructionsItemsA[i1].$clone();
                        var submeshB = submeshInstructionsItemsB[i1].$clone();

                        if (!(submeshA.rawVertexCount === submeshB.rawVertexCount && submeshA.startSlot === submeshB.startSlot && submeshA.endSlot === submeshB.endSlot && submeshA.rawTriangleCount === submeshB.rawTriangleCount && submeshA.rawFirstVertexIndex === submeshB.rawFirstVertexIndex)) {
                            return true;
                        }
                    }

                    return false;
                },
                /*Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual:static end.*/


            }
        },
        fields: {
            submeshInstructions: null,
            immutableTriangles: false,
            hasActiveClipping: false,
            rawVertexCount: 0,
            attachments: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#init", this ); }

                this.submeshInstructions = new (Spine.ExposedList$1(Spine.Unity.SubmeshInstruction)).ctor();
                this.rawVertexCount = -1;
                this.attachments = new (Spine.ExposedList$1(spine.Attachment)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererInstruction.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Clear", this ); }

                this.attachments.Clear(false);
                this.rawVertexCount = -1;
                this.hasActiveClipping = false;
                this.submeshInstructions.Clear(false);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Clear end.*/

            /*Spine.Unity.SkeletonRendererInstruction.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Dispose", this ); }

                this.attachments.Clear(true);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Dispose end.*/

            /*Spine.Unity.SkeletonRendererInstruction.SetWithSubset start.*/
            SetWithSubset: function (instructions, startSubmesh, endSubmesh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#SetWithSubset", this ); }

                var runningVertexCount = 0;

                var submeshes = this.submeshInstructions;
                submeshes.Clear(false);
                var submeshCount = (endSubmesh - startSubmesh) | 0;
                submeshes.Resize(submeshCount);
                var submeshesItems = submeshes.Items;
                var instructionsItems = instructions.Items;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var instruction = instructionsItems[((startSubmesh + i) | 0)].$clone();
                    submeshesItems[i] = instruction.$clone();
                    this.hasActiveClipping = !!(this.hasActiveClipping | instruction.hasClipping);
                    submeshesItems[i].rawFirstVertexIndex = runningVertexCount; // Ensure current instructions have correct cached values.
                    runningVertexCount = (runningVertexCount + instruction.rawVertexCount) | 0; // vertexCount will also be used for the rest of this method.
                }
                this.rawVertexCount = runningVertexCount;

                // assumption: instructions are contiguous. start and end are valid within instructions.

                var startSlot = instructionsItems[startSubmesh].startSlot;
                var endSlot = instructionsItems[((endSubmesh - 1) | 0)].endSlot;
                this.attachments.Clear(false);
                var attachmentCount = (endSlot - startSlot) | 0;
                this.attachments.Resize(attachmentCount);
                var attachmentsItems = this.attachments.Items;

                var drawOrderItems = instructionsItems[0].skeleton.DrawOrder.Items;
                for (var i1 = 0; i1 < attachmentCount; i1 = (i1 + 1) | 0) {
                    var slot = drawOrderItems[((startSlot + i1) | 0)];
                    if (!slot.bone.isActive()) {
                        continue;
                    }
                    attachmentsItems[i1] = slot.getAttachment();
                }

            },
            /*Spine.Unity.SkeletonRendererInstruction.SetWithSubset end.*/

            /*Spine.Unity.SkeletonRendererInstruction.Set start.*/
            Set: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Set", this ); }

                this.immutableTriangles = other.immutableTriangles;

                this.hasActiveClipping = other.hasActiveClipping;
                this.rawVertexCount = other.rawVertexCount;
                this.attachments.Clear(false);
                this.attachments.EnsureCapacity(other.attachments.Capacity);
                this.attachments.Count = other.attachments.Count;
                other.attachments.CopyTo(this.attachments.Items);

                this.submeshInstructions.Clear(false);
                this.submeshInstructions.EnsureCapacity(other.submeshInstructions.Capacity);
                this.submeshInstructions.Count = other.submeshInstructions.Count;
                other.submeshInstructions.CopyTo(this.submeshInstructions.Items);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Set end.*/


        }
    });
    /*Spine.Unity.SkeletonRendererInstruction end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate
     * @param   {Spine.Unity.SkeletonRenderer}    skeletonRenderer
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRenderSeparator start.*/
    Bridge.define("Spine.Unity.SkeletonRenderSeparator", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DefaultSortingOrderIncrement: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#init", this ); }

                    this.DefaultSortingOrderIncrement = 5;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonRenderSeparator.AddToSkeletonRenderer:static start.*/
                /**
                 * Adds a SkeletonRenderSeparator and child SkeletonPartsRenderer GameObjects to a given SkeletonRenderer.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonRenderSeparator
                 * @memberof Spine.Unity.SkeletonRenderSeparator
                 * @param   {Spine.Unity.SkeletonRenderer}           skeletonRenderer            The target SkeletonRenderer or SkeletonAnimation.
                 * @param   {number}                                 sortingLayerID              Sorting layer to be used for the parts renderers.
                 * @param   {number}                                 extraPartsRenderers         Number of additional SkeletonPartsRenderers on top of the ones determined by counting the number of separator slots.
                 * @param   {number}                                 sortingOrderIncrement       The integer to increment the sorting order per SkeletonPartsRenderer to separate them.
                 * @param   {number}                                 baseSortingOrder            The sorting order value of the first SkeletonPartsRenderer.
                 * @param   {boolean}                                addMinimumPartsRenderers    If set to <pre><code>true</code></pre>, a minimum number of SkeletonPartsRenderer GameObjects (determined by separatorSlots.Count + 1) will be added.
                 * @return  {Spine.Unity.SkeletonRenderSeparator}                                The to skeleton renderer.
                 */
                AddToSkeletonRenderer: function (skeletonRenderer, sortingLayerID, extraPartsRenderers, sortingOrderIncrement, baseSortingOrder, addMinimumPartsRenderers) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#AddToSkeletonRenderer", this ); }

                    if (sortingLayerID === void 0) { sortingLayerID = 0; }
                    if (extraPartsRenderers === void 0) { extraPartsRenderers = 0; }
                    if (sortingOrderIncrement === void 0) { sortingOrderIncrement = 5; }
                    if (baseSortingOrder === void 0) { baseSortingOrder = 0; }
                    if (addMinimumPartsRenderers === void 0) { addMinimumPartsRenderers = true; }
                    if (UnityEngine.MonoBehaviour.op_Equality(skeletonRenderer, null)) {
                        UnityEngine.Debug.Log$1("Tried to add SkeletonRenderSeparator to a null SkeletonRenderer reference.");
                        return null;
                    }

                    var srs = skeletonRenderer.gameObject.AddComponent(Spine.Unity.SkeletonRenderSeparator);
                    srs.skeletonRenderer = skeletonRenderer;

                    skeletonRenderer.Initialize(false);
                    var count = extraPartsRenderers;
                    if (addMinimumPartsRenderers) {
                        count = (((extraPartsRenderers + skeletonRenderer.separatorSlots.Count) | 0) + 1) | 0;
                    }

                    var skeletonRendererTransform = skeletonRenderer.transform;
                    var componentRenderers = srs.partsRenderers;

                    for (var i = 0; i < count; i = (i + 1) | 0) {
                        var spr = Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject(skeletonRendererTransform, Bridge.toString(i));
                        var mr = spr.MeshRenderer;
                        mr.sortingLayerID = sortingLayerID;
                        mr.sortingOrder = (baseSortingOrder + (Bridge.Int.mul(i, sortingOrderIncrement))) | 0;
                        componentRenderers.add(spr);
                    }

                    srs.OnEnable();


                    return srs;
                },
                /*Spine.Unity.SkeletonRenderSeparator.AddToSkeletonRenderer:static end.*/


            }
        },
        fields: {
            skeletonRenderer: null,
            mainMeshRenderer: null,
            copyPropertyBlock: false,
            copyMeshRendererFlags: false,
            partsRenderers: null,
            copiedBlock: null
        },
        events: {
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#set", this ); }

                    if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                        this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                    }

                    this.skeletonRenderer = value;
                    if (UnityEngine.MonoBehaviour.op_Equality(value, null)) {
                        this.enabled = false;
                    }
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#init", this ); }

                this.copyPropertyBlock = true;
                this.copyMeshRendererFlags = true;
                this.partsRenderers = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonPartsRenderer)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRenderSeparator.AddPartsRenderer start.*/
            /**
             * Add a child SkeletonPartsRenderer GameObject to this SkeletonRenderSeparator.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @param   {number}                               sortingOrderIncrement    
             * @param   {string}                               name
             * @return  {Spine.Unity.SkeletonPartsRenderer}
             */
            AddPartsRenderer: function (sortingOrderIncrement, name) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#AddPartsRenderer", this ); }

                if (sortingOrderIncrement === void 0) { sortingOrderIncrement = 5; }
                if (name === void 0) { name = null; }
                var sortingLayerID = 0;
                var sortingOrder = 0;
                if (this.partsRenderers.Count > 0) {
                    var previous = this.partsRenderers.getItem(((this.partsRenderers.Count - 1) | 0));
                    var previousMeshRenderer = previous.MeshRenderer;
                    sortingLayerID = previousMeshRenderer.sortingLayerID;
                    sortingOrder = (previousMeshRenderer.sortingOrder + sortingOrderIncrement) | 0;
                }

                if (System.String.isNullOrEmpty(name)) {
                    name = Bridge.toString(this.partsRenderers.Count);
                }

                var spr = Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject(this.skeletonRenderer.transform, name);
                this.partsRenderers.add(spr);

                var mr = spr.MeshRenderer;
                mr.sortingLayerID = sortingLayerID;
                mr.sortingOrder = sortingOrder;

                return spr;
            },
            /*Spine.Unity.SkeletonRenderSeparator.AddPartsRenderer end.*/

            /*Spine.Unity.SkeletonRenderSeparator.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                if (this.copiedBlock == null) {
                    this.copiedBlock = new UnityEngine.MaterialPropertyBlock();
                }
                this.mainMeshRenderer = this.skeletonRenderer.GetComponent(UnityEngine.MeshRenderer);

                this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                this.skeletonRenderer.addGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));

                if (this.copyMeshRendererFlags) {
                    var lightProbeUsage = this.mainMeshRenderer.lightProbeUsage;
                    var receiveShadows = this.mainMeshRenderer.receiveShadows;
                    var reflectionProbeUsage = this.mainMeshRenderer.reflectionProbeUsage;
                    var shadowCastingMode = this.mainMeshRenderer.shadowCastingMode;
                    var motionVectorGenerationMode = this.mainMeshRenderer.motionVectorGenerationMode;
                    var probeAnchor = this.mainMeshRenderer.probeAnchor;

                    for (var i = 0; i < this.partsRenderers.Count; i = (i + 1) | 0) {
                        var currentRenderer = this.partsRenderers.getItem(i);
                        if (UnityEngine.MonoBehaviour.op_Equality(currentRenderer, null)) {
                            continue;
                        } // skip null items.

                        var mr = currentRenderer.MeshRenderer;
                        mr.lightProbeUsage = lightProbeUsage;
                        mr.receiveShadows = receiveShadows;
                        mr.reflectionProbeUsage = reflectionProbeUsage;
                        mr.shadowCastingMode = shadowCastingMode;
                        mr.motionVectorGenerationMode = motionVectorGenerationMode;
                        mr.probeAnchor = probeAnchor;
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.OnEnable end.*/

            /*Spine.Unity.SkeletonRenderSeparator.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#OnDisable", this ); }

                var $t;
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));

                this.skeletonRenderer.LateUpdate();

                $t = Bridge.getEnumerator(this.partsRenderers);
                try {
                    while ($t.moveNext()) {
                        var partsRenderer = $t.Current;
                        if (UnityEngine.MonoBehaviour.op_Inequality(partsRenderer, null)) {
                            partsRenderer.ClearMesh();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.OnDisable end.*/

            /*Spine.Unity.SkeletonRenderSeparator.HandleRender start.*/
            HandleRender: function (instruction) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#HandleRender", this ); }

                var $t;
                var rendererCount = this.partsRenderers.Count;
                if (rendererCount <= 0) {
                    return;
                }

                if (this.copyPropertyBlock) {
                    this.mainMeshRenderer.GetPropertyBlock(this.copiedBlock);
                }

                var settings = ($t = new Spine.Unity.MeshGenerator.Settings(), $t.addNormals = this.skeletonRenderer.addNormals, $t.calculateTangents = this.skeletonRenderer.calculateTangents, $t.immutableTriangles = false, $t.pmaVertexColors = this.skeletonRenderer.pmaVertexColors, $t.tintBlack = this.skeletonRenderer.tintBlack, $t.useClipping = true, $t.zSpacing = this.skeletonRenderer.zSpacing, $t);

                var submeshInstructions = instruction.submeshInstructions;
                var submeshInstructionsItems = submeshInstructions.Items;
                var lastSubmeshInstruction = (submeshInstructions.Count - 1) | 0;

                var rendererIndex = 0;
                var currentRenderer = this.partsRenderers.getItem(rendererIndex);
                for (var si = 0, start = 0; si <= lastSubmeshInstruction; si = (si + 1) | 0) {
                    if (UnityEngine.MonoBehaviour.op_Equality(currentRenderer, null)) {
                        continue;
                    }
                    if (submeshInstructionsItems[si].forceSeparate || si === lastSubmeshInstruction) {
                        // Apply properties
                        var meshGenerator = currentRenderer.MeshGenerator;
                        meshGenerator.settings = settings.$clone();

                        if (this.copyPropertyBlock) {
                            currentRenderer.SetPropertyBlock(this.copiedBlock);
                        }

                        // Render
                        currentRenderer.RenderParts(instruction.submeshInstructions, start, ((si + 1) | 0));

                        start = (si + 1) | 0;
                        rendererIndex = (rendererIndex + 1) | 0;
                        if (rendererIndex < rendererCount) {
                            currentRenderer = this.partsRenderers.getItem(rendererIndex);
                        } else {
                            // Not enough renderers. Skip the rest of the instructions.
                            break;
                        }
                    }
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this.skeletonRenderer);
                }

                // Clear extra renderers if they exist.
                for (; rendererIndex < rendererCount; rendererIndex = (rendererIndex + 1) | 0) {
                    currentRenderer = this.partsRenderers.getItem(rendererIndex);
                    if (UnityEngine.MonoBehaviour.op_Inequality(currentRenderer, null)) {
                        this.partsRenderers.getItem(rendererIndex).ClearMesh();
                    }
                }

            },
            /*Spine.Unity.SkeletonRenderSeparator.HandleRender end.*/


        }
    });
    /*Spine.Unity.SkeletonRenderSeparator end.*/

    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo start.*/
    Bridge.define("Spine.Unity.SkeletonRootMotionBase.RootMotionInfo", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo(); }
            }
        },
        fields: {
            start: null,
            current: null,
            mid: null,
            end: null,
            timeIsPastMid: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#init", this ); }

                this.start = new UnityEngine.Vector2();
                this.current = new UnityEngine.Vector2();
                this.mid = new UnityEngine.Vector2();
                this.end = new UnityEngine.Vector2();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getHashCode", this ); }

                var h = Bridge.addHash([5573033076, this.start, this.current, this.mid, this.end, this.timeIsPastMid]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SkeletonRootMotionBase.RootMotionInfo)) {
                    return false;
                }
                return Bridge.equals(this.start, o.start) && Bridge.equals(this.current, o.current) && Bridge.equals(this.mid, o.mid) && Bridge.equals(this.end, o.end) && Bridge.equals(this.timeIsPastMid, o.timeIsPastMid);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                s.start = this.start.$clone();
                s.current = this.current.$clone();
                s.mid = this.mid.$clone();
                s.end = this.end.$clone();
                s.timeIsPastMid = this.timeIsPastMid;
                return s;
            }
        }
    });
    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo end.*/

    /*Spine.Unity.SkeletonSubmeshGraphic start.*/
    /**
     * A minimal MaskableGraphic subclass for rendering multiple submeshes
     at a {@link }.
     *
     * @public
     * @class Spine.Unity.SkeletonSubmeshGraphic
     * @augments UnityEngine.UI.MaskableGraphic
     */
    Bridge.define("Spine.Unity.SkeletonSubmeshGraphic", {
        inherits: [UnityEngine.UI.MaskableGraphic],
        methods: {
            /*Spine.Unity.SkeletonSubmeshGraphic.SetMaterialDirty start.*/
            SetMaterialDirty: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#SetMaterialDirty", this ); }
 },
            /*Spine.Unity.SkeletonSubmeshGraphic.SetMaterialDirty end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.SetVerticesDirty start.*/
            SetVerticesDirty: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#SetVerticesDirty", this ); }
 },
            /*Spine.Unity.SkeletonSubmeshGraphic.SetVerticesDirty end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.OnPopulateMesh start.*/
            OnPopulateMesh: function (vh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#OnPopulateMesh", this ); }

                vh.Clear();
            },
            /*Spine.Unity.SkeletonSubmeshGraphic.OnPopulateMesh end.*/


        }
    });
    /*Spine.Unity.SkeletonSubmeshGraphic end.*/

    /*Spine.Unity.SkeletonUtility start.*/
    Bridge.define("Spine.Unity.SkeletonUtility", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject:static start.*/
                AddBoundingBoxGameObject: function (skeleton, skinName, slotName, attachmentName, parent, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    var skin = System.String.isNullOrEmpty(skinName) ? skeleton.data.defaultSkin : skeleton.data.findSkin(skinName);
                    if (skin == null) {
                        UnityEngine.Debug.LogError$2("Skin " + (skinName || "") + " not found!");
                        return null;
                    }

                    var slot = skeleton.findSlot(slotName);
                    var attachment = slot != null ? skin.getAttachment(slot.data.index, attachmentName) : null;
                    if (attachment == null) {
                        UnityEngine.Debug.LogFormat("Attachment in slot '{0}' named '{1}' not found in skin '{2}'.", [slotName, attachmentName, skin.name]);
                        return null;
                    }

                    var box = Bridge.as(attachment, spine.BoundingBoxAttachment);
                    if (box != null) {
                        return Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1(box.name, box, slot, parent, isTrigger);
                    } else {
                        UnityEngine.Debug.LogFormat("Attachment '{0}' was not a Bounding Box.", [attachmentName]);
                        return null;
                    }
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1:static start.*/
                AddBoundingBoxGameObject$1: function (name, box, slot, parent, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject$1", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    var go = new UnityEngine.GameObject.$ctor2("[BoundingBox]" + ((System.String.isNullOrEmpty(name) ? box.name : name) || ""));
                    var got = go.transform;
                    got.parent = parent;
                    got.localPosition = pc.Vec3.ZERO.clone();
                    got.localRotation = pc.Quat.IDENTITY.clone();
                    got.localScale = new pc.Vec3( 1, 1, 1 );
                    return Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent(box, slot, go, isTrigger);
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent:static start.*/
                AddBoundingBoxAsComponent: function (box, slot, gameObject, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxAsComponent", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    if (box == null) {
                        return null;
                    }
                    var collider = gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                    collider.isTrigger = isTrigger;
                    Spine.Unity.SkeletonUtility.SetColliderPointsLocal(collider, slot, box);
                    return collider;
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent:static end.*/

                /*Spine.Unity.SkeletonUtility.SetColliderPointsLocal:static start.*/
                SetColliderPointsLocal: function (collider, slot, box, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SetColliderPointsLocal", this ); }

                    if (scale === void 0) { scale = 1.0; }
                    if (box == null) {
                        return;
                    }
                    if (Spine.SpineSkeletonExtensions.IsWeighted(box)) {
                        UnityEngine.Debug.LogWarning$1("UnityEngine.PolygonCollider2D does not support weighted or animated points. Collider points will not be animated and may have incorrect orientation. If you want to use it as a collider, please remove weights and animations from the bounding box in Spine editor.");
                    }
                    var verts = Spine.Unity.SkeletonExtensions.GetLocalVertices(box, slot, null);
                    if (scale !== 1.0) {
                        for (var i = 0, n = verts.length; i < n; i = (i + 1) | 0) {
                            verts[i] = verts[i].$clone().scale( scale );
                        }
                    }
                    collider.SetPath$1(0, verts);
                },
                /*Spine.Unity.SkeletonUtility.SetColliderPointsLocal:static end.*/

                /*Spine.Unity.SkeletonUtility.GetBoundingBoxBounds:static start.*/
                GetBoundingBoxBounds: function (boundingBox, depth) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#GetBoundingBoxBounds", this ); }

                    if (depth === void 0) { depth = 0.0; }
                    var floats = boundingBox.vertices;
                    var floatCount = floats.length;

                    var bounds = new pc.BoundingBox.ctor();

                    bounds.center = new pc.Vec3( floats[0], floats[1], 0 );
                    for (var i = 2; i < floatCount; i = (i + 2) | 0) {
                        bounds.expandToPoint( new pc.Vec3( floats[i], floats[((i + 1) | 0)], 0 ) );
                    }

                    var size = bounds.halfExtents.$clone().scale( 2 ).$clone();
                    size.z = depth;
                    bounds.halfExtents = size.$clone().$clone().scale( 0.5 );

                    return bounds;
                },
                /*Spine.Unity.SkeletonUtility.GetBoundingBoxBounds:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoneRigidbody2D:static start.*/
                AddBoneRigidbody2D: function (gameObject, isKinematic, gravityScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoneRigidbody2D", this ); }

                    if (isKinematic === void 0) { isKinematic = true; }
                    if (gravityScale === void 0) { gravityScale = 0.0; }
                    var rb = gameObject.GetComponent(UnityEngine.Rigidbody2D);
                    if (UnityEngine.Component.op_Equality(rb, null)) {
                        rb = gameObject.AddComponent(UnityEngine.Rigidbody2D);
                        rb.isKinematic = isKinematic;
                        rb.gravityScale = gravityScale;
                    }
                    return rb;
                },
                /*Spine.Unity.SkeletonUtility.AddBoneRigidbody2D:static end.*/


            }
        },
        fields: {
            boneRoot: null,
            /**
             * If true, {@link } and {@link } are followed
             by 180 degree rotation. If false, negative Transform scale is used.
             Note that using negative scale is consistent with previous behaviour (hence the default),
             however causes serious problems with rigidbodies and physics. Therefore, it is recommended to
             enable this parameter where possible. When creating hinge chains for a chain of skeleton bones
             via {@link }, it is mandatory to have <pre><code>flipBy180DegreeRotation</code></pre> enabled.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonUtility
             * @default false
             * @type boolean
             */
            flipBy180DegreeRotation: false,
            skeletonRenderer: null,
            skeletonGraphic: null,
            canvas: null,
            skeletonAnimation: null,
            skeletonComponent: null,
            boneComponents: null,
            constraintComponents: null,
            positionScale: 0,
            hasOverrideBones: false,
            hasConstraints: false,
            needToReprocessBones: false
        },
        events: {
            OnReset: null
        },
        props: {
            SkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SkeletonComponent#get", this ); }

                    if (this.skeletonComponent == null) {
                        this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonComponent) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonComponent) : this.GetComponent(Spine.Unity.ISkeletonComponent);
                    }
                    return this.skeletonComponent;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Skeleton#get", this ); }

                    if (this.SkeletonComponent == null) {
                        return null;
                    }
                    return this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#IsValid#get", this ); }

                    return (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid) || (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) && this.skeletonGraphic.IsValid);
                }
            },
            PositionScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#PositionScale#get", this ); }

                    return this.positionScale;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#init", this ); }

                this.flipBy180DegreeRotation = false;
                this.boneComponents = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonUtilityBone)).ctor();
                this.constraintComponents = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonUtilityConstraint)).ctor();
                this.positionScale = 1.0;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonUtility.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Update", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                if (skeleton != null && UnityEngine.Component.op_Inequality(this.boneRoot, null)) {

                    if (this.flipBy180DegreeRotation) {
                        this.boneRoot.localScale = new pc.Vec3( Math.abs(skeleton.scaleX), Math.abs(skeleton.scaleY), 1.0 );
                        this.boneRoot.eulerAngles = new pc.Vec3( skeleton.scaleY > 0 ? 0 : 180, skeleton.scaleX > 0 ? 0 : 180, 0 );
                    } else {
                        this.boneRoot.localScale = new pc.Vec3( skeleton.scaleX, skeleton.scaleY, 1.0 );
                    }
                }

                if (UnityEngine.Component.op_Inequality(this.canvas, null)) {
                    this.positionScale = this.canvas.referencePixelsPerUnit;
                }
            },
            /*Spine.Unity.SkeletonUtility.Update end.*/

            /*Spine.Unity.SkeletonUtility.ResubscribeEvents start.*/
            ResubscribeEvents: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#ResubscribeEvents", this ); }

                this.OnDisable();
                this.OnEnable();
            },
            /*Spine.Unity.SkeletonUtility.ResubscribeEvents end.*/

            /*Spine.Unity.SkeletonUtility.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                }
                if (this.skeletonAnimation == null) {
                    this.skeletonAnimation = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonAnimation) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonAnimation) : this.GetComponent(Spine.Unity.ISkeletonAnimation);
                }
                if (this.skeletonComponent == null) {
                    this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonComponent) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonComponent) : this.GetComponent(Spine.Unity.ISkeletonComponent);
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                    this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                } else if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                    this.skeletonGraphic.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                    this.canvas = this.skeletonGraphic.canvas;
                    if (UnityEngine.Component.op_Equality(this.canvas, null)) {
                        this.canvas = this.skeletonGraphic.GetComponentInParent(UnityEngine.Canvas);
                    }
                    if (UnityEngine.Component.op_Equality(this.canvas, null)) {
                        this.positionScale = 100.0;
                    }
                }

                if (this.skeletonAnimation != null) {
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                }

                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.OnEnable end.*/

            /*Spine.Unity.SkeletonUtility.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Start", this ); }

                //recollect because order of operations failure when switching between game mode and edit mode...
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.Start end.*/

            /*Spine.Unity.SkeletonUtility.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                }
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                }

                if (this.skeletonAnimation != null) {
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));
                }
            },
            /*Spine.Unity.SkeletonUtility.OnDisable end.*/

            /*Spine.Unity.SkeletonUtility.HandleRendererReset$1 start.*/
            HandleRendererReset$1: function (r) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#HandleRendererReset$1", this ); }

                if (!Bridge.staticEquals(this.OnReset, null)) {
                    this.OnReset();
                }
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.HandleRendererReset$1 end.*/

            /*Spine.Unity.SkeletonUtility.HandleRendererReset start.*/
            HandleRendererReset: function (g) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#HandleRendererReset", this ); }

                if (!Bridge.staticEquals(this.OnReset, null)) {
                    this.OnReset();
                }
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.HandleRendererReset end.*/

            /*Spine.Unity.SkeletonUtility.RegisterBone start.*/
            RegisterBone: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#RegisterBone", this ); }

                if (this.boneComponents.contains(bone)) {
                    return;
                } else {
                    this.boneComponents.add(bone);
                    this.needToReprocessBones = true;
                }
            },
            /*Spine.Unity.SkeletonUtility.RegisterBone end.*/

            /*Spine.Unity.SkeletonUtility.UnregisterBone start.*/
            UnregisterBone: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UnregisterBone", this ); }

                this.boneComponents.remove(bone);
            },
            /*Spine.Unity.SkeletonUtility.UnregisterBone end.*/

            /*Spine.Unity.SkeletonUtility.RegisterConstraint start.*/
            RegisterConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#RegisterConstraint", this ); }

                if (this.constraintComponents.contains(constraint)) {
                    return;
                } else {
                    this.constraintComponents.add(constraint);
                    this.needToReprocessBones = true;
                }
            },
            /*Spine.Unity.SkeletonUtility.RegisterConstraint end.*/

            /*Spine.Unity.SkeletonUtility.UnregisterConstraint start.*/
            UnregisterConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UnregisterConstraint", this ); }

                this.constraintComponents.remove(constraint);
            },
            /*Spine.Unity.SkeletonUtility.UnregisterConstraint end.*/

            /*Spine.Unity.SkeletonUtility.CollectBones start.*/
            CollectBones: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#CollectBones", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                if (skeleton == null) {
                    return;
                }

                if (UnityEngine.Component.op_Inequality(this.boneRoot, null)) {
                    var constraintTargets = new (System.Collections.Generic.List$1(System.Object)).ctor();
                    var ikConstraints = skeleton.IkConstraints;
                    for (var i = 0, n = ikConstraints.Count; i < n; i = (i + 1) | 0) {
                        constraintTargets.add(ikConstraints.Items[i].target);
                    }

                    var transformConstraints = skeleton.TransformConstraints;
                    for (var i1 = 0, n1 = transformConstraints.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                        constraintTargets.add(transformConstraints.Items[i1].target);
                    }

                    var boneComponents = this.boneComponents;
                    for (var i2 = 0, n2 = boneComponents.Count; i2 < n2; i2 = (i2 + 1) | 0) {
                        var b = boneComponents.getItem(i2);
                        if (b.bone == null) {
                            b.DoUpdate(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
                            if (b.bone == null) {
                                continue;
                            }
                        }
                        this.hasOverrideBones = !!(this.hasOverrideBones | (b.mode === Spine.Unity.SkeletonUtilityBone.Mode.Override));
                        this.hasConstraints = !!(this.hasConstraints | constraintTargets.contains(b.bone));
                    }

                    this.hasConstraints = !!(this.hasConstraints | this.constraintComponents.Count > 0);

                    if (this.skeletonAnimation != null) {
                        this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                        this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));

                        if (this.hasOverrideBones || this.hasConstraints) {
                            this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                        }

                        if (this.hasConstraints) {
                            this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));
                        }
                    }

                    this.needToReprocessBones = false;
                } else {
                    this.boneComponents.clear();
                    this.constraintComponents.clear();
                }
            },
            /*Spine.Unity.SkeletonUtility.CollectBones end.*/

            /*Spine.Unity.SkeletonUtility.UpdateLocal start.*/
            UpdateLocal: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateLocal", this ); }

                if (this.needToReprocessBones) {
                    this.CollectBones();
                }

                var boneComponents = this.boneComponents;
                if (boneComponents == null) {
                    return;
                }
                for (var i = 0, n = boneComponents.Count; i < n; i = (i + 1) | 0) {
                    boneComponents.getItem(i).transformLerpComplete = false;
                }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
            },
            /*Spine.Unity.SkeletonUtility.UpdateLocal end.*/

            /*Spine.Unity.SkeletonUtility.UpdateWorld start.*/
            UpdateWorld: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateWorld", this ); }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.World);
                for (var i = 0, n = this.constraintComponents.Count; i < n; i = (i + 1) | 0) {
                    this.constraintComponents.getItem(i).DoUpdate();
                }
            },
            /*Spine.Unity.SkeletonUtility.UpdateWorld end.*/

            /*Spine.Unity.SkeletonUtility.UpdateComplete start.*/
            UpdateComplete: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateComplete", this ); }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Complete);
            },
            /*Spine.Unity.SkeletonUtility.UpdateComplete end.*/

            /*Spine.Unity.SkeletonUtility.UpdateAllBones start.*/
            UpdateAllBones: function (phase) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateAllBones", this ); }

                if (UnityEngine.Component.op_Equality(this.boneRoot, null)) {
                    this.CollectBones();
                }

                var boneComponents = this.boneComponents;
                if (boneComponents == null) {
                    return;
                }
                for (var i = 0, n = boneComponents.Count; i < n; i = (i + 1) | 0) {
                    boneComponents.getItem(i).DoUpdate(phase);
                }
            },
            /*Spine.Unity.SkeletonUtility.UpdateAllBones end.*/

            /*Spine.Unity.SkeletonUtility.GetBoneRoot start.*/
            GetBoneRoot: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#GetBoneRoot", this ); }

                if (UnityEngine.Component.op_Inequality(this.boneRoot, null)) {
                    return this.boneRoot;
                }

                var boneRootObject = new UnityEngine.GameObject.$ctor2("SkeletonUtility-SkeletonRoot");
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    boneRootObject.AddComponent(UnityEngine.RectTransform);
                }

                this.boneRoot = boneRootObject.transform;
                this.boneRoot.SetParent(this.transform);
                this.boneRoot.localPosition = pc.Vec3.ZERO.clone();
                this.boneRoot.localRotation = pc.Quat.IDENTITY.clone();
                this.boneRoot.localScale = new pc.Vec3( 1, 1, 1 );

                return this.boneRoot;
            },
            /*Spine.Unity.SkeletonUtility.GetBoneRoot end.*/

            /*Spine.Unity.SkeletonUtility.SpawnRoot start.*/
            SpawnRoot: function (mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnRoot", this ); }

                this.GetBoneRoot();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;

                var go = this.SpawnBone(skeleton.getRootBone(), this.boneRoot, mode, pos, rot, sca);
                this.CollectBones();
                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnRoot end.*/

            /*Spine.Unity.SkeletonUtility.SpawnHierarchy start.*/
            SpawnHierarchy: function (mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnHierarchy", this ); }

                this.GetBoneRoot();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var go = this.SpawnBoneRecursively(skeleton.getRootBone(), this.boneRoot, mode, pos, rot, sca);
                this.CollectBones();
                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnHierarchy end.*/

            /*Spine.Unity.SkeletonUtility.SpawnBoneRecursively start.*/
            SpawnBoneRecursively: function (bone, parent, mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnBoneRecursively", this ); }

                var go = this.SpawnBone(bone, parent, mode, pos, rot, sca);

                var childrenBones = bone.Children;
                for (var i = 0, n = childrenBones.Count; i < n; i = (i + 1) | 0) {
                    var child = childrenBones.Items[i];
                    this.SpawnBoneRecursively(child, go.transform, mode, pos, rot, sca);
                }

                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnBoneRecursively end.*/

            /*Spine.Unity.SkeletonUtility.SpawnBone start.*/
            SpawnBone: function (bone, parent, mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnBone", this ); }

                var go = new UnityEngine.GameObject.$ctor2(bone.data.name);
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    go.AddComponent(UnityEngine.RectTransform);
                }

                var goTransform = go.transform;
                goTransform.SetParent(parent);

                var b = go.AddComponent(Spine.Unity.SkeletonUtilityBone);
                b.hierarchy = this;
                b.position = pos;
                b.rotation = rot;
                b.scale = sca;
                b.mode = mode;
                b.zPosition = true;
                b.Reset();
                b.bone = bone;
                b.boneName = bone.data.name;
                b.valid = true;

                if (mode === Spine.Unity.SkeletonUtilityBone.Mode.Override) {
                    if (rot) {
                        goTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, b.bone.arotation );
                    }
                    if (pos) {
                        goTransform.localPosition = new pc.Vec3( b.bone.x * this.positionScale, b.bone.y * this.positionScale, 0 );
                    }
                    goTransform.localScale = new pc.Vec3( b.bone.scaleX, b.bone.scaleY, 0 );
                }

                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnBone end.*/


        },
        overloads: {
            "HandleRendererReset(SkeletonRenderer)": "HandleRendererReset$1"
        }
    });
    /*Spine.Unity.SkeletonUtility end.*/

    /*Spine.Unity.SkeletonUtilityBone start.*/
    /**
     * Sets a GameObject's transform to match a bone on a Spine skeleton.
     *
     * @public
     * @class Spine.Unity.SkeletonUtilityBone
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.SkeletonUtilityBone", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible:static start.*/
                BoneTransformModeIncompatible: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#BoneTransformModeIncompatible", this ); }

                    return !Spine.SpineSkeletonExtensions.InheritsScale(bone.data.transformMode);
                },
                /*Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible:static end.*/


            }
        },
        fields: {
            /**
             * If a bone isn't set, boneName is used to find the bone.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonUtilityBone
             * @type string
             */
            boneName: null,
            parentReference: null,
            mode: 0,
            position: false,
            rotation: false,
            scale: false,
            zPosition: false,
            overrideAlpha: 0,
            hierarchy: null,
            bone: null,
            transformLerpComplete: false,
            valid: false,
            cachedTransform: null,
            skeletonTransform: null,
            incompatibleTransformMode: false
        },
        props: {
            IncompatibleTransformMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#IncompatibleTransformMode#get", this ); }

                    return this.incompatibleTransformMode;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#init", this ); }

                this.zPosition = true;
                this.overrideAlpha = 1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonUtilityBone.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#Reset", this ); }

                this.bone = null;
                this.cachedTransform = this.transform;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.hierarchy, null) && this.hierarchy.IsValid;
                if (!this.valid) {
                    return;
                }
                this.skeletonTransform = this.hierarchy.transform;
                this.hierarchy.removeOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                this.hierarchy.addOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                this.DoUpdate(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
            },
            /*Spine.Unity.SkeletonUtilityBone.Reset end.*/

            /*Spine.Unity.SkeletonUtilityBone.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.hierarchy, null)) {
                    this.hierarchy = this.transform.GetComponentInParent(Spine.Unity.SkeletonUtility);
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.hierarchy, null)) {
                    return;
                }

                this.hierarchy.RegisterBone(this);
                this.hierarchy.addOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
            },
            /*Spine.Unity.SkeletonUtilityBone.OnEnable end.*/

            /*Spine.Unity.SkeletonUtilityBone.HandleOnReset start.*/
            HandleOnReset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#HandleOnReset", this ); }

                this.Reset();
            },
            /*Spine.Unity.SkeletonUtilityBone.HandleOnReset end.*/

            /*Spine.Unity.SkeletonUtilityBone.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.hierarchy, null)) {
                    this.hierarchy.removeOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                    this.hierarchy.UnregisterBone(this);
                }
            },
            /*Spine.Unity.SkeletonUtilityBone.OnDisable end.*/

            /*Spine.Unity.SkeletonUtilityBone.DoUpdate start.*/
            DoUpdate: function (phase) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#DoUpdate", this ); }

                var $t;
                if (!this.valid) {
                    this.Reset();
                    return;
                }

                var skeleton = this.hierarchy.Skeleton;

                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = skeleton.findBone(this.boneName);
                    if (this.bone == null) {
                        UnityEngine.Debug.LogError$2("Bone not found: " + (this.boneName || ""), this);
                        return;
                    }
                }
                if (!this.bone.isActive()) {
                    return;
                }

                var positionScale = this.hierarchy.PositionScale;

                var thisTransform = this.cachedTransform;
                var skeletonFlipRotation = ($t = skeleton.scaleX * skeleton.scaleY, ($t === 0 ? 1 : Math.sign($t)));
                if (this.mode === Spine.Unity.SkeletonUtilityBone.Mode.Follow) {
                    switch (phase) {
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local: 
                            if (this.position) {
                                thisTransform.localPosition = new pc.Vec3( this.bone.x * positionScale, this.bone.y * positionScale, 0 );
                            }
                            if (this.rotation) {
                                if (Spine.SpineSkeletonExtensions.InheritsRotation(this.bone.data.transformMode)) {
                                    thisTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, this.bone.rotation );
                                } else {
                                    var euler = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                                    thisTransform.rotation = new pc.Quat().setFromEulerAngles_Unity( euler.x, euler.y, euler.z + (this.bone.getWorldRotationX() * skeletonFlipRotation) );
                                }
                            }
                            if (this.scale) {
                                thisTransform.localScale = new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 );
                                this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                            }
                            break;
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.World: 
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.Complete: 
                            if (this.position) {
                                thisTransform.localPosition = new pc.Vec3( this.bone.ax * positionScale, this.bone.ay * positionScale, 0 );
                            }
                            if (this.rotation) {
                                if (Spine.SpineSkeletonExtensions.InheritsRotation(this.bone.data.transformMode)) {
                                    thisTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, this.bone.arotation );
                                } else {
                                    var euler1 = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                                    thisTransform.rotation = new pc.Quat().setFromEulerAngles_Unity( euler1.x, euler1.y, euler1.z + (this.bone.getWorldRotationX() * skeletonFlipRotation) );
                                }
                            }
                            if (this.scale) {
                                thisTransform.localScale = new pc.Vec3( this.bone.ascaleX, this.bone.ascaleY, 1.0 );
                                this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                            }
                            break;
                    }

                } else if (this.mode === Spine.Unity.SkeletonUtilityBone.Mode.Override) {
                    if (this.transformLerpComplete) {
                        return;
                    }

                    if (UnityEngine.Component.op_Equality(this.parentReference, null)) {
                        if (this.position) {
                            var clp = thisTransform.localPosition.$clone().scale( 1.0 / ( positionScale ) );
                            this.bone.x = pc.math.lerp(this.bone.x, clp.x, this.overrideAlpha);
                            this.bone.y = pc.math.lerp(this.bone.y, clp.y, this.overrideAlpha);
                        }

                        if (this.rotation) {
                            var angle = UnityEngine.Mathf.LerpAngle(this.bone.rotation, thisTransform.localRotation.getPositiveEulerAngles().z, this.overrideAlpha);
                            this.bone.rotation = angle;
                            this.bone.arotation = angle;
                        }

                        if (this.scale) {
                            var cls = thisTransform.localScale.$clone();
                            this.bone.scaleX = pc.math.lerp(this.bone.scaleX, cls.x, this.overrideAlpha);
                            this.bone.scaleY = pc.math.lerp(this.bone.scaleY, cls.y, this.overrideAlpha);
                        }

                    } else {
                        if (this.transformLerpComplete) {
                            return;
                        }

                        if (this.position) {
                            var pos = this.parentReference.InverseTransformPoint(thisTransform.position).scale( 1.0 / ( positionScale ) );
                            this.bone.x = pc.math.lerp(this.bone.x, pos.x, this.overrideAlpha);
                            this.bone.y = pc.math.lerp(this.bone.y, pos.y, this.overrideAlpha);
                        }

                        if (this.rotation) {
                            var angle1 = UnityEngine.Mathf.LerpAngle(this.bone.rotation, new pc.Quat().lookRotation( new pc.Vec3( 0, 0, 1 ), this.parentReference.InverseTransformDirection(thisTransform.up) ).getPositiveEulerAngles().z, this.overrideAlpha);
                            this.bone.rotation = angle1;
                            this.bone.arotation = angle1;
                        }

                        if (this.scale) {
                            var cls1 = thisTransform.localScale.$clone();
                            this.bone.scaleX = pc.math.lerp(this.bone.scaleX, cls1.x, this.overrideAlpha);
                            this.bone.scaleY = pc.math.lerp(this.bone.scaleY, cls1.y, this.overrideAlpha);
                        }

                        this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                    }

                    this.transformLerpComplete = true;
                }
            },
            /*Spine.Unity.SkeletonUtilityBone.DoUpdate end.*/

            /*Spine.Unity.SkeletonUtilityBone.AddBoundingBox start.*/
            AddBoundingBox: function (skinName, slotName, attachmentName) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#AddBoundingBox", this ); }

                Spine.Unity.SkeletonUtility.AddBoneRigidbody2D(this.transform.gameObject);
                Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject(this.bone.skeleton, skinName, slotName, attachmentName, this.transform);
            },
            /*Spine.Unity.SkeletonUtilityBone.AddBoundingBox end.*/


        }
    });
    /*Spine.Unity.SkeletonUtilityBone end.*/

    /*Spine.Unity.SkeletonUtilityBone+Mode start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityBone.Mode", {
        $kind: 1006,
        statics: {
            fields: {
                Follow: 0,
                Override: 1
            }
        }
    });
    /*Spine.Unity.SkeletonUtilityBone+Mode end.*/

    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityBone.UpdatePhase", {
        $kind: 1006,
        statics: {
            fields: {
                Local: 0,
                World: 1,
                Complete: 2
            }
        }
    });
    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase end.*/

    /*Spine.Unity.SkeletonUtilityConstraint start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityConstraint", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            bone: null,
            hierarchy: null
        },
        methods: {
            /*Spine.Unity.SkeletonUtilityConstraint.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityConstraint#OnEnable", this ); }

                this.bone = this.GetComponent(Spine.Unity.SkeletonUtilityBone);
                this.hierarchy = this.transform.GetComponentInParent(Spine.Unity.SkeletonUtility);
                this.hierarchy.RegisterConstraint(this);
            },
            /*Spine.Unity.SkeletonUtilityConstraint.OnEnable end.*/

            /*Spine.Unity.SkeletonUtilityConstraint.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityConstraint#OnDisable", this ); }

                this.hierarchy.UnregisterConstraint(this);
            },
            /*Spine.Unity.SkeletonUtilityConstraint.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonUtilityConstraint end.*/

    /*Spine.Unity.SpineAttributeBase start.*/
    Bridge.define("Spine.Unity.SpineAttributeBase", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            dataField: null,
            startsWith: null,
            includeNone: false,
            fallbackToTextField: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttributeBase#init", this ); }

                this.dataField = "";
                this.startsWith = "";
                this.includeNone = true;
                this.fallbackToTextField = false;
            }
        }
    });
    /*Spine.Unity.SpineAttributeBase end.*/

    /*Spine.Unity.SpineAtlasRegion start.*/
    Bridge.define("Spine.Unity.SpineAtlasRegion", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            atlasAssetField: null
        },
        ctors: {
            ctor: function (atlasAssetField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasRegion#ctor", this ); }

                if (atlasAssetField === void 0) { atlasAssetField = ""; }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.atlasAssetField = atlasAssetField;
            }
        }
    });
    /*Spine.Unity.SpineAtlasRegion end.*/

    /*Spine.Unity.SpineAttachment+Hierarchy start.*/
    /**
     * A struct that represents 3 strings that help identify and locate an attachment in a skeleton.
     *
     * @public
     * @class Spine.Unity.SpineAttachment.Hierarchy
     */
    Bridge.define("Spine.Unity.SpineAttachment.Hierarchy", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#getDefaultValue", this ); }
 return new Spine.Unity.SpineAttachment.Hierarchy(); }
            }
        },
        fields: {
            skin: null,
            slot: null,
            name: null
        },
        ctors: {
            $ctor1: function (fullPath) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#$ctor1", this ); }

                this.$initialize();
                var chunks = System.String.split(fullPath, System.Array.init([47], System.Char).map(function (i) {{ return String.fromCharCode(i); }}), null, 1);
                if (chunks.length === 0) {
                    this.skin = "";
                    this.slot = "";
                    this.name = "";
                    return;
                } else if (chunks.length < 2) {
                    throw new System.Exception("Cannot generate Attachment Hierarchy from string! Not enough components! [" + (fullPath || "") + "]");
                }
                this.skin = chunks[0];
                this.slot = chunks[1];
                this.name = "";
                for (var i = 2; i < chunks.length; i = (i + 1) | 0) {
                    this.name = (this.name || "") + (chunks[i] || "");
                }
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#getHashCode", this ); }

                var h = Bridge.addHash([3670596642, this.skin, this.slot, this.name]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SpineAttachment.Hierarchy)) {
                    return false;
                }
                return Bridge.equals(this.skin, o.skin) && Bridge.equals(this.slot, o.slot) && Bridge.equals(this.name, o.name);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#$clone", this ); }

                var s = to || new Spine.Unity.SpineAttachment.Hierarchy();
                s.skin = this.skin;
                s.slot = this.slot;
                s.name = this.name;
                return s;
            }
        }
    });
    /*Spine.Unity.SpineAttachment+Hierarchy end.*/

    /*Spine.Unity.SpineMesh start.*/
    Bridge.define("Spine.Unity.SpineMesh", {
        statics: {
            fields: {
                MeshHideflags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineMesh#init", this ); }

                    this.MeshHideflags = 20;
                }
            },
            methods: {
                /*Spine.Unity.SpineMesh.NewSkeletonMesh:static start.*/
                /**
                 * Factory method for creating a new mesh for use in Spine components. This can be called in field initializers.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineMesh
                 * @memberof Spine.Unity.SpineMesh
                 * @return  {UnityEngine.Mesh}
                 */
                NewSkeletonMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineMesh#NewSkeletonMesh", this ); }

                    var m = new UnityEngine.Mesh.ctor();
                    m.MarkDynamic();
                    m.name = "Skeleton Mesh";
                    m.hideFlags = Spine.Unity.SpineMesh.MeshHideflags;
                    return m;
                },
                /*Spine.Unity.SpineMesh.NewSkeletonMesh:static end.*/


            }
        }
    });
    /*Spine.Unity.SpineMesh end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo start.*/
    Bridge.define("Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo", {
        $kind: 1002,
        fields: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            packingRotation: 0
        }
    });
    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo end.*/

    /*Spine.Unity.SubmeshInstruction start.*/
    /**
     * Instructions for how to generate a mesh or submesh: "Render this skeleton's slots: start slot, up to but not including endSlot, using this material."
     *
     * @public
     * @class Spine.Unity.SubmeshInstruction
     */
    Bridge.define("Spine.Unity.SubmeshInstruction", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#getDefaultValue", this ); }
 return new Spine.Unity.SubmeshInstruction(); }
            }
        },
        fields: {
            skeleton: null,
            startSlot: 0,
            endSlot: 0,
            material: null,
            forceSeparate: false,
            preActiveClippingSlotSource: 0,
            rawTriangleCount: 0,
            rawVertexCount: 0,
            rawFirstVertexIndex: 0,
            hasClipping: false,
            hasPMAAdditiveSlot: false
        },
        props: {
            /**
             * The number of slots in this SubmeshInstruction's range. Not necessarily the number of attachments.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SubmeshInstruction
             * @function SlotCount
             * @type number
             */
            SlotCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#SlotCount#get", this ); }

                    return ((this.endSlot - this.startSlot) | 0);
                }
            }
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SubmeshInstruction.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#toString", this ); }

                return System.String.format("[SubmeshInstruction: slots {0} to {1}. (Material){2}. preActiveClippingSlotSource:{3}]", Bridge.box(this.startSlot, System.Int32), Bridge.box(((this.endSlot - 1) | 0), System.Int32), this.material == null ? "<none>" : this.material.name, Bridge.box(this.preActiveClippingSlotSource, System.Int32));
            },
            /*Spine.Unity.SubmeshInstruction.toString end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#getHashCode", this ); }

                var h = Bridge.addHash([6756249098, this.skeleton, this.startSlot, this.endSlot, this.material, this.forceSeparate, this.preActiveClippingSlotSource, this.rawTriangleCount, this.rawVertexCount, this.rawFirstVertexIndex, this.hasClipping, this.hasPMAAdditiveSlot]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SubmeshInstruction)) {
                    return false;
                }
                return Bridge.equals(this.skeleton, o.skeleton) && Bridge.equals(this.startSlot, o.startSlot) && Bridge.equals(this.endSlot, o.endSlot) && Bridge.equals(this.material, o.material) && Bridge.equals(this.forceSeparate, o.forceSeparate) && Bridge.equals(this.preActiveClippingSlotSource, o.preActiveClippingSlotSource) && Bridge.equals(this.rawTriangleCount, o.rawTriangleCount) && Bridge.equals(this.rawVertexCount, o.rawVertexCount) && Bridge.equals(this.rawFirstVertexIndex, o.rawFirstVertexIndex) && Bridge.equals(this.hasClipping, o.hasClipping) && Bridge.equals(this.hasPMAAdditiveSlot, o.hasPMAAdditiveSlot);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#$clone", this ); }

                var s = to || new Spine.Unity.SubmeshInstruction();
                s.skeleton = this.skeleton;
                s.startSlot = this.startSlot;
                s.endSlot = this.endSlot;
                s.material = this.material;
                s.forceSeparate = this.forceSeparate;
                s.preActiveClippingSlotSource = this.preActiveClippingSlotSource;
                s.rawTriangleCount = this.rawTriangleCount;
                s.rawVertexCount = this.rawVertexCount;
                s.rawFirstVertexIndex = this.rawFirstVertexIndex;
                s.hasClipping = this.hasClipping;
                s.hasPMAAdditiveSlot = this.hasPMAAdditiveSlot;
                return s;
            }
        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Unity.SubmeshInstruction end.*/

    /*Spine.Unity.UpdateMode start.*/
    Bridge.define("Spine.Unity.UpdateMode", {
        $kind: 6,
        statics: {
            fields: {
                Nothing: 0,
                OnlyAnimationStatus: 1,
                OnlyEventTimelines: 4,
                EverythingExceptMesh: 2,
                FullUpdate: 3
            }
        }
    });
    /*Spine.Unity.UpdateMode end.*/

    /*Spine.Unity.WaitForSpineEvent start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState fires an event matching the given event name or EventData reference.
     *
     * @public
     * @class Spine.Unity.WaitForSpineEvent
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineEvent", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_TargetEvent: null,
            m_EventName: null,
            m_AnimationState: null,
            m_WasFired: false,
            m_unsubscribeAfterFiring: false
        },
        props: {
            /**
             * By default, WaitForSpineEvent will unsubscribe from the event immediately after it fires a correct matching event.
             If you want to reuse this WaitForSpineEvent instance on the same event, you can set this to false.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.WaitForSpineEvent
             * @function WillUnsubscribeAfterFiring
             * @type boolean
             */
            WillUnsubscribeAfterFiring: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#get", this ); }

                    return this.m_unsubscribeAfterFiring;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#set", this ); }

                    this.m_unsubscribeAfterFiring = value;
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$Current#get", this ); }

                    return null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#init", this ); }

                this.m_WasFired = false;
                this.m_unsubscribeAfterFiring = false;
            },
            ctor: function (state, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#ctor", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                this.Subscribe(state, eventDataReference, unsubscribeAfterFiring);
            },
            $ctor2: function (skeletonAnimation, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor2", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                // If skeletonAnimation is invalid, its state will be null. Subscribe handles null states just fine.
                this.Subscribe(skeletonAnimation.state, eventDataReference, unsubscribeAfterFiring);
            },
            $ctor1: function (state, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor1", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                this.SubscribeByName(state, eventName, unsubscribeAfterFiring);
            },
            $ctor3: function (skeletonAnimation, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor3", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                // If skeletonAnimation is invalid, its state will be null. Subscribe handles null states just fine.
                this.SubscribeByName(skeletonAnimation.state, eventName, unsubscribeAfterFiring);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineEvent.Subscribe start.*/
            Subscribe: function (state, eventDataReference, unsubscribe) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#Subscribe", this ); }

                if (state == null) {
                    UnityEngine.Debug.LogWarning$1("AnimationState argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                } else if (eventDataReference == null) {
                    UnityEngine.Debug.LogWarning$1("eventDataReference argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }

                this.m_AnimationState = state;
                this.m_TargetEvent = eventDataReference;
                state.addEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));

                this.m_unsubscribeAfterFiring = unsubscribe;

            },
            /*Spine.Unity.WaitForSpineEvent.Subscribe end.*/

            /*Spine.Unity.WaitForSpineEvent.SubscribeByName start.*/
            SubscribeByName: function (state, eventName, unsubscribe) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#SubscribeByName", this ); }

                if (state == null) {
                    UnityEngine.Debug.LogWarning$1("AnimationState argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                } else if (System.String.isNullOrEmpty(eventName)) {
                    UnityEngine.Debug.LogWarning$1("eventName argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }

                this.m_AnimationState = state;
                this.m_EventName = eventName;
                state.addEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));

                this.m_unsubscribeAfterFiring = unsubscribe;
            },
            /*Spine.Unity.WaitForSpineEvent.SubscribeByName end.*/

            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEventByName start.*/
            HandleAnimationStateEventByName: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#HandleAnimationStateEventByName", this ); }

                this.m_WasFired = !!(this.m_WasFired | (Bridge.referenceEquals(e.data.name, this.m_EventName))); // Check event name string match.
                if (this.m_WasFired && this.m_unsubscribeAfterFiring) {
                    this.m_AnimationState.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));
                } // Unsubscribe after correct event fires.
            },
            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEventByName end.*/

            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEvent start.*/
            HandleAnimationStateEvent: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#HandleAnimationStateEvent", this ); }

                this.m_WasFired = !!(this.m_WasFired | (Bridge.referenceEquals(e.data, this.m_TargetEvent))); // Check event data reference match.
                if (this.m_WasFired && this.m_unsubscribeAfterFiring) {
                    this.m_AnimationState.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));
                } // Usubscribe after correct event fires.
            },
            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEvent end.*/

            /*Spine.Unity.WaitForSpineEvent.NowWaitFor start.*/
            NowWaitFor: function (state, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#NowWaitFor", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }
                Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                this.Clear(state);
                this.Subscribe(state, eventDataReference, unsubscribeAfterFiring);

                return this;
            },
            /*Spine.Unity.WaitForSpineEvent.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineEvent.NowWaitFor$1 start.*/
            NowWaitFor$1: function (state, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#NowWaitFor$1", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }
                Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                this.Clear(state);
                this.SubscribeByName(state, eventName, unsubscribeAfterFiring);

                return this;
            },
            /*Spine.Unity.WaitForSpineEvent.NowWaitFor$1 end.*/

            /*Spine.Unity.WaitForSpineEvent.Clear start.*/
            Clear: function (state) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#Clear", this ); }

                state.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));
                state.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));
            },
            /*Spine.Unity.WaitForSpineEvent.Clear end.*/

            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$moveNext", this ); }

                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset(); // auto-reset for YieldInstruction reuse
                    return false;
                }

                return true;
            },
            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$reset", this ); }

                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$reset end.*/


        },
        overloads: {
            "NowWaitFor(Spine.AnimationState, string, bool)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineEvent end.*/

    /*Spine.Unity.IHasSkeletonDataAsset start.*/
    /**
     * Holds a reference to a SkeletonDataAsset.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonDataAsset
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IHasSkeletonDataAsset", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonDataAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset start.*/
    Bridge.define("Spine.Unity.BlendModeMaterialsAsset", {
        inherits: [Spine.Unity.SkeletonDataModifierAsset],
        statics: {
            methods: {
                /*Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials:static start.*/
                ApplyMaterials: function (skeletonData, multiplyTemplate, screenTemplate, additiveTemplate, includeAdditiveSlots) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#ApplyMaterials", this ); }

                    var $t, $t1;
                    if (skeletonData == null) {
                        throw new System.ArgumentNullException.$ctor1("skeletonData");
                    }

                    var materialCache = new Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache();
                    try {
                        var entryBuffer = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                        var slotsItems = skeletonData.Slots.Items;
                        for (var slotIndex = 0, slotCount = skeletonData.Slots.Count; slotIndex < slotCount; slotIndex = (slotIndex + 1) | 0) {
                            var slot = slotsItems[slotIndex];
                            if (slot.blendMode === spine.BlendMode.Normal) {
                                continue;
                            }
                            if (!includeAdditiveSlots && slot.blendMode === spine.BlendMode.Additive) {
                                continue;
                            }

                            entryBuffer.clear();
                            $t = Bridge.getEnumerator(skeletonData.Skins);
                            try {
                                while ($t.moveNext()) {
                                    var skin = $t.Current;
                                    ( entryBuffer._items.length = 0, skin.getAttachmentsForSlot( slotIndex, entryBuffer._items ), entryBuffer._size = entryBuffer._items.length );
                                }
                            } finally {
                                if (Bridge.is($t, System.IDisposable)) {
                                    $t.System$IDisposable$Dispose();
                                }
                            }

                            var templateMaterial = null;
                            switch (slot.blendMode) {
                                case spine.BlendMode.Multiply: 
                                    templateMaterial = multiplyTemplate;
                                    break;
                                case spine.BlendMode.Screen: 
                                    templateMaterial = screenTemplate;
                                    break;
                                case spine.BlendMode.Additive: 
                                    templateMaterial = additiveTemplate;
                                    break;
                            }
                            if (templateMaterial == null) {
                                continue;
                            }

                            $t1 = Bridge.getEnumerator(entryBuffer);
                            try {
                                while ($t1.moveNext()) {
                                    var entry = $t1.Current;
                                    var renderableAttachment = Bridge.as(entry.attachment, Spine.IHasRendererObject);
                                    if (renderableAttachment != null) {
                                        renderableAttachment.Spine$IHasRendererObject$RendererObject = materialCache.CloneAtlasRegionWithMaterial(Bridge.cast(renderableAttachment.Spine$IHasRendererObject$RendererObject, Spine.AtlasRegion), templateMaterial);
                                    }
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }

                    }
                    finally {
                        if (Bridge.hasValue(materialCache)) {
                            materialCache.System$IDisposable$Dispose();
                        }
                    }
                    //attachmentBuffer.Clear();
                },
                /*Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials:static end.*/


            }
        },
        fields: {
            multiplyMaterialTemplate: null,
            screenMaterialTemplate: null,
            additiveMaterialTemplate: null,
            applyAdditiveMaterial: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#init", this ); }

                this.applyAdditiveMaterial = true;
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterialsAsset.Apply start.*/
            Apply: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#Apply", this ); }

                Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials(skeletonData, this.multiplyMaterialTemplate, this.screenMaterialTemplate, this.additiveMaterialTemplate, this.applyAdditiveMaterial);
            },
            /*Spine.Unity.BlendModeMaterialsAsset.Apply end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterialsAsset end.*/

    /*Spine.Unity.IAnimationStateComponent start.*/
    /**
     * A Spine-Unity Component that uses a Spine.AnimationState to animate its skeleton.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IAnimationStateComponent
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IAnimationStateComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IAnimationStateComponent end.*/

    /*Spine.Unity.IHasSkeletonComponent start.*/
    /**
     * A Spine-Unity Component that holds a reference to an ISkeletonComponent.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonComponent
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IHasSkeletonComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonComponent end.*/

    /*Spine.Unity.IHasSkeletonRenderer start.*/
    /**
     * A Spine-Unity Component that holds a reference to a SkeletonRenderer.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonRenderer
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IHasSkeletonRenderer", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonRenderer end.*/

    /*Spine.Unity.ISkeletonAnimation start.*/
    /**
     * A Spine-Unity Component that animates a Skeleton but not necessarily with a Spine.AnimationState.
     *
     * @abstract
     * @public
     * @class Spine.Unity.ISkeletonAnimation
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.ISkeletonAnimation", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.ISkeletonAnimation end.*/

    /*Spine.Unity.ISkeletonComponent start.*/
    /**
     * A Spine-Unity Component that manages a Spine.Skeleton instance, instantiated from a SkeletonDataAsset.
     *
     * @abstract
     * @public
     * @class Spine.Unity.ISkeletonComponent
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.ISkeletonComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.ISkeletonComponent end.*/

    /*Spine.Unity.SkeletonMecanimRootMotion start.*/
    /**
     * Add this component to a SkeletonMecanim GameObject
     to turn motion of a selected root bone into Transform or RigidBody motion.
     Local bone translation movement is used as motion.
     All top-level bones of the skeleton are moved to compensate the root
     motion bone location, keeping the distance relationship between bones intact.
     *
     * @public
     * @class Spine.Unity.SkeletonMecanimRootMotion
     * @augments Spine.Unity.SkeletonRootMotionBase
     */
    Bridge.define("Spine.Unity.SkeletonMecanimRootMotion", {
        inherits: [Spine.Unity.SkeletonRootMotionBase],
        statics: {
            fields: {
                DefaultMecanimLayerFlags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#init", this ); }

                    this.DefaultMecanimLayerFlags = -1;
                }
            }
        },
        fields: {
            mecanimLayerFlags: 0,
            movementDelta: null,
            skeletonMecanim: null
        },
        props: {
            SkeletonMecanim: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#SkeletonMecanim#get", this ); }

                    return UnityEngine.Object.op_Implicit(this.skeletonMecanim) ? this.skeletonMecanim : (this.skeletonMecanim = this.GetComponent(Spine.Unity.SkeletonMecanim));
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#init", this ); }

                this.movementDelta = new UnityEngine.Vector2();
                this.mecanimLayerFlags = -1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRemainingRootMotion start.*/
            GetRemainingRootMotion: function (layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#GetRemainingRootMotion", this ); }

                var pair = this.skeletonMecanim.Translator.GetActiveAnimationAndTime(layerIndex);
                var animation = pair.key;
                var time = pair.value;
                if (animation == null) {
                    return pc.Vec2.ZERO.clone();
                }

                var start = time;
                var end = animation.duration;
                return this.GetAnimationRootMotion$1(start, end, animation);
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRemainingRootMotion end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.GetRootMotionInfo start.*/
            GetRootMotionInfo: function (layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#GetRootMotionInfo", this ); }

                var pair = this.skeletonMecanim.Translator.GetActiveAnimationAndTime(layerIndex);
                var animation = pair.key;
                var time = pair.value;
                if (animation == null) {
                    return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                }
                return this.GetAnimationRootMotionInfo(animation, time);
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRootMotionInfo end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#Reset", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Reset.call(this);
                this.mecanimLayerFlags = Spine.Unity.SkeletonMecanimRootMotion.DefaultMecanimLayerFlags;
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.Reset end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#Start", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Start.call(this);
                this.skeletonMecanim = this.GetComponent(Spine.Unity.SkeletonMecanim);
                if (UnityEngine.Object.op_Implicit(this.skeletonMecanim)) {
                    this.skeletonMecanim.Translator.removeOnClipApplied(Bridge.fn.cacheBind(this, this.OnClipApplied));
                    this.skeletonMecanim.Translator.addOnClipApplied(Bridge.fn.cacheBind(this, this.OnClipApplied));
                }
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.Start end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.OnClipApplied start.*/
            OnClipApplied: function (animation, layerIndex, weight, time, lastTime, playsBackward) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#OnClipApplied", this ); }


                if (((this.mecanimLayerFlags & 1 << layerIndex) === 0) || weight === 0) {
                    return;
                }

                if (!playsBackward) {
                    this.movementDelta = this.movementDelta.$clone().add( this.GetAnimationRootMotion$1(lastTime, time, animation).scale( weight ) );
                } else {
                    this.movementDelta = this.movementDelta.$clone().sub( this.GetAnimationRootMotion$1(time, lastTime, animation).scale( weight ) );
                }
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.OnClipApplied end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsMovementDelta start.*/
            CalculateAnimationsMovementDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsMovementDelta", this ); }

                // Note: movement delta is not gather after animation but
                // in OnClipApplied after every applied animation.
                var result = this.movementDelta.$clone();
                this.movementDelta = pc.Vec2.ZERO.clone();
                return result.$clone();
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsMovementDelta end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanimRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotion start.*/
    /**
     * Add this component to a SkeletonAnimation or SkeletonGraphic GameObject
     to turn motion of a selected root bone into Transform or RigidBody motion.
     Local bone translation movement is used as motion.
     All top-level bones of the skeleton are moved to compensate the root
     motion bone location, keeping the distance relationship between bones intact.
     *
     * @public
     * @class Spine.Unity.SkeletonRootMotion
     * @augments Spine.Unity.SkeletonRootMotionBase
     */
    Bridge.define("Spine.Unity.SkeletonRootMotion", {
        inherits: [Spine.Unity.SkeletonRootMotionBase],
        statics: {
            fields: {
                DefaultAnimationTrackFlags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#init", this ); }

                    this.DefaultAnimationTrackFlags = -1;
                }
            }
        },
        fields: {
            animationTrackFlags: 0,
            animationState: null,
            canvas: null
        },
        props: {
            AdditionalScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#AdditionalScale#get", this ); }

                    return UnityEngine.Object.op_Implicit(this.canvas) ? this.canvas.referencePixelsPerUnit : 1.0;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#init", this ); }

                this.animationTrackFlags = -1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRootMotion.GetRemainingRootMotion start.*/
            GetRemainingRootMotion: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetRemainingRootMotion", this ); }

                var track = this.animationState.getCurrent(trackIndex);
                if (track == null) {
                    return pc.Vec2.ZERO.clone();
                }

                var animation = track.animation;
                var start = track.getAnimationTime();
                var end = animation.duration;
                return this.GetAnimationRootMotion$1(start, end, animation);
            },
            /*Spine.Unity.SkeletonRootMotion.GetRemainingRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotion.GetRootMotionInfo start.*/
            GetRootMotionInfo: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetRootMotionInfo", this ); }

                var track = this.animationState.getCurrent(trackIndex);
                if (track == null) {
                    return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                }

                var animation = track.animation;
                var time = track.getAnimationTime();
                return this.GetAnimationRootMotionInfo(track.animation, time);
            },
            /*Spine.Unity.SkeletonRootMotion.GetRootMotionInfo end.*/

            /*Spine.Unity.SkeletonRootMotion.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#Reset", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Reset.call(this);
                this.animationTrackFlags = Spine.Unity.SkeletonRootMotion.DefaultAnimationTrackFlags;
            },
            /*Spine.Unity.SkeletonRootMotion.Reset end.*/

            /*Spine.Unity.SkeletonRootMotion.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#Start", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Start.call(this);
                var animstateComponent = Bridge.as(this.skeletonComponent, Spine.Unity.IAnimationStateComponent);
                this.animationState = (animstateComponent != null) ? animstateComponent.Spine$Unity$IAnimationStateComponent$AnimationState : null;

                if (UnityEngine.Component.op_Inequality(this.GetComponent(UnityEngine.CanvasRenderer), null)) {
                    this.canvas = this.GetComponentInParent(UnityEngine.Canvas);
                }
            },
            /*Spine.Unity.SkeletonRootMotion.Start end.*/

            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsMovementDelta start.*/
            CalculateAnimationsMovementDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#CalculateAnimationsMovementDelta", this ); }

                var localDelta = pc.Vec2.ZERO.clone();
                var trackCount = this.animationState.Tracks.Count;

                for (var trackIndex = 0; trackIndex < trackCount; trackIndex = (trackIndex + 1) | 0) {
                    // note: animationTrackFlags != -1 below covers trackIndex >= 32,
                    // with -1 corresponding to entry "everything" of the dropdown list.
                    if (this.animationTrackFlags !== -1 && (this.animationTrackFlags & 1 << trackIndex) === 0) {
                        continue;
                    }

                    var track = this.animationState.getCurrent(trackIndex);
                    var next = null;
                    while (track != null) {
                        var animation = track.animation;
                        var start = track.animationLast;
                        var end = track.getAnimationTime();
                        var currentDelta = { v : this.GetAnimationRootMotion$1(start, end, animation) };
                        if (!pc.Vec2.equals( currentDelta.v, pc.Vec2.ZERO.clone() )) {
                            this.ApplyMixAlphaToDelta(currentDelta, next, track);
                            localDelta = localDelta.$clone().add( currentDelta.v.$clone() );
                        }

                        // Traverse mixingFrom chain.
                        next = track;
                        track = track.mixingFrom;
                    }
                }
                return localDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta start.*/
            ApplyMixAlphaToDelta: function (currentDelta, next, track) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta", this ); }

                // Apply mix alpha to the delta position (based on AnimationState.cs).
                var mix;
                if (next != null) {
                    if (next.mixDuration === 0) { // Single frame mix to undo mixingFrom changes.
                        mix = 1;
                    } else {
                        mix = next.mixTime / next.mixDuration;
                        if (mix > 1) {
                            mix = 1;
                        }
                    }
                    var mixAndAlpha = track.alpha * next.interruptAlpha * (1 - mix);
                    currentDelta.v = currentDelta.v.$clone().scale( mixAndAlpha );
                } else {
                    if (track.mixDuration === 0) {
                        mix = 1;
                    } else {
                        mix = track.alpha * (track.mixTime / track.mixDuration);
                        if (mix > 1) {
                            mix = 1;
                        }
                    }
                    currentDelta.v = currentDelta.v.$clone().scale( mix );
                }
            },
            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta end.*/


        }
    });
    /*Spine.Unity.SkeletonRootMotion end.*/

    /*Spine.Unity.SpineAnimation start.*/
    Bridge.define("Spine.Unity.SpineAnimation", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAnimation#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineAnimation end.*/

    /*Spine.Unity.SpineAtlasAsset start.*/
    /**
     * Loads and stores a Spine atlas and list of materials.
     *
     * @public
     * @class Spine.Unity.SpineAtlasAsset
     * @augments Spine.Unity.AtlasAssetBase
     */
    Bridge.define("Spine.Unity.SpineAtlasAsset", {
        inherits: [Spine.Unity.AtlasAssetBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime AtlasAsset
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineAtlasAsset
                 * @memberof Spine.Unity.SpineAtlasAsset
                 * @param   {UnityEngine.TextAsset}           atlasText     
                 * @param   {Array.<UnityEngine.Material>}    materials     
                 * @param   {boolean}                         initialize
                 * @return  {Spine.Unity.SpineAtlasAsset}
                 */
                CreateRuntimeInstance: function (atlasText, materials, initialize) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance", this ); }

                    var atlasAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SpineAtlasAsset);
                    atlasAsset.Reset();
                    atlasAsset.atlasFile = atlasText;
                    atlasAsset.materials = materials;

                    if (initialize) {
                        atlasAsset.GetAtlas();
                    }

                    return atlasAsset;
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1:static start.*/
                /**
                 * Creates a runtime AtlasAsset. Only providing the textures is slower
                 because it has to search for atlas page matches.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineAtlasAsset
                 * @memberof Spine.Unity.SpineAtlasAsset
                 * @param   {UnityEngine.TextAsset}            atlasText                 
                 * @param   {Array.<UnityEngine.Texture2D>}    textures                  An array of all textures referenced in the provided <pre><code>atlasText</code></pre>
                 atlas asset JSON file. When procedurally creating textures, each <pre><code>Texture.name</code></pre>
                 needs to be set to the atlas page texture filename without the .png extension,
                 e.g. 'my_skeleton' if the png filename listed in the atlas asset file is 'my_skeleton.png'.
                 * @param   {UnityEngine.Material}             materialPropertySource    
                 * @param   {boolean}                          initialize
                 * @return  {Spine.Unity.SpineAtlasAsset}
                 * @see {@link Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance(TextAsset, Material[], bool)}
                 */
                CreateRuntimeInstance$1: function (atlasText, textures, materialPropertySource, initialize) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$1", this ); }

                    // Get atlas page names.
                    var atlasString = atlasText.text;
                    atlasString = System.String.replaceAll(atlasString, "\r", "");
                    var atlasLines = System.String.split(atlasString, [10].map(function (i) {{ return String.fromCharCode(i); }}));
                    var pages = new (System.Collections.Generic.List$1(System.String)).ctor();
                    for (var i = 0; i < ((atlasLines.length - 1) | 0); i = (i + 1) | 0) {
                        var line = atlasLines[i].trim();
                        if (System.String.endsWith(line, ".png")) {
                            pages.add(System.String.replaceAll(line, ".png", ""));
                        }
                    }

                    // Populate Materials[] by matching texture names with page names.
                    var materials = System.Array.init(pages.Count, null, UnityEngine.Material);
                    for (var i1 = 0, n = pages.Count; i1 < n; i1 = (i1 + 1) | 0) {
                        var mat = null;

                        // Search for a match.
                        var pageName = pages.getItem(i1);
                        for (var j = 0, m = textures.length; j < m; j = (j + 1) | 0) {
                            if (System.String.equals(pageName, textures[j].name, 5)) {
                                // Match found.
                                mat = new UnityEngine.Material.$ctor1(materialPropertySource);
                                mat.mainTexture = textures[j];
                                break;
                            }
                        }

                        if (mat != null) {
                            materials[i1] = mat;
                        } else {
                            throw new System.ArgumentException.$ctor1("Could not find matching atlas page in the texture array.");
                        }
                    }

                    // Create AtlasAsset normally
                    return Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance(atlasText, materials, initialize);
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1:static end.*/

                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$2:static start.*/
                /**
                 * Creates a runtime AtlasAsset. Only providing the textures is slower because it has to search for atlas page matches.
                 <param name="textures">An array of all textures referenced in the provided <c>atlasText</c>
                 atlas asset JSON file. When procedurally creating textures, each <c>Texture.name</c>
                 needs to be set to the atlas page texture filename without the .png extension,
                 e.g. 'my_skeleton' if the png filename listed in the atlas asset file is 'my_skeleton.png'.</param><seealso cref="Spine.Unity.AtlasAssetBase.CreateRuntimeInstance(TextAsset, Material[], bool)" />
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineAtlasAsset
                 * @memberof Spine.Unity.SpineAtlasAsset
                 * @param   {UnityEngine.TextAsset}            atlasText     
                 * @param   {Array.<UnityEngine.Texture2D>}    textures      An array of all textures referenced in the provided <pre><code>atlasText</code></pre>
                 atlas asset JSON file. When procedurally creating textures, each <pre><code>Texture.name</code></pre>
                 needs to be set to the atlas page texture filename without the .png extension,
                 e.g. 'my_skeleton' if the png filename listed in the atlas asset file is 'my_skeleton.png'.
                 * @param   {UnityEngine.Shader}               shader        
                 * @param   {boolean}                          initialize
                 * @return  {Spine.Unity.SpineAtlasAsset}
                 * @see {@link Spine.Unity.AtlasAssetBase.CreateRuntimeInstance(TextAsset, Material[], bool)}
                 */
                CreateRuntimeInstance$2: function (atlasText, textures, shader, initialize) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$2", this ); }

                    if (shader == null) {
                        shader = UnityEngine.Shader.Find("Spine/Skeleton");
                    }

                    var materialProperySource = new UnityEngine.Material.$ctor2(shader);
                    var oa = Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1(atlasText, textures, materialProperySource, initialize);

                    return oa;
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$2:static end.*/


            }
        },
        fields: {
            atlasFile: null,
            materials: null,
            atlas: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#IsLoaded#get", this ); }

                    return this.atlas != null;
                }
            },
            Materials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Materials#get", this ); }

                    return this.materials;
                }
            },
            MaterialCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#MaterialCount#get", this ); }

                    return this.materials == null ? 0 : this.materials.length;
                }
            },
            PrimaryMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#PrimaryMaterial#get", this ); }

                    return this.materials[0];
                }
            }
        },
        methods: {
            /*Spine.Unity.SpineAtlasAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SpineAtlasAsset.Reset end.*/

            /*Spine.Unity.SpineAtlasAsset.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Clear", this ); }

                this.atlas = null;
            },
            /*Spine.Unity.SpineAtlasAsset.Clear end.*/

            /*Spine.Unity.SpineAtlasAsset.GetAtlas start.*/
            /**
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SpineAtlasAsset
             * @memberof Spine.Unity.SpineAtlasAsset
             * @param   {boolean}        onlyMetaData
             * @return  {Spine.Atlas}                    The atlas or null if it could not be loaded.
             */
            GetAtlas: function (onlyMetaData) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#GetAtlas", this ); }

                if (onlyMetaData === void 0) { onlyMetaData = false; }
                if (this.atlasFile == null) {
                    UnityEngine.Debug.LogError$2("Atlas file not set for atlas asset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (!onlyMetaData && (this.materials == null || this.materials.length === 0)) {
                    UnityEngine.Debug.LogError$2("Materials not set for atlas asset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (this.atlas != null) {
                    return this.atlas;
                }

                try {
                    var loader;
                    if (!onlyMetaData) {
                        loader = new Spine.Unity.MaterialsTextureLoader(this);
                    } else {
                        loader = new Spine.Unity.NoOpTextureLoader();
                    }
                    this.atlas = new Spine.Atlas.$ctor1(new System.IO.StringReader(this.atlasFile.text), "", loader);
                    this.atlas.FlipV();
                    return this.atlas;
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    UnityEngine.Debug.LogError$2("Error reading atlas file for atlas asset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this);
                    return null;
                }
            },
            /*Spine.Unity.SpineAtlasAsset.GetAtlas end.*/

            /*Spine.Unity.SpineAtlasAsset.GenerateMesh start.*/
            GenerateMesh: function (name, mesh, material, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#GenerateMesh", this ); }

                if (scale === void 0) { scale = 0.01; }
                var region = this.atlas.findRegion(name);
                material.v = null;
                if (region != null) {
                    if (mesh == null) {
                        mesh = new UnityEngine.Mesh.ctor();
                        mesh.name = name;
                    }

                    var verts = System.Array.init(4, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    var uvs = System.Array.init(4, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    var colors = System.Array.init([
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 )
                    ], UnityEngine.Color);
                    var triangles = System.Array.init([
                        0, 
                        1, 
                        2, 
                        2, 
                        3, 
                        0
                    ], System.Int32);

                    var left, right, top, bottom;
                    left = region.width / -2.0;
                    right = left * -1.0;
                    top = region.height / 2.0;
                    bottom = top * -1;

                    verts[0] = new pc.Vec3( left, bottom, 0 ).clone().scale( scale );
                    verts[1] = new pc.Vec3( left, top, 0 ).clone().scale( scale );
                    verts[2] = new pc.Vec3( right, top, 0 ).clone().scale( scale );
                    verts[3] = new pc.Vec3( right, bottom, 0 ).clone().scale( scale );
                    var u, v, u2, v2;
                    u = region.u;
                    v = region.v;
                    u2 = region.u2;
                    v2 = region.v2;

                    if (region.degrees === 90) {
                        uvs[0] = new pc.Vec2( u2, v2 );
                        uvs[1] = new pc.Vec2( u, v2 );
                        uvs[2] = new pc.Vec2( u, v );
                        uvs[3] = new pc.Vec2( u2, v );
                    } else {
                        uvs[0] = new pc.Vec2( u, v2 );
                        uvs[1] = new pc.Vec2( u, v );
                        uvs[2] = new pc.Vec2( u2, v );
                        uvs[3] = new pc.Vec2( u2, v2 );
                    }

                    mesh.triangles = System.Array.init(0, 0, System.Int32);
                    mesh.vertices = verts;
                    mesh.uv = uvs;
                    mesh.colors = colors;
                    mesh.triangles = triangles;
                    mesh.RecalculateNormals();
                    mesh.RecalculateBounds();

                    material.v = Bridge.cast(region.page.rendererObject, UnityEngine.Material);
                } else {
                    mesh = null;
                }

                return mesh;
            },
            /*Spine.Unity.SpineAtlasAsset.GenerateMesh end.*/


        }
    });
    /*Spine.Unity.SpineAtlasAsset end.*/

    /*Spine.Unity.SpineAttachment start.*/
    Bridge.define("Spine.Unity.SpineAttachment", {
        inherits: [Spine.Unity.SpineAttributeBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineAttachment.getHierarchy:static start.*/
                getHierarchy: function (fullPath) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getHierarchy", this ); }

                    return new Spine.Unity.SpineAttachment.Hierarchy.$ctor1(fullPath);
                },
                /*Spine.Unity.SpineAttachment.getHierarchy:static end.*/

                /*Spine.Unity.SpineAttachment.getAttachment:static start.*/
                getAttachment: function (attachmentPath, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getAttachment", this ); }

                    var hierarchy = Spine.Unity.SpineAttachment.getHierarchy(attachmentPath);
                    if (System.String.isNullOrEmpty(hierarchy.name)) {
                        return null;
                    }

                    var slot = skeletonData.findSlot(hierarchy.slot);
                    if (slot == null) {
                        return null;
                    }
                    return skeletonData.findSkin(hierarchy.skin).getAttachment(slot.index, hierarchy.name);
                },
                /*Spine.Unity.SpineAttachment.getAttachment:static end.*/

                /*Spine.Unity.SpineAttachment.getAttachment$1:static start.*/
                getAttachment$1: function (attachmentPath, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getAttachment$1", this ); }

                    return Spine.Unity.SpineAttachment.getAttachment(attachmentPath, skeletonDataAsset.GetSkeletonData(true));
                },
                /*Spine.Unity.SpineAttachment.getAttachment$1:static end.*/


            }
        },
        fields: {
            returnAttachmentPath: false,
            currentSkinOnly: false,
            placeholdersOnly: false,
            skinField: null,
            slotField: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#init", this ); }

                this.returnAttachmentPath = false;
                this.currentSkinOnly = false;
                this.placeholdersOnly = false;
                this.skinField = "";
                this.slotField = "";
            },
            
            ctor: function (currentSkinOnly, returnAttachmentPath, placeholdersOnly, slotField, dataField, skinField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#ctor", this ); }

                if (currentSkinOnly === void 0) { currentSkinOnly = true; }
                if (returnAttachmentPath === void 0) { returnAttachmentPath = false; }
                if (placeholdersOnly === void 0) { placeholdersOnly = false; }
                if (slotField === void 0) { slotField = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (skinField === void 0) { skinField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.currentSkinOnly = currentSkinOnly;
                this.returnAttachmentPath = returnAttachmentPath;
                this.placeholdersOnly = placeholdersOnly;
                this.slotField = slotField;
                this.dataField = dataField;
                this.skinField = skinField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineAttachment end.*/

    /*Spine.Unity.SpineBone start.*/
    Bridge.define("Spine.Unity.SpineBone", {
        inherits: [Spine.Unity.SpineAttributeBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineBone.getBone:static start.*/
                getBone: function (boneName, renderer) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#getBone", this ); }

                    return renderer.skeleton == null ? null : renderer.skeleton.findBone(boneName);
                },
                /*Spine.Unity.SpineBone.getBone:static end.*/

                /*Spine.Unity.SpineBone.getBoneData:static start.*/
                getBoneData: function (boneName, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#getBoneData", this ); }

                    var data = skeletonDataAsset.GetSkeletonData(true);
                    return data.findBone(boneName);
                },
                /*Spine.Unity.SpineBone.getBoneData:static end.*/


            }
        },
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineBone end.*/

    /*Spine.Unity.SpineEvent start.*/
    Bridge.define("Spine.Unity.SpineEvent", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            /**
             * Smart popup menu for Spine Events (Spine.EventData)
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SpineEvent
             * @default false
             * @type boolean
             */
            audioOnly: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineEvent#init", this ); }

                this.audioOnly = false;
            },
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField, audioOnly) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineEvent#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }
                if (audioOnly === void 0) { audioOnly = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
                this.audioOnly = audioOnly;
            }
        }
    });
    /*Spine.Unity.SpineEvent end.*/

    /*Spine.Unity.SpineIkConstraint start.*/
    Bridge.define("Spine.Unity.SpineIkConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            /**
             * Smart popup menu for Spine IK Constraints (Spine.IkConstraint)
             *
             * @instance
             * @public
             * @this Spine.Unity.SpineIkConstraint
             * @memberof Spine.Unity.SpineIkConstraint
             * @param   {string}     startsWith             Filters popup results to elements that begin with supplied string.
             * @param   {string}     dataField              If specified, a locally scoped field with the name supplied by in dataField will be used to fill the popup results.
             Valid types are SkeletonDataAsset and SkeletonRenderer (and derivatives).
             If left empty and the script the attribute is applied to is derived from Component, GetComponent(SkeletonRenderer)() will be called as a fallback.
             * @param   {boolean}    includeNone            If true, the dropdown list will include a "none" option which stored as an empty string.
             * @param   {boolean}    fallbackToTextField    If true, and an animation list source can't be found, the field will fall back to a normal text field. If false, it will show an error.
             * @return  {void}
             */
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineIkConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineIkConstraint end.*/

    /*Spine.Unity.SpinePathConstraint start.*/
    Bridge.define("Spine.Unity.SpinePathConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            /**
             * Smart popup menu for Spine Events (Spine.PathConstraint)
             *
             * @instance
             * @public
             * @this Spine.Unity.SpinePathConstraint
             * @memberof Spine.Unity.SpinePathConstraint
             * @param   {string}     startsWith             Filters popup results to elements that begin with supplied string.
             * @param   {string}     dataField              If specified, a locally scoped field with the name supplied by in dataField will be used to fill the popup results.
             Valid types are SkeletonDataAsset and SkeletonRenderer (and derivatives).
             If left empty and the script the attribute is applied to is derived from Component, GetComponent(SkeletonRenderer)() will be called as a fallback.
             * @param   {boolean}    includeNone            If true, the dropdown list will include a "none" option which stored as an empty string.
             * @param   {boolean}    fallbackToTextField
             * @return  {void}
             */
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpinePathConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpinePathConstraint end.*/

    /*Spine.Unity.SpineSkin start.*/
    Bridge.define("Spine.Unity.SpineSkin", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            
            defaultAsEmptyString: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSkin#init", this ); }

                this.defaultAsEmptyString = false;
            },
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField, defaultAsEmptyString) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSkin#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }
                if (defaultAsEmptyString === void 0) { defaultAsEmptyString = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
                this.defaultAsEmptyString = defaultAsEmptyString;
            }
        }
    });
    /*Spine.Unity.SpineSkin end.*/

    /*Spine.Unity.SpineSlot start.*/
    Bridge.define("Spine.Unity.SpineSlot", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            containsBoundingBoxes: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSlot#init", this ); }

                this.containsBoundingBoxes = false;
            },
            
            ctor: function (startsWith, dataField, containsBoundingBoxes, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSlot#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (containsBoundingBoxes === void 0) { containsBoundingBoxes = false; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.containsBoundingBoxes = containsBoundingBoxes;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineSlot end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset start.*/
    /**
     * Loads and stores a Spine atlas and list of materials.
     *
     * @public
     * @class Spine.Unity.SpineSpriteAtlasAsset
     * @augments Spine.Unity.AtlasAssetBase
     */
    Bridge.define("Spine.Unity.SpineSpriteAtlasAsset", {
        inherits: [Spine.Unity.AtlasAssetBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineSpriteAtlasAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime AtlasAsset
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineSpriteAtlasAsset
                 * @memberof Spine.Unity.SpineSpriteAtlasAsset
                 * @param   {UnityEngine.U2D.SpriteAtlas}          spriteAtlasFile    
                 * @param   {Array.<UnityEngine.Material>}         materials          
                 * @param   {boolean}                              initialize
                 * @return  {Spine.Unity.SpineSpriteAtlasAsset}
                 */
                CreateRuntimeInstance: function (spriteAtlasFile, materials, initialize) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#CreateRuntimeInstance", this ); }

                    var atlasAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SpineSpriteAtlasAsset);
                    atlasAsset.Reset();
                    atlasAsset.spriteAtlasFile = spriteAtlasFile;
                    atlasAsset.materials = materials;

                    if (initialize) {
                        atlasAsset.GetAtlas();
                    }

                    return atlasAsset;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture:static start.*/
                AccessPackedTexture: function (sprites) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#AccessPackedTexture", this ); }

                    return sprites[0].texture;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture:static end.*/

                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites:static start.*/
                AccessPackedSprites: function (spriteAtlas) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#AccessPackedSprites", this ); }

                    var sprites = null;
                    if (sprites == null) {
                        sprites = System.Array.init(spriteAtlas.spriteCount, null, UnityEngine.Sprite);
                        spriteAtlas.GetSprites(sprites);
                        if (sprites.length === 0) {
                            return null;
                        }
                    }
                    return sprites;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites:static end.*/


            }
        },
        fields: {
            spriteAtlasFile: null,
            materials: null,
            atlas: null,
            updateRegionsInPlayMode: false,
            savedRegions: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#IsLoaded#get", this ); }

                    return this.atlas != null;
                }
            },
            Materials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#Materials#get", this ); }

                    return this.materials;
                }
            },
            MaterialCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#MaterialCount#get", this ); }

                    return this.materials == null ? 0 : this.materials.length;
                }
            },
            PrimaryMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#PrimaryMaterial#get", this ); }

                    return this.materials[0];
                }
            }
        },
        methods: {
            /*Spine.Unity.SpineSpriteAtlasAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.Reset end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#Clear", this ); }

                this.atlas = null;
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.Clear end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.GetAtlas start.*/
            /**
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SpineSpriteAtlasAsset
             * @memberof Spine.Unity.SpineSpriteAtlasAsset
             * @param   {boolean}        onlyMetaData
             * @return  {Spine.Atlas}                    The atlas or null if it could not be loaded.
             */
            GetAtlas: function (onlyMetaData) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#GetAtlas", this ); }

                if (onlyMetaData === void 0) { onlyMetaData = false; }
                if (this.spriteAtlasFile == null) {
                    UnityEngine.Debug.LogError$2("SpriteAtlas file not set for SpineSpriteAtlasAsset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (!onlyMetaData && (this.materials == null || this.materials.length === 0)) {
                    UnityEngine.Debug.LogError$2("Materials not set for SpineSpriteAtlasAsset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (this.atlas != null) {
                    return this.atlas;
                }

                try {
                    this.atlas = this.LoadAtlas(this.spriteAtlasFile);
                    return this.atlas;
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    UnityEngine.Debug.LogError$2("Error analyzing SpriteAtlas for SpineSpriteAtlasAsset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this);
                    return null;
                }
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.GetAtlas end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.AssignRegionsFromSavedRegions start.*/
            AssignRegionsFromSavedRegions: function (sprites, usedAtlas) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#AssignRegionsFromSavedRegions", this ); }

                var $t;

                if (this.savedRegions == null || this.savedRegions.length !== sprites.length) {
                    return;
                }

                var i = 0;
                $t = Bridge.getEnumerator(usedAtlas);
                try {
                    while ($t.moveNext()) {
                        var region = $t.Current;
                        var savedRegion = this.savedRegions[i];
                        var page = region.page;

                        region.degrees = savedRegion.packingRotation === UnityEngine.SpritePackingRotation.None ? 0 : 90;

                        var x = savedRegion.x;
                        var y = savedRegion.y;
                        var width = savedRegion.width;
                        var height = savedRegion.height;

                        region.u = x / page.width;
                        region.v = y / page.height;
                        if (region.degrees === 90) {
                            region.u2 = (x + height) / page.width;
                            region.v2 = (y + width) / page.height;
                        } else {
                            region.u2 = (x + width) / page.width;
                            region.v2 = (y + height) / page.height;
                        }
                        region.x = Bridge.Int.clip32(x);
                        region.y = Bridge.Int.clip32(y);
                        region.width = Math.abs(Bridge.Int.clip32(width));
                        region.height = Math.abs(Bridge.Int.clip32(height));

                        // flip upside down
                        var temp = region.v;
                        region.v = region.v2;
                        region.v2 = temp;

                        region.originalWidth = Bridge.Int.clip32(width);
                        region.originalHeight = Bridge.Int.clip32(height);

                        // note: currently sprite pivot offsets are ignored.
                        // var sprite = sprites[i];
                        region.offsetX = 0; //sprite.pivot.x;
                        region.offsetY = 0; //sprite.pivot.y;

                        i = (i + 1) | 0;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.AssignRegionsFromSavedRegions end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.LoadAtlas start.*/
            LoadAtlas: function (spriteAtlas) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#LoadAtlas", this ); }


                var pages = new (System.Collections.Generic.List$1(Spine.AtlasPage)).ctor();
                var regions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();

                var sprites = System.Array.init(spriteAtlas.spriteCount, null, UnityEngine.Sprite);
                spriteAtlas.GetSprites(sprites);
                if (sprites.length === 0) {
                    return new Spine.Atlas.ctor(pages, regions);
                }

                var texture = null;
                texture = Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture(sprites);

                var material = this.materials[0];
                material.mainTexture = texture;

                var page = new Spine.AtlasPage();
                page.name = spriteAtlas.name;
                page.width = texture.width;
                page.height = texture.height;
                page.format = Spine.Format.RGBA8888;

                page.minFilter = spine.TextureFilter.Linear;
                page.magFilter = spine.TextureFilter.Linear;
                page.uWrap = spine.TextureWrap.ClampToEdge;
                page.vWrap = spine.TextureWrap.ClampToEdge;
                page.rendererObject = material;
                pages.add(page);

                sprites = Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites(spriteAtlas);

                var i = 0;
                for (; i < sprites.length; i = (i + 1) | 0) {
                    var sprite = sprites[i];
                    var region = new Spine.AtlasRegion();
                    region.name = System.String.replaceAll(sprite.name, "(Clone)", "");
                    region.page = page;
                    region.degrees = sprite.packingRotation === UnityEngine.SpritePackingRotation.None ? 0 : 90;

                    region.u2 = 1;
                    region.v2 = 1;
                    region.width = page.width;
                    region.height = page.height;
                    region.originalWidth = page.width;
                    region.originalHeight = page.height;

                    region.index = i;
                    regions.add(region);
                }

                var atlas = new Spine.Atlas.ctor(pages, regions);
                this.AssignRegionsFromSavedRegions(sprites, atlas);

                return atlas;
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.LoadAtlas end.*/


        }
    });
    /*Spine.Unity.SpineSpriteAtlasAsset end.*/

    /*Spine.Unity.SpineTransformConstraint start.*/
    Bridge.define("Spine.Unity.SpineTransformConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineTransformConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineTransformConstraint end.*/

    /*Spine.Unity.AnimationReferenceAsset start.*/
    Bridge.define("Spine.Unity.AnimationReferenceAsset", {
        inherits: [UnityEngine.ScriptableObject,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                QuietSkeletonData: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#init", this ); }

                    this.QuietSkeletonData = true;
                }
            },
            methods: {
                op_Implicit: function (asset) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#op_Implicit", this ); }

                    return asset.Animation;
                }
            }
        },
        fields: {
            skeletonDataAsset: null,
            animationName: null,
            animation: null
        },
        props: {
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            },
            Animation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Animation#get", this ); }

                    if (this.animation == null) {
                        this.Initialize();
                    }
                    return this.animation;
                }
            }
        },
        alias: ["SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"],
        methods: {
            /*Spine.Unity.AnimationReferenceAsset.Clear start.*/
            /**
             * Clears the cached animation corresponding to a loaded SkeletonData object.
             Use this to force a reload for the next time Animation is called.
             *
             * @instance
             * @public
             * @this Spine.Unity.AnimationReferenceAsset
             * @memberof Spine.Unity.AnimationReferenceAsset
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Clear", this ); }

                this.animation = null;
            },
            /*Spine.Unity.AnimationReferenceAsset.Clear end.*/

            /*Spine.Unity.AnimationReferenceAsset.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Initialize", this ); }

                if (this.skeletonDataAsset == null) {
                    return;
                }
                var skeletonData = this.skeletonDataAsset.GetSkeletonData(Spine.Unity.AnimationReferenceAsset.QuietSkeletonData);
                this.animation = skeletonData != null ? skeletonData.findAnimation(this.animationName) : null;
                if (this.animation == null) {
                    UnityEngine.Debug.LogWarningFormat("Animation '{0}' not found in SkeletonData : {1}.", [this.animationName, this.skeletonDataAsset.name]);
                }
            },
            /*Spine.Unity.AnimationReferenceAsset.Initialize end.*/


        }
    });
    /*Spine.Unity.AnimationReferenceAsset end.*/

    /*Spine.Unity.PointFollower start.*/
    Bridge.define("Spine.Unity.PointFollower", {
        inherits: [UnityEngine.MonoBehaviour,Spine.Unity.IHasSkeletonRenderer,Spine.Unity.IHasSkeletonComponent],
        fields: {
            skeletonRenderer: null,
            slotName: null,
            pointAttachmentName: null,
            followRotation: false,
            followSkeletonFlip: false,
            followSkeletonZPosition: false,
            skeletonTransform: null,
            skeletonTransformIsParent: false,
            point: null,
            bone: null,
            valid: false
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                }
            },
            SkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#SkeletonComponent#get", this ); }

                    return Bridge.as(this.skeletonRenderer, Spine.Unity.ISkeletonComponent);
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#IsValid#get", this ); }

                    return this.valid;
                }
            }
        },
        alias: [
            "SkeletonRenderer", "Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer",
            "SkeletonComponent", "Spine$Unity$IHasSkeletonComponent$SkeletonComponent"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#init", this ); }

                this.followRotation = true;
                this.followSkeletonFlip = true;
                this.followSkeletonZPosition = false;
            }
        },
        methods: {
            /*Spine.Unity.PointFollower.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#Initialize", this ); }

                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid;
                if (!this.valid) {
                    return;
                }

                this.UpdateReferences();

            },
            /*Spine.Unity.PointFollower.Initialize end.*/

            /*Spine.Unity.PointFollower.HandleRebuildRenderer start.*/
            HandleRebuildRenderer: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#HandleRebuildRenderer", this ); }

                this.Initialize();
            },
            /*Spine.Unity.PointFollower.HandleRebuildRenderer end.*/

            /*Spine.Unity.PointFollower.UpdateReferences start.*/
            UpdateReferences: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#UpdateReferences", this ); }

                this.skeletonTransform = this.skeletonRenderer.transform;
                this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                this.bone = null;
                this.point = null;
                if (!System.String.isNullOrEmpty(this.pointAttachmentName)) {
                    var skeleton = this.skeletonRenderer.Skeleton;

                    var slot = skeleton.findSlot(this.slotName);
                    if (slot != null) {
                        var slotIndex = slot.data.index;
                        this.bone = slot.bone;
                        this.point = Bridge.as(skeleton.getAttachment(slotIndex, this.pointAttachmentName), Spine.PointAttachment);
                    }
                }
            },
            /*Spine.Unity.PointFollower.UpdateReferences end.*/

            /*Spine.Unity.PointFollower.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#OnDestroy", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                }
            },
            /*Spine.Unity.PointFollower.OnDestroy end.*/

            /*Spine.Unity.PointFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#LateUpdate", this ); }

                var $t;

                if (this.point == null) {
                    if (System.String.isNullOrEmpty(this.pointAttachmentName)) {
                        return;
                    }
                    this.UpdateReferences();
                    if (this.point == null) {
                        return;
                    }
                }

                var worldPos = new UnityEngine.Vector2();
                this.point.ComputeWorldPosition(this.bone, Bridge.ref(worldPos, "x"), Bridge.ref(worldPos, "y"));
                var rotation = this.point.computeWorldRotation(this.bone);

                var thisTransform = this.transform;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( worldPos.x, worldPos.y, this.followSkeletonZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followRotation) {
                        var halfRotation = rotation * 0.5 * UnityEngine.Mathf.Deg2Rad;

                        var q = Bridge.getDefaultValue(UnityEngine.Quaternion);
                        q.z = Math.sin(halfRotation);
                        q.w = Math.cos(halfRotation);
                        thisTransform.localRotation = q.$clone();
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( worldPos.x, worldPos.y, 0.0 ));
                    if (!this.followSkeletonZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }

                    var transformParent = thisTransform.parent;
                    if (UnityEngine.Component.op_Inequality(transformParent, null)) {
                        var m = transformParent.localToWorldMatrix.$clone();
                        if (m.e00 * m.e11 - m.e01 * m.e10 < 0) {
                            rotation = -rotation;
                        }
                    }

                    if (this.followRotation) {
                        var transformWorldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        thisTransform.SetPositionAndRotation(targetWorldPosition, new pc.Quat().setFromEulerAngles_Unity( transformWorldRotation.x, transformWorldRotation.y, transformWorldRotation.z + rotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }
                }

                if (this.followSkeletonFlip) {
                    var localScale = thisTransform.localScale.$clone();
                    localScale.y = Math.abs(localScale.y) * ($t = this.bone.skeleton.scaleX * this.bone.skeleton.scaleY, ($t === 0 ? 1 : Math.sign($t)));
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.PointFollower.LateUpdate end.*/


        }
    });
    /*Spine.Unity.PointFollower end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRenderer.InstructionDelegate
     * @param   {Spine.Unity.SkeletonRendererInstruction}    instruction
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.MeshGeneratorDelegate
     * @param   {Spine.Unity.MeshGeneratorBuffers}    buffers
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRenderer start.*/
    /**
     * Base class of animated Spine skeleton components. This component manages and renders a skeleton.
     *
     * @public
     * @class Spine.Unity.SkeletonRenderer
     * @augments UnityEngine.MonoBehaviour
     * @implements  Spine.Unity.ISkeletonComponent
     * @implements  Spine.Unity.IHasSkeletonDataAsset
     */
    Bridge.define("Spine.Unity.SkeletonRenderer", {
        inherits: [UnityEngine.MonoBehaviour,Spine.Unity.ISkeletonComponent,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 8
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_NONE: 0,
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 4
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE: 0,
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 5
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE: 0,
                /**
                 * Shader property ID used for the Stencil comparison function.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @type number
                 */
                STENCIL_COMP_PARAM_ID: 0,
                SUBMESH_DUMMY_PARAM_ID: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#init", this ); }

                    this.STENCIL_COMP_MASKINTERACTION_NONE = UnityEngine.Rendering.CompareFunction.Always;
                    this.STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE = UnityEngine.Rendering.CompareFunction.LessEqual;
                    this.STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE = UnityEngine.Rendering.CompareFunction.Greater;
                    this.STENCIL_COMP_PARAM_ID = UnityEngine.Shader.PropertyToID("_StencilComp");
                    this.SUBMESH_DUMMY_PARAM_ID = UnityEngine.Shader.PropertyToID("_Submesh");
                }
            },
            methods: {
                /*Spine.Unity.SkeletonRenderer.NewSpineGameObject:static start.*/
                NewSpineGameObject: function (T, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#NewSpineGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.AddSpineComponent(T, new UnityEngine.GameObject.$ctor2("New Spine GameObject"), skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonRenderer.NewSpineGameObject:static end.*/

                /*Spine.Unity.SkeletonRenderer.AddSpineComponent:static start.*/
                /**
                 * Add and prepare a Spine component that derives from SkeletonRenderer to a GameObject at runtime.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonRenderer
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @param   {Function}                         T                    T should be SkeletonRenderer or any of its derived classes.
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {T}
                 */
                AddSpineComponent: function (T, gameObject, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#AddSpineComponent", this ); }

                    if (quiet === void 0) { quiet = false; }
                    var c = Bridge.rValue(gameObject.AddComponent(T));
                    if (skeletonDataAsset != null) {
Bridge.rValue(                        c).skeletonDataAsset = skeletonDataAsset;
Bridge.rValue(                        c).Initialize(false, quiet);
                    }
                    return Bridge.rValue(c);
                },
                /*Spine.Unity.SkeletonRenderer.AddSpineComponent:static end.*/


            }
        },
        fields: {
            skeletonDataAsset: null,
            /**
             * Skin name to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type string
             */
            initialSkinName: null,
            /**
             * Enable this parameter when overwriting the Skeleton's skin from an editor script.
             Otherwise any changes will be overwritten by the next inspector update.
             * Flip X and Y to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type boolean
             */
            initialFlipX: false,
            /**
             * Enable this parameter when overwriting the Skeleton's skin from an editor script.
             Otherwise any changes will be overwritten by the next inspector update.
             * Flip X and Y to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type boolean
             */
            initialFlipY: false,
            updateMode: 0,
            /**
             * Update mode used when the MeshRenderer becomes invisible
             (when <pre><code>OnBecameInvisible()</code></pre> is called). Update mode is automatically
             reset to <pre><code>UpdateMode.FullUpdate</code></pre> when the mesh becomes visible again.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Spine.Unity.UpdateMode
             */
            updateWhenInvisible: 0,
            /**
             * Slot names used to populate separatorSlots list when the Skeleton is initialized. Changing this after initialization does nothing.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Array.<string>
             */
            separatorSlotNames: null,
            /**
             * Slots that determine where the render is split. This is used by components such as SkeletonRenderSeparator so that the skeleton can be rendered by two separate renderers on different GameObjects.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @type System.Collections.Generic.List$1
             */
            separatorSlots: null,
            zSpacing: 0,
            /**
             * Use Spine's clipping feature. If false, ClippingAttachments will be ignored.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default true
             * @type boolean
             */
            useClipping: false,
            /**
             * If true, triangles will not be updated. Enable this as an optimization if the skeleton does not make use of attachment swapping or hiding, or draw order keys. Otherwise, setting this to false may cause errors in rendering.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            immutableTriangles: false,
            /**
             * Multiply vertex color RGB with vertex color alpha. Set this to true if the shader used for rendering is a premultiplied alpha shader. Setting this to false disables single-batch additive slots.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default true
             * @type boolean
             */
            pmaVertexColors: false,
            /**
             * Clears the state of the render and skeleton when this component or its GameObject is disabled. This prevents previous state from being retained when it is enabled again. When pooling your skeleton, setting this to true can be helpful.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            clearStateOnDisable: false,
            /**
             * If true, second colors on slots will be added to the output Mesh as UV2 and UV3. A special "tint black" shader that interprets UV2 and UV3 as black point colors is required to render this properly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            tintBlack: false,
            /**
             * If true, the renderer assumes the skeleton only requires one Material and one submesh to render. This allows the MeshGenerator to skip checking for changes in Materials. Enable this as an optimization if the skeleton only uses one Material.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            singleSubmesh: false,
            /**
             * Applies only when 3+ submeshes are used (2+ materials with alternating order, e.g. "A B A").
             If true, GPU instancing is disabled at all materials and MaterialPropertyBlocks are assigned at each
             material to prevent aggressive batching of submeshes by e.g. the LWRP renderer, leading to incorrect
             draw order (e.g. "A1 B A2" changed to "A1A2 B").
             You can disable this parameter when everything is drawn correctly to save the additional performance cost.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            fixDrawOrder: false,
            /**
             * If true, the mesh generator adds normals to the output mesh. For better performance and reduced memory requirements, use a shader that assumes the desired normal.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            addNormals: false,
            /**
             * If true, tangents are calculated every frame and added to the Mesh. Enable this when using a shader that uses lighting that requires tangents.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            calculateTangents: false,
            /**
             * This enum controls the mode under which the sprite will interact with the masking system.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type UnityEngine.SpriteMaskInteraction
             */
            maskInteraction: 0,
            /**
             * Material references for switching material sets at runtime when {@link } changes.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             */
            maskMaterials: null,
            disableRenderingOnOverride: false,
            customMaterialOverride: null,
            customSlotMaterials: null,
            currentInstructions: null,
            meshGenerator: null,
            rendererBuffers: null,
            meshRenderer: null,
            meshFilter: null,
            valid: false,
            skeleton: null,
            reusedPropertyBlock: null
        },
        events: {
            generateMeshOverride: null,
            /**
             * Occurs after the vertex data is populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            /**
             * Occurs after the vertex data is populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            OnPostProcessVertices: null,
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnRebuild
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnRebuild
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnRebuild: null,
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            /**
             * Update mode to optionally limit updates to e.g. only apply animations but not update the mesh.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @function UpdateMode
             * @type Spine.Unity.UpdateMode
             */
            UpdateMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#UpdateMode#get", this ); }

                    return this.updateMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#UpdateMode#set", this ); }

                    this.updateMode = value;
                }
            },
            /**
             * Use this Dictionary to override a Material with a different Material.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @function CustomMaterialOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomMaterialOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#CustomMaterialOverride#get", this ); }

                    return this.customMaterialOverride;
                }
            },
            /**
             * Use this Dictionary to use a different Material to render specific Slots.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @function CustomSlotMaterials
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomSlotMaterials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#CustomSlotMaterials#get", this ); }

                    return this.customSlotMaterials;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Skeleton#get", this ); }

                    this.Initialize(false);
                    return this.skeleton;
                }
            },
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            }
        },
        alias: [
            "Skeleton", "Spine$Unity$ISkeletonComponent$Skeleton",
            "SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset",
            "SkeletonDataAsset", "Spine$Unity$ISkeletonComponent$SkeletonDataAsset"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#init", this ); }

                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.updateWhenInvisible = Spine.Unity.UpdateMode.FullUpdate;
                this.separatorSlotNames = System.Array.init(0, null, System.String);
                this.separatorSlots = new (System.Collections.Generic.List$1(Spine.Slot)).ctor();
                this.useClipping = true;
                this.immutableTriangles = false;
                this.pmaVertexColors = true;
                this.clearStateOnDisable = false;
                this.tintBlack = false;
                this.singleSubmesh = false;
                this.fixDrawOrder = false;
                this.addNormals = false;
                this.calculateTangents = false;
                this.maskInteraction = UnityEngine.SpriteMaskInteraction.None;
                this.maskMaterials = new Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials();
                this.disableRenderingOnOverride = true;
                this.customMaterialOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Material,UnityEngine.Material)).ctor();
                this.customSlotMaterials = new (System.Collections.Generic.Dictionary$2(Spine.Slot,UnityEngine.Material)).ctor();
                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
                this.meshGenerator = new Spine.Unity.MeshGenerator();
                this.rendererBuffers = new Spine.Unity.MeshRendererBuffers();
            }
        },
        methods: {
            /**
             * Allows separate code to take over rendering for this SkeletonRenderer component. The subscriber is passed a SkeletonRendererInstruction argument to determine how to render a skeleton.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @event Spine.Unity.SkeletonRenderer#GenerateMeshOverride
             * @return  {Spine.Unity.SkeletonRenderer.InstructionDelegate}
             */
            addGenerateMeshOverride: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#addGenerateMeshOverride", this ); }

                this.addgenerateMeshOverride(value);
                if (this.disableRenderingOnOverride && !Bridge.staticEquals(this.generateMeshOverride, null)) {
                    this.Initialize(false);
                    if (UnityEngine.Object.op_Implicit(this.meshRenderer)) {
                        this.meshRenderer.enabled = false;
                    }
                }
            },
            /**
             * Allows separate code to take over rendering for this SkeletonRenderer component. The subscriber is passed a SkeletonRendererInstruction argument to determine how to render a skeleton.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @event Spine.Unity.SkeletonRenderer#GenerateMeshOverride
             * @return  {Spine.Unity.SkeletonRenderer.InstructionDelegate}
             */
            removeGenerateMeshOverride: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#removeGenerateMeshOverride", this ); }

                this.removegenerateMeshOverride(value);
                if (this.disableRenderingOnOverride && Bridge.staticEquals(this.generateMeshOverride, null)) {
                    this.Initialize(false);
                    if (UnityEngine.Object.op_Implicit(this.meshRenderer)) {
                        this.meshRenderer.enabled = true;
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.SetMeshSettings start.*/
            /**
             * Applies MeshGenerator settings to the SkeletonRenderer and its internal MeshGenerator.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {Spine.Unity.MeshGenerator.Settings}    settings
             * @return  {void}
             */
            SetMeshSettings: function (settings) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SetMeshSettings", this ); }

                this.calculateTangents = settings.calculateTangents;
                this.immutableTriangles = settings.immutableTriangles;
                this.pmaVertexColors = settings.pmaVertexColors;
                this.tintBlack = settings.tintBlack;
                this.useClipping = settings.useClipping;
                this.zSpacing = settings.zSpacing;

                this.meshGenerator.settings = settings.$clone();
            },
            /*Spine.Unity.SkeletonRenderer.SetMeshSettings end.*/

            /*Spine.Unity.SkeletonRenderer.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Awake", this ); }

                this.Initialize(false);
                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonRenderer.Awake end.*/

            /*Spine.Unity.SkeletonRenderer.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnDisable", this ); }

                if (this.clearStateOnDisable && this.valid) {
                    this.ClearState();
                }
            },
            /*Spine.Unity.SkeletonRenderer.OnDisable end.*/

            /*Spine.Unity.SkeletonRenderer.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnDestroy", this ); }

                this.rendererBuffers.Dispose();
                this.valid = false;
            },
            /*Spine.Unity.SkeletonRenderer.OnDestroy end.*/

            /*Spine.Unity.SkeletonRenderer.ClearState start.*/
            /**
             * Clears the previously generated mesh and resets the skeleton's pose.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#ClearState", this ); }

                var meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                if (UnityEngine.Component.op_Inequality(meshFilter, null)) {
                    meshFilter.sharedMesh = null;
                }
                this.currentInstructions.Clear();
                if (this.skeleton != null) {
                    this.skeleton.setToSetupPose();
                }
            },
            /*Spine.Unity.SkeletonRenderer.ClearState end.*/

            /*Spine.Unity.SkeletonRenderer.EnsureMeshGeneratorCapacity start.*/
            /**
             * Sets a minimum buffer size for the internal MeshGenerator to prevent excess allocations during animation.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {number}    minimumVertexCount
             * @return  {void}
             */
            EnsureMeshGeneratorCapacity: function (minimumVertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#EnsureMeshGeneratorCapacity", this ); }

                this.meshGenerator.EnsureVertexCapacity(minimumVertexCount);
            },
            /*Spine.Unity.SkeletonRenderer.EnsureMeshGeneratorCapacity end.*/

            /*Spine.Unity.SkeletonRenderer.Initialize start.*/
            /**
             * Initialize this component. Attempts to load the SkeletonData and creates the internal Skeleton object and buffers.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {boolean}    overwrite    If set to <pre><code>true</code></pre>, it will overwrite internal objects if they were already generated. Otherwise, the initialized component will ignore subsequent calls to initialize.
             * @param   {boolean}    quiet
             * @return  {void}
             */
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Initialize", this ); }

                var $t;
                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                // Clear
                {
                    // Note: do not reset meshFilter.sharedMesh or meshRenderer.sharedMaterial to null,
                    // otherwise constant reloading will be triggered at prefabs.
                    this.currentInstructions.Clear();
                    this.rendererBuffers.Clear();
                    this.meshGenerator.Begin();
                    this.skeleton = null;
                    this.valid = false;
                }

                if (this.skeletonDataAsset == null) {
                    return;
                }

                var skeletonData = this.skeletonDataAsset.GetSkeletonData(false);
                if (skeletonData == null) {
                    return;
                }
                this.valid = true;

                this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                if (UnityEngine.Component.op_Equality(this.meshFilter, null)) {
                    this.meshFilter = this.gameObject.AddComponent(UnityEngine.MeshFilter);
                }

                this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                this.rendererBuffers.Initialize();

                this.skeleton = ($t = new Spine.Skeleton.$ctor1(skeletonData), $t.scaleX = this.initialFlipX ? -1 : 1, $t.scaleY = this.initialFlipY ? -1 : 1, $t);

                if (!System.String.isNullOrEmpty(this.initialSkinName) && !System.String.equals(this.initialSkinName, "default", 4)) {
                    this.skeleton.setSkinByName(this.initialSkinName);
                }

                this.separatorSlots.clear();
                for (var i = 0; i < this.separatorSlotNames.length; i = (i + 1) | 0) {
                    this.separatorSlots.add(this.skeleton.findSlot(this.separatorSlotNames[i]));
                }

                // Generate mesh once, required to update mesh bounds for visibility
                var updateModeSaved = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.skeleton.updateWorldTransform();
                this.LateUpdate();
                this.updateMode = updateModeSaved;

                if (!Bridge.staticEquals(this.OnRebuild, null)) {
                    this.OnRebuild(this);
                }

            },
            /*Spine.Unity.SkeletonRenderer.Initialize end.*/

            /*Spine.Unity.SkeletonRenderer.LateUpdate start.*/
            /**
             * Generates a new UnityEngine.Mesh from the internal Skeleton.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#LateUpdate", this ); }

                if (!this.valid) {
                    return;
                }


                if (this.updateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    return;
                }

                this.LateUpdateMesh();
            },
            /*Spine.Unity.SkeletonRenderer.LateUpdate end.*/

            /*Spine.Unity.SkeletonRenderer.LateUpdateMesh start.*/
            LateUpdateMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#LateUpdateMesh", this ); }

                var $t, $t1;
                var doMeshOverride = !Bridge.staticEquals(this.generateMeshOverride, null);
                if ((!UnityEngine.Object.op_Implicit(this.meshRenderer) || !this.meshRenderer.enabled) && !doMeshOverride) {
                    return;
                }
                var currentInstructions = this.currentInstructions;
                var workingSubmeshInstructions = currentInstructions.submeshInstructions;
                var currentSmartMesh = this.rendererBuffers.GetNextMesh(); // Double-buffer for performance.

                var updateTriangles;

                if (this.singleSubmesh) {
                    // STEP 1. Determine a SmartMesh.Instruction. Split up instructions into submeshes. =============================================
                    Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction(currentInstructions, this.skeleton, ($t = this.skeletonDataAsset.atlasAssets)[0].PrimaryMaterial);

                    // STEP 1.9. Post-process workingInstructions. ==================================================================================
                    if (this.customMaterialOverride.Count > 0) {
                        Spine.Unity.MeshGenerator.TryReplaceMaterials(workingSubmeshInstructions, this.customMaterialOverride);
                    }

                    // STEP 2. Update vertex buffer based on verts from the attachments. ===========================================================
                    this.meshGenerator.settings = ($t1 = new Spine.Unity.MeshGenerator.Settings(), $t1.pmaVertexColors = this.pmaVertexColors, $t1.zSpacing = this.zSpacing, $t1.useClipping = this.useClipping, $t1.tintBlack = this.tintBlack, $t1.calculateTangents = this.calculateTangents, $t1.addNormals = this.addNormals, $t1);
                    this.meshGenerator.Begin();
                    updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, currentSmartMesh.instructionUsed);
                    if (currentInstructions.hasActiveClipping) {
                        this.meshGenerator.AddSubmesh(workingSubmeshInstructions.Items[0], updateTriangles);
                    } else {
                        this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                    }

                } else {
                    // STEP 1. Determine a SmartMesh.Instruction. Split up instructions into submeshes. =============================================
                    Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction(currentInstructions, this.skeleton, this.customSlotMaterials, this.separatorSlots, doMeshOverride, this.immutableTriangles);

                    // STEP 1.9. Post-process workingInstructions. ==================================================================================
                    if (this.customMaterialOverride.Count > 0) {
                        Spine.Unity.MeshGenerator.TryReplaceMaterials(workingSubmeshInstructions, this.customMaterialOverride);
                    }

                    if (doMeshOverride) {
                        this.generateMeshOverride(currentInstructions);
                        if (this.disableRenderingOnOverride) {
                            return;
                        }
                    }

                    updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, currentSmartMesh.instructionUsed);

                    // STEP 2. Update vertex buffer based on verts from the attachments. ===========================================================
                    this.meshGenerator.settings = ($t1 = new Spine.Unity.MeshGenerator.Settings(), $t1.pmaVertexColors = this.pmaVertexColors, $t1.zSpacing = this.zSpacing, $t1.useClipping = this.useClipping, $t1.tintBlack = this.tintBlack, $t1.calculateTangents = this.calculateTangents, $t1.addNormals = this.addNormals, $t1);
                    this.meshGenerator.Begin();
                    if (currentInstructions.hasActiveClipping) {
                        this.meshGenerator.BuildMesh(currentInstructions, updateTriangles);
                    } else {
                        this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                    }
                }

                if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                    this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                }

                // STEP 3. Move the mesh data into a UnityEngine.Mesh ===========================================================================
                var currentMesh = currentSmartMesh.mesh;
                this.meshGenerator.FillVertexData(currentMesh);

                this.rendererBuffers.UpdateSharedMaterials(workingSubmeshInstructions);

                var materialsChanged = this.rendererBuffers.MaterialsChangedInLastUpdate();
                if (updateTriangles) { // Check if the triangles should also be updated.
                    this.meshGenerator.FillTriangles(currentMesh);
                    this.meshRenderer.sharedMaterials = this.rendererBuffers.GetUpdatedSharedMaterialsArray();
                } else if (materialsChanged) {
                    this.meshRenderer.sharedMaterials = this.rendererBuffers.GetUpdatedSharedMaterialsArray();
                }
                if (materialsChanged && (this.maskMaterials.AnyMaterialCreated)) {
                    this.maskMaterials = new Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials();
                }

                this.meshGenerator.FillLateVertexData(currentMesh);

                // STEP 4. The UnityEngine.Mesh is ready. Set it as the MeshFilter's mesh. Store the instructions used for that mesh. ===========
                if (UnityEngine.Object.op_Implicit(this.meshFilter)) {
                    this.meshFilter.sharedMesh = currentMesh;
                }
                currentSmartMesh.instructionUsed.Set(currentInstructions);

                if (UnityEngine.Component.op_Inequality(this.meshRenderer, null)) {
                    this.AssignSpriteMaskMaterials();
                }

                if (this.fixDrawOrder && this.meshRenderer.sharedMaterials.length > 2) {
                    this.SetMaterialSettingsToFixDrawOrder();
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonRenderer.LateUpdateMesh end.*/

            /*Spine.Unity.SkeletonRenderer.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnBecameVisible", this ); }

                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;

                // OnBecameVisible is called after LateUpdate()
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonRenderer.OnBecameVisible end.*/

            /*Spine.Unity.SkeletonRenderer.OnBecameInvisible start.*/
            OnBecameInvisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnBecameInvisible", this ); }

                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonRenderer.OnBecameInvisible end.*/

            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots$1 start.*/
            FindAndApplySeparatorSlots$1: function (startsWith, clearExistingSeparators, updateStringArray) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots$1", this ); }

                if (clearExistingSeparators === void 0) { clearExistingSeparators = true; }
                if (updateStringArray === void 0) { updateStringArray = false; }
                if (System.String.isNullOrEmpty(startsWith)) {
                    return;
                }

                this.FindAndApplySeparatorSlots(function (slotName) {
                    return System.String.startsWith(slotName, startsWith);
                }, clearExistingSeparators, updateStringArray);
            },
            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots$1 end.*/

            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots start.*/
            FindAndApplySeparatorSlots: function (slotNamePredicate, clearExistingSeparators, updateStringArray) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots", this ); }

                var $t, $t1, $t2;
                if (clearExistingSeparators === void 0) { clearExistingSeparators = true; }
                if (updateStringArray === void 0) { updateStringArray = false; }
                if (Bridge.staticEquals(slotNamePredicate, null)) {
                    return;
                }
                if (!this.valid) {
                    return;
                }

                if (clearExistingSeparators) {
                    this.separatorSlots.clear();
                }

                var slots = this.skeleton.Slots;
                $t = Bridge.getEnumerator(slots);
                try {
                    while ($t.moveNext()) {
                        var slot = $t.Current;
                        if (slotNamePredicate(slot.data.name)) {
                            this.separatorSlots.add(slot);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (updateStringArray) {
                    var detectedSeparatorNames = new (System.Collections.Generic.List$1(System.String)).ctor();
                    $t1 = Bridge.getEnumerator(this.skeleton.Slots);
                    try {
                        while ($t1.moveNext()) {
                            var slot1 = $t1.Current;
                            var slotName = slot1.data.name;
                            if (slotNamePredicate(slotName)) {
                                detectedSeparatorNames.add(slotName);
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    if (!clearExistingSeparators) {
                        var originalNames = this.separatorSlotNames;
                        $t2 = Bridge.getEnumerator(originalNames);
                        try {
                            while ($t2.moveNext()) {
                                var originalName = $t2.Current;
                                detectedSeparatorNames.add(originalName);
                            }
                        } finally {
                            if (Bridge.is($t2, System.IDisposable)) {
                                $t2.System$IDisposable$Dispose();
                            }
                        }
                    }

                    this.separatorSlotNames = detectedSeparatorNames.ToArray();
                }

            },
            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots end.*/

            /*Spine.Unity.SkeletonRenderer.ReapplySeparatorSlotNames start.*/
            ReapplySeparatorSlotNames: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#ReapplySeparatorSlotNames", this ); }

                if (!this.valid) {
                    return;
                }

                this.separatorSlots.clear();
                for (var i = 0, n = this.separatorSlotNames.length; i < n; i = (i + 1) | 0) {
                    var slot = this.skeleton.findSlot(this.separatorSlotNames[i]);
                    if (slot != null) {
                        this.separatorSlots.add(slot);
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.ReapplySeparatorSlotNames end.*/

            /*Spine.Unity.SkeletonRenderer.AssignSpriteMaskMaterials start.*/
            AssignSpriteMaskMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#AssignSpriteMaskMaterials", this ); }

                var $t, $t1, $t2;

                if (UnityEngine.Application.isPlaying) {
                    if (this.maskInteraction !== UnityEngine.SpriteMaskInteraction.None && this.maskMaterials.materialsMaskDisabled.length === 0) {
                        this.maskMaterials.materialsMaskDisabled = this.meshRenderer.sharedMaterials;
                    }
                }

                if (this.maskMaterials.materialsMaskDisabled.length > 0 && ($t = this.maskMaterials.materialsMaskDisabled)[0] != null && this.maskInteraction === UnityEngine.SpriteMaskInteraction.None) {
                    this.meshRenderer.materials = this.maskMaterials.materialsMaskDisabled;
                } else if (this.maskInteraction === UnityEngine.SpriteMaskInteraction.VisibleInsideMask) {
                    if (this.maskMaterials.materialsInsideMask.length === 0 || ($t1 = this.maskMaterials.materialsInsideMask)[0] == null) {
                        if (!this.InitSpriteMaskMaterialsInsideMask()) {
                            return;
                        }
                    }
                    this.meshRenderer.materials = this.maskMaterials.materialsInsideMask;
                } else if (this.maskInteraction === UnityEngine.SpriteMaskInteraction.VisibleOutsideMask) {
                    if (this.maskMaterials.materialsOutsideMask.length === 0 || ($t2 = this.maskMaterials.materialsOutsideMask)[0] == null) {
                        if (!this.InitSpriteMaskMaterialsOutsideMask()) {
                            return;
                        }
                    }
                    this.meshRenderer.materials = this.maskMaterials.materialsOutsideMask;
                }
            },
            /*Spine.Unity.SkeletonRenderer.AssignSpriteMaskMaterials end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsInsideMask start.*/
            InitSpriteMaskMaterialsInsideMask: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsInsideMask", this ); }

                return this.InitSpriteMaskMaterialsForMaskType(Spine.Unity.SkeletonRenderer.STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE, Bridge.ref(this.maskMaterials, "materialsInsideMask"));
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsInsideMask end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsOutsideMask start.*/
            InitSpriteMaskMaterialsOutsideMask: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsOutsideMask", this ); }

                return this.InitSpriteMaskMaterialsForMaskType(Spine.Unity.SkeletonRenderer.STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE, Bridge.ref(this.maskMaterials, "materialsOutsideMask"));
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsOutsideMask end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsForMaskType start.*/
            InitSpriteMaskMaterialsForMaskType: function (maskFunction, materialsToFill) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsForMaskType", this ); }


                var originalMaterials = this.maskMaterials.materialsMaskDisabled;
                materialsToFill.v = System.Array.init(originalMaterials.length, null, UnityEngine.Material);
                for (var i = 0; i < originalMaterials.length; i = (i + 1) | 0) {
                    var newMaterial = new UnityEngine.Material.$ctor1(originalMaterials[i]);
                    newMaterial.SetFloat(Spine.Unity.SkeletonRenderer.STENCIL_COMP_PARAM_ID, maskFunction);
                    materialsToFill.v[i] = newMaterial;
                }
                return true;
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsForMaskType end.*/

            /*Spine.Unity.SkeletonRenderer.SetMaterialSettingsToFixDrawOrder start.*/
            /**
             * This method was introduced as a workaround for too aggressive submesh draw call batching,
             leading to incorrect draw order when 3+ materials are used at submeshes in alternating order.
             Otherwise, e.g. when using Lightweight Render Pipeline, deliberately separated draw calls
             "A1 B A2" are reordered to "A1A2 B", regardless of batching-related project settings.
             *
             * @instance
             * @private
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            SetMaterialSettingsToFixDrawOrder: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SetMaterialSettingsToFixDrawOrder", this ); }

                var $t, $t1;
                if (this.reusedPropertyBlock == null) {
                    this.reusedPropertyBlock = new UnityEngine.MaterialPropertyBlock();
                }

                var hasPerRendererBlock = this.meshRenderer.HasPropertyBlock();
                if (hasPerRendererBlock) {
                    this.meshRenderer.GetPropertyBlock(this.reusedPropertyBlock);
                }

                for (var i = 0; i < this.meshRenderer.sharedMaterials.length; i = (i + 1) | 0) {
                    if (!UnityEngine.Object.op_Implicit(($t = this.meshRenderer.sharedMaterials)[i])) {
                        continue;
                    }

                    if (!hasPerRendererBlock) {
                        this.meshRenderer.GetPropertyBlock$1(this.reusedPropertyBlock, i);
                    }
                    // Note: this parameter shall not exist at any shader, then Unity will create separate
                    // material instances (not in terms of memory cost or leakage).
                    this.reusedPropertyBlock.SetFloat(Spine.Unity.SkeletonRenderer.SUBMESH_DUMMY_PARAM_ID, i);
                    this.meshRenderer.SetPropertyBlock$1(this.reusedPropertyBlock, i);

                    ($t1 = this.meshRenderer.sharedMaterials)[i].enableInstancing = false;
                }
            },
            /*Spine.Unity.SkeletonRenderer.SetMaterialSettingsToFixDrawOrder end.*/


        },
        overloads: {
            "FindAndApplySeparatorSlots(string, bool, bool)": "FindAndApplySeparatorSlots$1"
        }
    });
    /*Spine.Unity.SkeletonRenderer end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate
     * @param   {Spine.Unity.SkeletonGraphic}    skeletonGraphic
     * @return  {void}
     */


    /*Spine.Unity.SkeletonGraphic start.*/
    Bridge.define("Spine.Unity.SkeletonGraphic", {
        inherits: [UnityEngine.UI.MaskableGraphic,Spine.Unity.ISkeletonComponent,Spine.Unity.IAnimationStateComponent,Spine.Unity.ISkeletonAnimation,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                SeparatorPartGameObjectName: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#init", this ); }

                    this.SeparatorPartGameObjectName = "Part";
                }
            },
            methods: {
                /*Spine.Unity.SkeletonGraphic.NewSkeletonGraphicGameObject:static start.*/
                /**
                 * Create a new GameObject with a SkeletonGraphic component.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonGraphic
                 * @memberof Spine.Unity.SkeletonGraphic
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {UnityEngine.Transform}            parent               
                 * @param   {UnityEngine.Material}             material             Material for the canvas renderer to use. Usually, the default SkeletonGraphic material will work.
                 * @return  {Spine.Unity.SkeletonGraphic}
                 */
                NewSkeletonGraphicGameObject: function (skeletonDataAsset, parent, material) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#NewSkeletonGraphicGameObject", this ); }

                    var sg = Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent(new UnityEngine.GameObject.$ctor2("New Spine GameObject"), skeletonDataAsset, material);
                    if (UnityEngine.Component.op_Inequality(parent, null)) {
                        sg.transform.SetParent(parent, false);
                    }
                    return sg;
                },
                /*Spine.Unity.SkeletonGraphic.NewSkeletonGraphicGameObject:static end.*/

                /*Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent:static start.*/
                /**
                 * Add a SkeletonGraphic component to a GameObject.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonGraphic
                 * @memberof Spine.Unity.SkeletonGraphic
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {UnityEngine.Material}             material             Material for the canvas renderer to use. Usually, the default SkeletonGraphic material will work.
                 * @return  {Spine.Unity.SkeletonGraphic}
                 */
                AddSkeletonGraphicComponent: function (gameObject, skeletonDataAsset, material) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#AddSkeletonGraphicComponent", this ); }

                    var c = gameObject.AddComponent(Spine.Unity.SkeletonGraphic);
                    if (skeletonDataAsset != null) {
                        c.material = material;
                        c.skeletonDataAsset = skeletonDataAsset;
                        c.Initialize(false);
                    }
                    return c;
                },
                /*Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent:static end.*/


            }
        },
        fields: {
            skeletonDataAsset: null,
            additiveMaterial: null,
            multiplyMaterial: null,
            screenMaterial: null,
            initialSkinName: null,
            initialFlipX: false,
            initialFlipY: false,
            startingAnimation: null,
            startingLoop: false,
            timeScale: 0,
            freeze: false,
            updateMode: 0,
            /**
             * Update mode used when the MeshRenderer becomes invisible
             (when <pre><code>OnBecameInvisible()</code></pre> is called). Update mode is automatically
             reset to <pre><code>UpdateMode.FullUpdate</code></pre> when the mesh becomes visible again.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @type Spine.Unity.UpdateMode
             */
            updateWhenInvisible: 0,
            unscaledTime: false,
            allowMultipleCanvasRenderers: false,
            canvasRenderers: null,
            submeshGraphics: null,
            usedRenderersCount: 0,
            /**
             * Slot names used to populate separatorSlots list when the Skeleton is initialized. Changing this after initialization does nothing.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonGraphic
             * @type Array.<string>
             */
            separatorSlotNames: null,
            /**
             * Slots that determine where the render is split. This is used by components such as SkeletonRenderSeparator so that the skeleton can be rendered by two separate renderers on different GameObjects.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @type System.Collections.Generic.List$1
             */
            separatorSlots: null,
            enableSeparatorSlots: false,
            separatorParts: null,
            updateSeparatorPartLocation: false,
            wasUpdatedAfterInit: false,
            baseTexture: null,
            customTextureOverride: null,
            customMaterialOverride: null,
            overrideTexture: null,
            skeleton: null,
            state: null,
            meshGenerator: null,
            meshBuffers: null,
            currentInstructions: null,
            meshes: null
        },
        events: {
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnRebuild
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnRebuild
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnRebuild: null,
            /**
             * OnMeshAndMaterialsUpdated is at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null,
            BeforeApply: null,
            UpdateLocal: null,
            UpdateWorld: null,
            UpdateComplete: null,
            /**
             * Occurs after the vertex data populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            /**
             * Occurs after the vertex data populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            OnPostProcessVertices: null
        },
        props: {
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            },
            /**
             * Update mode to optionally limit updates to e.g. only apply animations but not update the mesh.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @function UpdateMode
             * @type Spine.Unity.UpdateMode
             */
            UpdateMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMode#get", this ); }

                    return this.updateMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMode#set", this ); }

                    this.updateMode = value;
                }
            },
            SeparatorParts: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SeparatorParts#get", this ); }

                    return this.separatorParts;
                }
            },
            /**
             * Use this Dictionary to override a Texture with a different Texture.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @function CustomTextureOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomTextureOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#CustomTextureOverride#get", this ); }

                    return this.customTextureOverride;
                }
            },
            /**
             * Use this Dictionary to override the Material where the Texture was used at the original atlas.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @function CustomMaterialOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomMaterialOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#CustomMaterialOverride#get", this ); }

                    return this.customMaterialOverride;
                }
            },
            OverrideTexture: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OverrideTexture#get", this ); }

                    return this.overrideTexture;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OverrideTexture#set", this ); }

                    this.overrideTexture = value;
                    this.canvasRenderer.SetTexture(this.mainTexture); // Refresh canvasRenderer's texture. Make sure it handles null.
                }
            },
            mainTexture: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#mainTexture#get", this ); }

                    if (this.overrideTexture != null) {
                        return this.overrideTexture;
                    }
                    return this.baseTexture;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Skeleton#get", this ); }

                    this.Initialize(false);
                    return this.skeleton;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Skeleton#set", this ); }

                    this.skeleton = value;
                }
            },
            SkeletonData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SkeletonData#get", this ); }

                    return this.skeleton == null ? null : this.skeleton.data;
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#IsValid#get", this ); }

                    return this.skeleton != null;
                }
            },
            AnimationState: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#AnimationState#get", this ); }

                    this.Initialize(false);
                    return this.state;
                }
            },
            MeshGenerator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MeshGenerator#get", this ); }

                    return this.meshGenerator;
                }
            }
        },
        alias: [
            "SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset",
            "SkeletonDataAsset", "Spine$Unity$ISkeletonComponent$SkeletonDataAsset",
            "Rebuild", "UnityEngine$UI$ICanvasElement$Rebuild",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton",
            "Skeleton", "Spine$Unity$ISkeletonComponent$Skeleton",
            "AnimationState", "Spine$Unity$IAnimationStateComponent$AnimationState",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#init", this ); }

                this.timeScale = 1.0;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.updateWhenInvisible = Spine.Unity.UpdateMode.FullUpdate;
                this.allowMultipleCanvasRenderers = false;
                this.canvasRenderers = new (System.Collections.Generic.List$1(UnityEngine.CanvasRenderer)).ctor();
                this.submeshGraphics = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonSubmeshGraphic)).ctor();
                this.usedRenderersCount = 0;
                this.separatorSlotNames = System.Array.init(0, null, System.String);
                this.separatorSlots = new (System.Collections.Generic.List$1(Spine.Slot)).ctor();
                this.enableSeparatorSlots = false;
                this.separatorParts = new (System.Collections.Generic.List$1(UnityEngine.Transform)).ctor();
                this.updateSeparatorPartLocation = true;
                this.wasUpdatedAfterInit = true;
                this.customTextureOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Texture,UnityEngine.Texture)).ctor();
                this.customMaterialOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Texture,UnityEngine.Material)).ctor();
                this.meshGenerator = new Spine.Unity.MeshGenerator();
                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
                this.meshes = new (Spine.ExposedList$1(UnityEngine.Mesh)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphic.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Awake", this ); }


                UnityEngine.UI.MaskableGraphic.prototype.Awake.call(this);
                this.onCullStateChanged.AddListener(Bridge.fn.cacheBind(this, this.OnCullStateChanged));

                this.SyncSubmeshGraphicsWithCanvasRenderers();
                if (!this.IsValid) {
                    this.Initialize(false);
                    this.Rebuild(UnityEngine.UI.CanvasUpdate.PreRender);
                }
            },
            /*Spine.Unity.SkeletonGraphic.Awake end.*/

            /*Spine.Unity.SkeletonGraphic.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnDestroy", this ); }

                this.Clear();
                UnityEngine.UI.MaskableGraphic.prototype.OnDestroy.call(this);
            },
            /*Spine.Unity.SkeletonGraphic.OnDestroy end.*/

            /*Spine.Unity.SkeletonGraphic.Rebuild start.*/
            Rebuild: function (update) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Rebuild", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.Rebuild.call(this, update);
                if (this.canvasRenderer.cull) {
                    return;
                }
                if (update === UnityEngine.UI.CanvasUpdate.PreRender) {
                    this.UpdateMesh(true);
                }
                if (this.allowMultipleCanvasRenderers) {
                    this.canvasRenderer.Clear();
                }
            },
            /*Spine.Unity.SkeletonGraphic.Rebuild end.*/

            /*Spine.Unity.SkeletonGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnDisable", this ); }

                var $t;
                UnityEngine.UI.MaskableGraphic.prototype.OnDisable.call(this);
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        canvasRenderer.Clear();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.OnDisable end.*/

            /*Spine.Unity.SkeletonGraphic.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Update", this ); }


                if (this.freeze) {
                    return;
                }
                this.Update$1(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.Update end.*/

            /*Spine.Unity.SkeletonGraphic.Update$1 start.*/
            Update$1: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Update$1", this ); }

                if (!this.IsValid) {
                    return;
                }

                this.wasUpdatedAfterInit = true;
                if (this.updateMode < Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }

                this.UpdateAnimationStatus(deltaTime);

                if (this.updateMode === Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, false);
                    return;
                }
                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonGraphic.Update$1 end.*/

            /*Spine.Unity.SkeletonGraphic.SyncSubmeshGraphicsWithCanvasRenderers start.*/
            SyncSubmeshGraphicsWithCanvasRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SyncSubmeshGraphicsWithCanvasRenderers", this ); }

                var $t;
                this.submeshGraphics.clear();

                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        var submeshGraphic = canvasRenderer.GetComponent(Spine.Unity.SkeletonSubmeshGraphic);
                        if (UnityEngine.MonoBehaviour.op_Equality(submeshGraphic, null)) {
                            submeshGraphic = canvasRenderer.gameObject.AddComponent(Spine.Unity.SkeletonSubmeshGraphic);
                            submeshGraphic.maskable = this.maskable;
                            submeshGraphic.raycastTarget = false;
                        }
                        this.submeshGraphics.add(submeshGraphic);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.SyncSubmeshGraphicsWithCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateAnimationStatus start.*/
            UpdateAnimationStatus: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateAnimationStatus", this ); }

                deltaTime *= this.timeScale;
                this.skeleton.update(deltaTime);
                this.state.update(deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.UpdateAnimationStatus end.*/

            /*Spine.Unity.SkeletonGraphic.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this.BeforeApply, null)) {
                    this.BeforeApply(this);
                }

                if (this.updateMode !== Spine.Unity.UpdateMode.OnlyEventTimelines) {
                    this.state.apply(this.skeleton);
                } else {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, true);
                }

                if (!Bridge.staticEquals(this.UpdateLocal, null)) {
                    this.UpdateLocal(this);
                }

                this.skeleton.updateWorldTransform();

                if (!Bridge.staticEquals(this.UpdateWorld, null)) {
                    this.UpdateWorld(this);
                    this.skeleton.updateWorldTransform();
                }

                if (!Bridge.staticEquals(this.UpdateComplete, null)) {
                    this.UpdateComplete(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#LateUpdate", this ); }

                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update$1(0);
                }
                if (this.freeze) {
                    return;
                }
                if (this.updateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    return;
                }

                this.UpdateMesh();
            },
            /*Spine.Unity.SkeletonGraphic.LateUpdate end.*/

            /*Spine.Unity.SkeletonGraphic.OnCullStateChanged start.*/
            OnCullStateChanged: function (culled) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnCullStateChanged", this ); }

                if (culled) {
                    this.OnBecameInvisible();
                } else {
                    this.OnBecameVisible();
                }
            },
            /*Spine.Unity.SkeletonGraphic.OnCullStateChanged end.*/

            /*Spine.Unity.SkeletonGraphic.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnBecameVisible", this ); }

                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
            },
            /*Spine.Unity.SkeletonGraphic.OnBecameVisible end.*/

            /*Spine.Unity.SkeletonGraphic.OnBecameInvisible start.*/
            OnBecameInvisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnBecameInvisible", this ); }

                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonGraphic.OnBecameInvisible end.*/

            /*Spine.Unity.SkeletonGraphic.ReapplySeparatorSlotNames start.*/
            ReapplySeparatorSlotNames: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#ReapplySeparatorSlotNames", this ); }

                if (!this.IsValid) {
                    return;
                }

                this.separatorSlots.clear();
                for (var i = 0, n = this.separatorSlotNames.length; i < n; i = (i + 1) | 0) {
                    var slotName = this.separatorSlotNames[i];
                    if (Bridge.referenceEquals(slotName, "")) {
                        continue;
                    }
                    var slot = this.skeleton.findSlot(slotName);
                    if (slot != null) {
                        this.separatorSlots.add(slot);
                    }
                }
                this.UpdateSeparatorPartParents();
            },
            /*Spine.Unity.SkeletonGraphic.ReapplySeparatorSlotNames end.*/

            /*Spine.Unity.SkeletonGraphic.GetLastMesh start.*/
            GetLastMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetLastMesh", this ); }

                return this.meshBuffers.GetCurrent().mesh;
            },
            /*Spine.Unity.SkeletonGraphic.GetLastMesh end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformWithBounds start.*/
            MatchRectTransformWithBounds: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformWithBounds", this ); }

                if (!this.wasUpdatedAfterInit) {
                    this.Update$1(0);
                }
                this.UpdateMesh();

                if (!this.allowMultipleCanvasRenderers) {
                    return this.MatchRectTransformSingleRenderer();
                } else {
                    return this.MatchRectTransformMultipleRenderers();
                }
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformWithBounds end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformSingleRenderer start.*/
            MatchRectTransformSingleRenderer: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformSingleRenderer", this ); }

                var mesh = this.GetLastMesh();
                if (mesh == null) {
                    return false;
                }
                if (mesh.vertexCount === 0) {
                    this.rectTransform.sizeDelta = new pc.Vec2( 50.0, 50.0 );
                    this.rectTransform.pivot = new pc.Vec2( 0.5, 0.5 );
                    return false;
                }
                mesh.RecalculateBounds();
                this.SetRectTransformBounds(mesh.bounds);
                return true;
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformSingleRenderer end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformMultipleRenderers start.*/
            MatchRectTransformMultipleRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformMultipleRenderers", this ); }

                var $t;
                var anyBoundsAdded = false;
                var combinedBounds = new pc.BoundingBox.ctor();
                for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (!canvasRenderer.gameObject.activeSelf) {
                        continue;
                    }

                    var mesh = ($t = this.meshes.Items)[i];
                    if (mesh == null || mesh.vertexCount === 0) {
                        continue;
                    }

                    mesh.RecalculateBounds();
                    var bounds = mesh.bounds;
                    if (anyBoundsAdded) {
                        combinedBounds.add( bounds );
                    } else {
                        anyBoundsAdded = true;
                        combinedBounds = bounds;
                    }
                }

                if (!anyBoundsAdded) {
                    this.rectTransform.sizeDelta = new pc.Vec2( 50.0, 50.0 );
                    this.rectTransform.pivot = new pc.Vec2( 0.5, 0.5 );
                    return false;
                }

                this.SetRectTransformBounds(combinedBounds);
                return true;
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformMultipleRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.SetRectTransformBounds start.*/
            SetRectTransformBounds: function (combinedBounds) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SetRectTransformBounds", this ); }

                var $t;
                var size = combinedBounds.halfExtents.$clone().scale( 2 ).$clone();
                var center = combinedBounds.center.$clone();
                var p = new pc.Vec2( 0.5 - (center.x / size.x), 0.5 - (center.y / size.y) );

                this.rectTransform.sizeDelta = UnityEngine.Vector2.FromVector3(size.$clone());
                this.rectTransform.pivot = p.$clone();

                $t = Bridge.getEnumerator(this.submeshGraphics);
                try {
                    while ($t.moveNext()) {
                        var submeshGraphic = $t.Current;
                        submeshGraphic.rectTransform.sizeDelta = UnityEngine.Vector2.FromVector3(size.$clone());
                        submeshGraphic.rectTransform.pivot = p.$clone();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.SetRectTransformBounds end.*/

            /*Spine.Unity.SkeletonGraphic.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Clear", this ); }

                this.skeleton = null;
                this.canvasRenderer.Clear();

                for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    this.canvasRenderers.getItem(i).Clear();
                }
                this.DestroyMeshes();
                this.DisposeMeshBuffers();
            },
            /*Spine.Unity.SkeletonGraphic.Clear end.*/

            /*Spine.Unity.SkeletonGraphic.TrimRenderers start.*/
            TrimRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#TrimRenderers", this ); }

                var $t;
                var newList = new (System.Collections.Generic.List$1(UnityEngine.CanvasRenderer)).ctor();
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        if (canvasRenderer.gameObject.activeSelf) {
                            newList.add(canvasRenderer);
                        } else {
                            if (UnityEngine.Application.isEditor && !UnityEngine.Application.isPlaying) {
                                UnityEngine.Object.DestroyImmediate(canvasRenderer.gameObject);
                            } else {
                                UnityEngine.MonoBehaviour.Destroy(canvasRenderer.gameObject);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.canvasRenderers = newList;
                this.SyncSubmeshGraphicsWithCanvasRenderers();
            },
            /*Spine.Unity.SkeletonGraphic.TrimRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.Initialize start.*/
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Initialize", this ); }

                var $t, $t1;
                if (this.IsValid && !overwrite) {
                    return;
                }
                if (this.skeletonDataAsset == null) {
                    return;
                }
                var skeletonData = this.skeletonDataAsset.GetSkeletonData(false);
                if (skeletonData == null) {
                    return;
                }

                if (this.skeletonDataAsset.atlasAssets.length <= 0 || ($t = this.skeletonDataAsset.atlasAssets)[0].MaterialCount <= 0) {
                    return;
                }

                this.state = new Spine.AnimationState(this.skeletonDataAsset.GetAnimationStateData());
                if (this.state == null) {
                    this.Clear();
                    return;
                }

                this.skeleton = ($t1 = new Spine.Skeleton.$ctor1(skeletonData), $t1.scaleX = this.initialFlipX ? -1 : 1, $t1.scaleY = this.initialFlipY ? -1 : 1, $t1);

                this.InitMeshBuffers();
                this.baseTexture = ($t1 = this.skeletonDataAsset.atlasAssets)[0].PrimaryMaterial.mainTexture;
                this.canvasRenderer.SetTexture(this.mainTexture); // Needed for overwriting initializations.

                // Set the initial Skin and Animation
                if (!System.String.isNullOrEmpty(this.initialSkinName)) {
                    this.skeleton.setSkinByName(this.initialSkinName);
                }

                this.separatorSlots.clear();
                for (var i = 0; i < this.separatorSlotNames.length; i = (i + 1) | 0) {
                    this.separatorSlots.add(this.skeleton.findSlot(this.separatorSlotNames[i]));
                }

                this.wasUpdatedAfterInit = false;
                if (!System.String.isNullOrEmpty(this.startingAnimation)) {
                    var animationObject = this.skeletonDataAsset.GetSkeletonData(false).findAnimation(this.startingAnimation);
                    if (animationObject != null) {
                        this.state.setAnimationWith( 0, animationObject, this.startingLoop );
                    }
                }

                if (!Bridge.staticEquals(this.OnRebuild, null)) {
                    this.OnRebuild(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.Initialize end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMesh start.*/
            UpdateMesh: function (keepRendererCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMesh", this ); }

                if (keepRendererCount === void 0) { keepRendererCount = false; }
                if (!this.IsValid) {
                    return;
                }

                Spine.Unity.SkeletonExtensions.SetColor$4(this.skeleton, this.color.$clone());

                var currentInstructions = this.currentInstructions;
                if (!this.allowMultipleCanvasRenderers) {
                    this.UpdateMeshSingleCanvasRenderer();
                } else {
                    this.UpdateMeshMultipleCanvasRenderers(currentInstructions, keepRendererCount);
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMesh end.*/

            /*Spine.Unity.SkeletonGraphic.HasMultipleSubmeshInstructions start.*/
            HasMultipleSubmeshInstructions: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#HasMultipleSubmeshInstructions", this ); }

                if (!this.IsValid) {
                    return false;
                }
                return Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder(this.skeleton);
            },
            /*Spine.Unity.SkeletonGraphic.HasMultipleSubmeshInstructions end.*/

            /*Spine.Unity.SkeletonGraphic.InitMeshBuffers start.*/
            InitMeshBuffers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#InitMeshBuffers", this ); }

                if (this.meshBuffers != null) {
                    this.meshBuffers.GetNext().Clear();
                    this.meshBuffers.GetNext().Clear();
                } else {
                    this.meshBuffers = new (Spine.Unity.DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh))();
                }
            },
            /*Spine.Unity.SkeletonGraphic.InitMeshBuffers end.*/

            /*Spine.Unity.SkeletonGraphic.DisposeMeshBuffers start.*/
            DisposeMeshBuffers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DisposeMeshBuffers", this ); }

                if (this.meshBuffers != null) {
                    this.meshBuffers.GetNext().Dispose();
                    this.meshBuffers.GetNext().Dispose();
                    this.meshBuffers = null;
                }
            },
            /*Spine.Unity.SkeletonGraphic.DisposeMeshBuffers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshSingleCanvasRenderer start.*/
            UpdateMeshSingleCanvasRenderer: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshSingleCanvasRenderer", this ); }

                var $t, $t1;
                if (this.canvasRenderers.Count > 0) {
                    this.DisableUnusedCanvasRenderers(0);
                }

                var smartMesh = this.meshBuffers.GetNext();
                Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction(this.currentInstructions, this.skeleton, null);
                var updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(this.currentInstructions, smartMesh.instructionUsed);

                this.meshGenerator.Begin();
                if (this.currentInstructions.hasActiveClipping && this.currentInstructions.submeshInstructions.Count > 0) {
                    this.meshGenerator.AddSubmesh(($t = this.currentInstructions.submeshInstructions.Items)[0], updateTriangles);
                } else {
                    this.meshGenerator.BuildMeshWithArrays(this.currentInstructions, updateTriangles);
                }

                if (UnityEngine.Component.op_Inequality(this.canvas, null)) {
                    this.meshGenerator.ScaleVertexData(this.canvas.referencePixelsPerUnit);
                }
                if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                    this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                }

                var mesh = smartMesh.mesh;
                this.meshGenerator.FillVertexData(mesh);
                if (updateTriangles) {
                    this.meshGenerator.FillTriangles(mesh);
                }
                this.meshGenerator.FillLateVertexData(mesh);

                this.canvasRenderer.SetMesh(mesh);
                smartMesh.instructionUsed.Set(this.currentInstructions);

                if (this.currentInstructions.submeshInstructions.Count > 0) {
                    var material = ($t1 = this.currentInstructions.submeshInstructions.Items)[0].material;
                    if (material != null && !Bridge.referenceEquals(this.baseTexture, material.mainTexture)) {
                        this.baseTexture = material.mainTexture;
                        if (this.overrideTexture == null) {
                            this.canvasRenderer.SetTexture(this.mainTexture);
                        }
                    }
                }

                //this.UpdateMaterial(); // note: This would allocate memory.
                this.usedRenderersCount = 0;
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshSingleCanvasRenderer end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshMultipleCanvasRenderers start.*/
            UpdateMeshMultipleCanvasRenderers: function (currentInstructions, keepRendererCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshMultipleCanvasRenderers", this ); }

                var $t;
                Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction(currentInstructions, this.skeleton, null, this.enableSeparatorSlots ? this.separatorSlots : null, this.enableSeparatorSlots ? this.separatorSlots.Count > 0 : false, false);

                var submeshCount = currentInstructions.submeshInstructions.Count;
                if (keepRendererCount && submeshCount !== this.usedRenderersCount) {
                    return;
                }
                this.EnsureCanvasRendererCount(submeshCount);
                this.EnsureMeshesCount(submeshCount);
                this.EnsureSeparatorPartCount();

                var c = this.canvas;
                var scale = (UnityEngine.Component.op_Equality(c, null)) ? 100 : c.referencePixelsPerUnit;

                // Generate meshes.
                var meshesItems = this.meshes.Items;
                var useOriginalTextureAndMaterial = (this.customMaterialOverride.Count === 0 && this.customTextureOverride.Count === 0);
                var separatorSlotGroupIndex = 0;
                var parent = this.separatorSlots.Count === 0 ? this.transform : this.separatorParts.getItem(0);

                if (this.updateSeparatorPartLocation) {
                    for (var p = 0; p < this.separatorParts.Count; p = (p + 1) | 0) {
                        this.separatorParts.getItem(p).position = this.transform.position.$clone();
                        this.separatorParts.getItem(p).rotation = this.transform.rotation.$clone();
                    }
                }

                var blendModeMaterials = this.skeletonDataAsset.blendModeMaterials;
                var hasBlendModeMaterials = blendModeMaterials.RequiresBlendModeMaterials;
                var mainCullTransparentMesh = this.canvasRenderer.cullTransparentMesh;
                var pmaVertexColors = this.meshGenerator.settings.pmaVertexColors;
                var targetSiblingIndex = 0;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[i].$clone();
                    this.meshGenerator.Begin();
                    this.meshGenerator.AddSubmesh(submeshInstructionItem);

                    var targetMesh = meshesItems[i];
                    this.meshGenerator.ScaleVertexData(scale);
                    if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                        this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                    }
                    this.meshGenerator.FillVertexData(targetMesh);
                    this.meshGenerator.FillTriangles(targetMesh);
                    this.meshGenerator.FillLateVertexData(targetMesh);

                    var submeshMaterial = submeshInstructionItem.material;
                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (i >= this.usedRenderersCount) {
                        canvasRenderer.gameObject.SetActive(true);
                    }
                    canvasRenderer.SetMesh(targetMesh);
                    canvasRenderer.materialCount = 1;

                    if (UnityEngine.Component.op_Inequality(canvasRenderer.transform.parent, parent.transform)) {
                        canvasRenderer.transform.SetParent(parent.transform, false);
                        canvasRenderer.transform.localPosition = pc.Vec3.ZERO.clone();
                    }
                    canvasRenderer.transform.SetSiblingIndex(Bridge.identity(targetSiblingIndex, ((targetSiblingIndex = (targetSiblingIndex + 1) | 0))));
                    if (submeshInstructionItem.forceSeparate) {
                        targetSiblingIndex = 0;
                        parent = this.separatorParts.getItem(((separatorSlotGroupIndex = (separatorSlotGroupIndex + 1) | 0)));
                    }

                    var submeshGraphic = this.submeshGraphics.getItem(i);
                    if (useOriginalTextureAndMaterial) {
                        var usedTexture = submeshMaterial.mainTexture;
                        if (!hasBlendModeMaterials) {
                            canvasRenderer.SetMaterial$1(this.materialForRendering, usedTexture);
                        } else {
                            var allowCullTransparentMesh = true;
                            var blendMode = blendModeMaterials.BlendModeForMaterial(submeshMaterial);
                            var usedMaterial = this.materialForRendering;
                            if (blendMode === spine.BlendMode.Normal) {
                                if (submeshInstructionItem.hasPMAAdditiveSlot) {
                                    allowCullTransparentMesh = false;
                                }
                            } else if (blendMode === spine.BlendMode.Additive) {
                                if (pmaVertexColors) {
                                    allowCullTransparentMesh = false;
                                } else {
                                    if (UnityEngine.Object.op_Implicit(this.additiveMaterial)) {
                                        usedMaterial = this.additiveMaterial;
                                    }
                                }
                            } else if (blendMode === spine.BlendMode.Multiply && UnityEngine.Object.op_Implicit(this.multiplyMaterial)) {
                                usedMaterial = this.multiplyMaterial;
                            } else {
                                if (blendMode === spine.BlendMode.Screen && UnityEngine.Object.op_Implicit(this.screenMaterial)) {
                                    usedMaterial = this.screenMaterial;
                                }
                            }

                            usedMaterial = submeshGraphic.GetModifiedMaterial(usedMaterial);
                            canvasRenderer.SetMaterial$1(usedMaterial, usedTexture);
                            canvasRenderer.cullTransparentMesh = allowCullTransparentMesh ? mainCullTransparentMesh : false;
                        }
                    } else {
                        var originalTexture = submeshMaterial.mainTexture;
                        var usedMaterial1 = { };
                        var usedTexture1 = { };
                        if (!this.customMaterialOverride.tryGetValue(originalTexture, usedMaterial1)) {
                            usedMaterial1.v = this.material;
                        }
                        if (!this.customTextureOverride.tryGetValue(originalTexture, usedTexture1)) {
                            usedTexture1.v = originalTexture;
                        }

                        usedMaterial1.v = submeshGraphic.GetModifiedMaterial(usedMaterial1.v);
                        canvasRenderer.SetMaterial$1(usedMaterial1.v, usedTexture1.v);
                    }
                }

                this.DisableUnusedCanvasRenderers(submeshCount);
                this.usedRenderersCount = submeshCount;
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshMultipleCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureCanvasRendererCount start.*/
            EnsureCanvasRendererCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureCanvasRendererCount", this ); }

                var currentCount = this.canvasRenderers.Count;
                for (var i = currentCount; i < targetCount; i = (i + 1) | 0) {
                    var go = new UnityEngine.GameObject.$ctor3(System.String.format("Renderer{0}", [Bridge.box(i, System.Int32)]), UnityEngine.RectTransform);
                    go.transform.SetParent(this.transform, false);
                    go.transform.localPosition = pc.Vec3.ZERO.clone();
                    var canvasRenderer = go.AddComponent(UnityEngine.CanvasRenderer);
                    this.canvasRenderers.add(canvasRenderer);
                    var submeshGraphic = go.AddComponent(Spine.Unity.SkeletonSubmeshGraphic);
                    submeshGraphic.maskable = this.maskable;
                    submeshGraphic.raycastTarget = false;
                    this.submeshGraphics.add(submeshGraphic);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureCanvasRendererCount end.*/

            /*Spine.Unity.SkeletonGraphic.DisableUnusedCanvasRenderers start.*/
            DisableUnusedCanvasRenderers: function (usedCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DisableUnusedCanvasRenderers", this ); }

                for (var i = usedCount; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    this.canvasRenderers.getItem(i).Clear();
                    this.canvasRenderers.getItem(i).gameObject.SetActive(false);
                }
            },
            /*Spine.Unity.SkeletonGraphic.DisableUnusedCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureMeshesCount start.*/
            EnsureMeshesCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureMeshesCount", this ); }

                var oldCount = this.meshes.Count;
                this.meshes.EnsureCapacity(targetCount);
                for (var i = oldCount; i < targetCount; i = (i + 1) | 0) {
                    this.meshes.Add(Spine.Unity.SpineMesh.NewSkeletonMesh());
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureMeshesCount end.*/

            /*Spine.Unity.SkeletonGraphic.DestroyMeshes start.*/
            DestroyMeshes: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DestroyMeshes", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.meshes);
                try {
                    while ($t.moveNext()) {
                        var mesh = $t.Current;
                        UnityEngine.Object.Destroy(mesh);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.meshes.Clear();
            },
            /*Spine.Unity.SkeletonGraphic.DestroyMeshes end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureSeparatorPartCount start.*/
            EnsureSeparatorPartCount: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureSeparatorPartCount", this ); }

                var targetCount = (this.separatorSlots.Count + 1) | 0;
                if (targetCount === 1) {
                    return;
                }

                var currentCount = this.separatorParts.Count;
                for (var i = currentCount; i < targetCount; i = (i + 1) | 0) {
                    var go = new UnityEngine.GameObject.$ctor3(System.String.format("{0}[{1}]", Spine.Unity.SkeletonGraphic.SeparatorPartGameObjectName, Bridge.box(i, System.Int32)), UnityEngine.RectTransform);
                    go.transform.SetParent(this.transform, false);
                    go.transform.localPosition = pc.Vec3.ZERO.clone();
                    this.separatorParts.add(go.transform);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureSeparatorPartCount end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateSeparatorPartParents start.*/
            UpdateSeparatorPartParents: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateSeparatorPartParents", this ); }

                var usedCount = (this.separatorSlots.Count + 1) | 0;
                if (usedCount === 1) {
                    usedCount = 0; // placed directly at the SkeletonGraphic parent
                    for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                        var canvasRenderer = this.canvasRenderers.getItem(i);
                        if (System.String.contains(canvasRenderer.transform.parent.name,Spine.Unity.SkeletonGraphic.SeparatorPartGameObjectName)) {
                            canvasRenderer.transform.SetParent(this.transform, false);
                            canvasRenderer.transform.localPosition = pc.Vec3.ZERO.clone();
                        }
                    }
                }
                for (var i1 = 0; i1 < this.separatorParts.Count; i1 = (i1 + 1) | 0) {
                    var isUsed = i1 < usedCount;
                    this.separatorParts.getItem(i1).gameObject.SetActive(isUsed);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateSeparatorPartParents end.*/


        },
        overloads: {
            "Update(float)": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonGraphic end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.UpdateBonesDelegate
     * @param   {Spine.Unity.ISkeletonAnimation}    animated
     * @return  {void}
     */


    /*Spine.Unity.SkeletonAnimation start.*/
    Bridge.define("Spine.Unity.SkeletonAnimation", {
        inherits: [Spine.Unity.SkeletonRenderer,Spine.Unity.ISkeletonAnimation,Spine.Unity.IAnimationStateComponent],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonAnimation.AddToGameObject:static start.*/
                /**
                 * Adds and prepares a SkeletonAnimation component to a GameObject at runtime.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonAnimation
                 * @memberof Spine.Unity.SkeletonAnimation
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {Spine.Unity.SkeletonAnimation}                         The newly instantiated SkeletonAnimation
                 */
                AddToGameObject: function (gameObject, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AddToGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.AddSpineComponent(Spine.Unity.SkeletonAnimation, gameObject, skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonAnimation.AddToGameObject:static end.*/

                /*Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject:static start.*/
                /**
                 * Instantiates a new UnityEngine.GameObject and adds a prepared SkeletonAnimation component to it.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonAnimation
                 * @memberof Spine.Unity.SkeletonAnimation
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {Spine.Unity.SkeletonAnimation}                         The newly instantiated SkeletonAnimation component.
                 */
                NewSkeletonAnimationGameObject: function (skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#NewSkeletonAnimationGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.NewSpineGameObject(Spine.Unity.SkeletonAnimation, skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject:static end.*/


            }
        },
        fields: {
            /**
             * This is the Spine.AnimationState object of this SkeletonAnimation. You can control animations through it.
             Note that this object, like .skeleton, is not guaranteed to exist in Awake. Do all accesses and caching to it in Start
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @type Spine.AnimationState
             */
            state: null,
            wasUpdatedAfterInit: false,
            _animationName: null,
            /**
             * Whether or not {@link } should loop. This only applies to the initial animation specified in the inspector, or any subsequent Animations played through .AnimationName. Animations set through state.SetAnimation are unaffected.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @type boolean
             */
            loop: false,
            /**
             * The rate at which animations progress over time. 1 means 100%. 0.5 means 50%.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @default 1
             * @type number
             */
            timeScale: 0
        },
        events: {
            _BeforeApply: null,
            _UpdateLocal: null,
            _UpdateWorld: null,
            _UpdateComplete: null
        },
        props: {
            /**
             * This is the Spine.AnimationState object of this SkeletonAnimation. You can control animations through it.
             Note that this object, like .skeleton, is not guaranteed to exist in Awake. Do all accesses and caching to it in Start
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonAnimation
             * @function AnimationState
             * @type Spine.AnimationState
             */
            AnimationState: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationState#get", this ); }

                    this.Initialize(false);
                    return this.state;
                }
            },
            /**
             * Setting this property sets the animation of the skeleton. If invalid, it will store the animation name for the next time the skeleton is properly initialized.
             Getting this property gets the name of the currently playing animation. If invalid, it will return the last stored animation name set through this property.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @function AnimationName
             * @type string
             */
            AnimationName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationName#get", this ); }

                    if (!this.valid) {
                        return this._animationName;
                    } else {
                        var entry = this.state.getCurrent(0);
                        return entry == null ? null : entry.animation.name;
                    }
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationName#set", this ); }

                    this.Initialize(false);
                    if (Bridge.referenceEquals(this._animationName, value)) {
                        var entry = this.state.getCurrent(0);
                        if (entry != null && entry.loop === this.loop) {
                            return;
                        }
                    }
                    this._animationName = value;

                    if (System.String.isNullOrEmpty(value)) {
                        this.state.clearTrack(0);
                    } else {
                        var animationObject = this.skeletonDataAsset.GetSkeletonData(false).findAnimation(value);
                        if (animationObject != null) {
                            this.state.setAnimationWith( 0, animationObject, this.loop );
                        }
                    }
                }
            }
        },
        alias: [
            "AnimationState", "Spine$Unity$IAnimationStateComponent$AnimationState",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#init", this ); }

                this.wasUpdatedAfterInit = true;
                this.timeScale = 1;
            }
        },
        methods: {
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addBeforeApply", this ); }

                this.add_BeforeApply(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeBeforeApply", this ); }

                this.remove_BeforeApply(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateLocal", this ); }

                this.add_UpdateLocal(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateLocal", this ); }

                this.remove_UpdateLocal(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateWorld", this ); }

                this.add_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateWorld", this ); }

                this.remove_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateComplete", this ); }

                this.add_UpdateComplete(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateComplete", this ); }

                this.remove_UpdateComplete(value);
            },
            /*Spine.Unity.SkeletonAnimation.ClearState start.*/
            /**
             * Clears the previously generated mesh, resets the skeleton's pose, and clears all previously active animations.
             *
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @return  {void}
             */
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#ClearState", this ); }

                Spine.Unity.SkeletonRenderer.prototype.ClearState.call(this);
                if (this.state != null) {
                    this.state.clearTracks();
                }
            },
            /*Spine.Unity.SkeletonAnimation.ClearState end.*/

            /*Spine.Unity.SkeletonAnimation.Initialize start.*/
            /**
             * Initialize this component. Attempts to load the SkeletonData and creates the internal Spine objects and buffers.
             *
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @param   {boolean}    overwrite    If set to <pre><code>true</code></pre>, force overwrite an already initialized object.
             * @param   {boolean}    quiet
             * @return  {void}
             */
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Initialize", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                Spine.Unity.SkeletonRenderer.prototype.Initialize.call(this, overwrite, quiet);

                if (!this.valid) {
                    return;
                }
                this.state = new Spine.AnimationState(this.skeletonDataAsset.GetAnimationStateData());
                this.wasUpdatedAfterInit = false;

                if (!System.String.isNullOrEmpty(this._animationName)) {
                    var animationObject = this.skeletonDataAsset.GetSkeletonData(false).findAnimation(this._animationName);
                    if (animationObject != null) {
                        this.state.setAnimationWith( 0, animationObject, this.loop );
                    }
                }
            },
            /*Spine.Unity.SkeletonAnimation.Initialize end.*/

            /*Spine.Unity.SkeletonAnimation.Update$1 start.*/
            Update$1: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Update$1", this ); }


                this.Update(UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.Update$1 end.*/

            /*Spine.Unity.SkeletonAnimation.Update start.*/
            /**
             * Progresses the AnimationState according to the given deltaTime, and applies it to the Skeleton. Use Time.deltaTime to update manually. Use deltaTime 0 to update without progressing the time.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @param   {number}    deltaTime
             * @return  {void}
             */
            Update: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Update", this ); }

                if (!this.valid || this.state == null) {
                    return;
                }

                this.wasUpdatedAfterInit = true;
                if (this.updateMode < Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.UpdateAnimationStatus(deltaTime);

                if (this.updateMode === Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, false);
                    return;
                }
                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonAnimation.Update end.*/

            /*Spine.Unity.SkeletonAnimation.UpdateAnimationStatus start.*/
            UpdateAnimationStatus: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UpdateAnimationStatus", this ); }

                deltaTime *= this.timeScale;
                this.skeleton.update(deltaTime);
                this.state.update(deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.UpdateAnimationStatus end.*/

            /*Spine.Unity.SkeletonAnimation.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this._BeforeApply, null)) {
                    this._BeforeApply(this);
                }

                if (this.updateMode !== Spine.Unity.UpdateMode.OnlyEventTimelines) {
                    this.state.apply(this.skeleton);
                } else {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, true);
                }

                if (!Bridge.staticEquals(this._UpdateLocal, null)) {
                    this._UpdateLocal(this);
                }

                this.skeleton.updateWorldTransform();

                if (!Bridge.staticEquals(this._UpdateWorld, null)) {
                    this._UpdateWorld(this);
                    this.skeleton.updateWorldTransform();
                }

                if (!Bridge.staticEquals(this._UpdateComplete, null)) {
                    this._UpdateComplete(this);
                }
            },
            /*Spine.Unity.SkeletonAnimation.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonAnimation.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#LateUpdate", this ); }

                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update(0);
                }
                Spine.Unity.SkeletonRenderer.prototype.LateUpdate.call(this);
            },
            /*Spine.Unity.SkeletonAnimation.LateUpdate end.*/

            /*Spine.Unity.SkeletonAnimation.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#OnBecameVisible", this ); }

                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;

                // OnBecameVisible is called after LateUpdate()
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate && previousUpdateMode !== Spine.Unity.UpdateMode.EverythingExceptMesh) {
                    this.Update(0);
                }
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonAnimation.OnBecameVisible end.*/


        },
        overloads: {
            "Update()": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonAnimation end.*/

    /*Spine.Unity.SkeletonMecanim start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim", {
        inherits: [Spine.Unity.SkeletonRenderer,Spine.Unity.ISkeletonAnimation],
        fields: {
            translator: null,
            wasUpdatedAfterInit: false
        },
        events: {
            _BeforeApply: null,
            _UpdateLocal: null,
            _UpdateWorld: null,
            _UpdateComplete: null
        },
        props: {
            Translator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Translator#get", this ); }

                    return this.translator;
                }
            }
        },
        alias: [
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#init", this ); }

                this.wasUpdatedAfterInit = true;
            }
        },
        methods: {
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addBeforeApply", this ); }

                this.add_BeforeApply(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeBeforeApply", this ); }

                this.remove_BeforeApply(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateLocal", this ); }

                this.add_UpdateLocal(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateLocal", this ); }

                this.remove_UpdateLocal(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateWorld", this ); }

                this.add_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateWorld", this ); }

                this.remove_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateComplete", this ); }

                this.add_UpdateComplete(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateComplete", this ); }

                this.remove_UpdateComplete(value);
            },
            /*Spine.Unity.SkeletonMecanim.Initialize start.*/
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Initialize", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                Spine.Unity.SkeletonRenderer.prototype.Initialize.call(this, overwrite, quiet);

                if (!this.valid) {
                    return;
                }

                if (this.translator == null) {
                    this.translator = new Spine.Unity.SkeletonMecanim.MecanimTranslator();
                }
                this.translator.Initialize(this.GetComponent(UnityEngine.Animator), this.skeletonDataAsset);
                this.wasUpdatedAfterInit = false;
            },
            /*Spine.Unity.SkeletonMecanim.Initialize end.*/

            /*Spine.Unity.SkeletonMecanim.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Update", this ); }

                if (!this.valid) {
                    return;
                }

                this.wasUpdatedAfterInit = true;
                // animation status is kept by Mecanim Animator component
                if (this.updateMode <= Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonMecanim.Update end.*/

            /*Spine.Unity.SkeletonMecanim.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this._BeforeApply, null)) {
                    this._BeforeApply(this);
                }

                this.translator.Apply(this.skeleton);

                // UpdateWorldTransform and Bone Callbacks
                {
                    if (!Bridge.staticEquals(this._UpdateLocal, null)) {
                        this._UpdateLocal(this);
                    }

                    this.skeleton.updateWorldTransform();

                    if (!Bridge.staticEquals(this._UpdateWorld, null)) {
                        this._UpdateWorld(this);
                        this.skeleton.updateWorldTransform();
                    }

                    if (!Bridge.staticEquals(this._UpdateComplete, null)) {
                        this._UpdateComplete(this);
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonMecanim.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#LateUpdate", this ); }

                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update();
                }
                Spine.Unity.SkeletonRenderer.prototype.LateUpdate.call(this);
            },
            /*Spine.Unity.SkeletonMecanim.LateUpdate end.*/

            /*Spine.Unity.SkeletonMecanim.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#OnBecameVisible", this ); }

                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;

                // OnBecameVisible is called after LateUpdate()
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate && previousUpdateMode !== Spine.Unity.UpdateMode.EverythingExceptMesh) {
                    this.Update();
                }
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonMecanim.OnBecameVisible end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanim end.*/

    if ( MODULE_reflection ) {
    var $m = Bridge.setMetadata,
        $n = ["System","Spine","Spine.Unity","System.Collections.Generic","UnityEngine","UnityEngine.U2D","UnityEngine.UI","UnityEngine.Rendering","Spine.Unity.AttachmentTools","Do","UnityEngine.Audio","DG.Tweening.Core","DG.Tweening","DG.Tweening.Plugins.Core.PathCore","System.Globalization","DG.Tweening.Plugins.Options"];

    /*MusicType start.*/
    $m("MusicType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Gameplay","is":true,"t":4,"rt":MusicType,"sn":"Gameplay","box":function ($v) { return Bridge.box($v, MusicType, System.Enum.toStringFn(MusicType));}},{"a":2,"n":"Home","is":true,"t":4,"rt":MusicType,"sn":"Home","box":function ($v) { return Bridge.box($v, MusicType, System.Enum.toStringFn(MusicType));}}]}; }, $n);
    /*MusicType end.*/

    /*NutType start.*/
    $m("NutType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Normal","is":true,"t":4,"rt":NutType,"sn":"Normal","box":function ($v) { return Bridge.box($v, NutType, System.Enum.toStringFn(NutType));}},{"a":2,"n":"Square","is":true,"t":4,"rt":NutType,"sn":"Square","box":function ($v) { return Bridge.box($v, NutType, System.Enum.toStringFn(NutType));}},{"a":2,"n":"Star","is":true,"t":4,"rt":NutType,"sn":"Star","box":function ($v) { return Bridge.box($v, NutType, System.Enum.toStringFn(NutType));}}]}; }, $n);
    /*NutType end.*/

    /*ScreenType start.*/
    $m("ScreenType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Horizontal","is":true,"t":4,"rt":ScreenType,"sn":"Horizontal","box":function ($v) { return Bridge.box($v, ScreenType, System.Enum.toStringFn(ScreenType));}},{"a":2,"n":"Vertical","is":true,"t":4,"rt":ScreenType,"sn":"Vertical","box":function ($v) { return Bridge.box($v, ScreenType, System.Enum.toStringFn(ScreenType));}}]}; }, $n);
    /*ScreenType end.*/

    /*SoundType start.*/
    $m("SoundType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Bomb_Defuse","is":true,"t":4,"rt":SoundType,"sn":"Bomb_Defuse","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Bomb_Explore","is":true,"t":4,"rt":SoundType,"sn":"Bomb_Explore","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Booster_Add_Holder","is":true,"t":4,"rt":SoundType,"sn":"Booster_Add_Holder","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Booster_Fill","is":true,"t":4,"rt":SoundType,"sn":"Booster_Fill","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Click_UI","is":true,"t":4,"rt":SoundType,"sn":"Click_UI","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Coin_Collect","is":true,"t":4,"rt":SoundType,"sn":"Coin_Collect","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Complete_Holder_1","is":true,"t":4,"rt":SoundType,"sn":"Complete_Holder_1","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Complete_Holder_2","is":true,"t":4,"rt":SoundType,"sn":"Complete_Holder_2","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Complete_Holder_3","is":true,"t":4,"rt":SoundType,"sn":"Complete_Holder_3","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Done_Progress","is":true,"t":4,"rt":SoundType,"sn":"Done_Progress","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Feature_Anounce","is":true,"t":4,"rt":SoundType,"sn":"Feature_Anounce","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Firework","is":true,"t":4,"rt":SoundType,"sn":"Firework","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Glass_Break","is":true,"t":4,"rt":SoundType,"sn":"Glass_Break","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Hard_Level","is":true,"t":4,"rt":SoundType,"sn":"Hard_Level","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Holder_Close","is":true,"t":4,"rt":SoundType,"sn":"Holder_Close","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Ice_Break","is":true,"t":4,"rt":SoundType,"sn":"Ice_Break","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Island_Build","is":true,"t":4,"rt":SoundType,"sn":"Island_Build","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Island_Complete_1","is":true,"t":4,"rt":SoundType,"sn":"Island_Complete_1","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Island_Complete_2","is":true,"t":4,"rt":SoundType,"sn":"Island_Complete_2","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Lose","is":true,"t":4,"rt":SoundType,"sn":"Lose","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Nut_Go_To_Screw","is":true,"t":4,"rt":SoundType,"sn":"Nut_Go_To_Screw","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Nut_Out_Of_Screw","is":true,"t":4,"rt":SoundType,"sn":"Nut_Out_Of_Screw","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Rope_Cut","is":true,"t":4,"rt":SoundType,"sn":"Rope_Cut","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Rope_Reject","is":true,"t":4,"rt":SoundType,"sn":"Rope_Reject","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Show_Hidden","is":true,"t":4,"rt":SoundType,"sn":"Show_Hidden","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Undo_Move","is":true,"t":4,"rt":SoundType,"sn":"Undo_Move","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Update_Progress","is":true,"t":4,"rt":SoundType,"sn":"Update_Progress","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Use_Booster","is":true,"t":4,"rt":SoundType,"sn":"Use_Booster","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Very_Hard_Level","is":true,"t":4,"rt":SoundType,"sn":"Very_Hard_Level","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Win","is":true,"t":4,"rt":SoundType,"sn":"Win","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}}]}; }, $n);
    /*SoundType end.*/

    /*LunaManager start.*/
    $m("LunaManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"OnPlayButtonClick","t":8,"sn":"OnPlayButtonClick","rt":$n[0].Void},{"a":1,"n":"PauseGameplay","t":8,"sn":"PauseGameplay","rt":$n[0].Void},{"a":1,"n":"ResumeGameplay","t":8,"sn":"ResumeGameplay","rt":$n[0].Void}]}; }, $n);
    /*LunaManager end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    $m("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*Spine.BoneMatrix start.*/
    $m("Spine.BoneMatrix", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[1].Bone],"pi":[{"n":"bone","pt":$n[1].Bone,"ps":0}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[spine.BoneData],"pi":[{"n":"boneData","pt":spine.BoneData,"ps":0}],"sn":"$ctor2"},{"a":2,"n":"CalculateSetupWorld","is":true,"t":8,"pi":[{"n":"boneData","pt":spine.BoneData,"ps":0}],"sn":"CalculateSetupWorld","rt":$n[1].BoneMatrix,"p":[spine.BoneData]},{"a":1,"n":"GetInheritedInternal","is":true,"t":8,"pi":[{"n":"boneData","pt":spine.BoneData,"ps":0},{"n":"parentMatrix","pt":$n[1].BoneMatrix,"ps":1}],"sn":"GetInheritedInternal","rt":$n[1].BoneMatrix,"p":[spine.BoneData,$n[1].BoneMatrix]},{"a":2,"n":"TransformMatrix","t":8,"pi":[{"n":"local","pt":$n[1].BoneMatrix,"ps":0}],"sn":"TransformMatrix","rt":$n[1].BoneMatrix,"p":[$n[1].BoneMatrix]},{"a":2,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"c","t":4,"rt":$n[0].Single,"sn":"c","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"d","t":4,"rt":$n[0].Single,"sn":"d","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.BoneMatrix end.*/

    /*Spine.SpineSkeletonExtensions start.*/
    $m("Spine.SpineSkeletonExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"InheritsRotation","is":true,"t":8,"pi":[{"n":"mode","pt":spine.TransformMode,"ps":0}],"sn":"InheritsRotation","rt":$n[0].Boolean,"p":[spine.TransformMode],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"InheritsScale","is":true,"t":8,"pi":[{"n":"mode","pt":spine.TransformMode,"ps":0}],"sn":"InheritsScale","rt":$n[0].Boolean,"p":[spine.TransformMode],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsWeighted","is":true,"t":8,"pi":[{"n":"va","pt":spine.VertexAttachment,"ps":0}],"sn":"IsWeighted","rt":$n[0].Boolean,"p":[spine.VertexAttachment],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.SpineSkeletonExtensions end.*/

    /*Spine.Unity.AnimationReferenceAsset start.*/
    $m("Spine.Unity.AnimationReferenceAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/Animation Reference Asset", order: 100
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"op_Implicit","is":true,"t":8,"pi":[{"n":"asset","pt":$n[2].AnimationReferenceAsset,"ps":0}],"sn":"op_Implicit","rt":$n[1].Animation,"p":[$n[2].AnimationReferenceAsset]},{"a":2,"n":"Animation","t":16,"rt":$n[1].Animation,"g":{"a":2,"n":"get_Animation","t":8,"rt":$n[1].Animation,"fg":"Animation"},"fn":"Animation"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[2].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[2].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":1,"n":"QuietSkeletonData","is":true,"t":4,"rt":$n[0].Boolean,"sn":"QuietSkeletonData","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"animation","t":4,"rt":$n[1].Animation,"sn":"animation"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":3,"n":"animationName","t":4,"rt":$n[0].String,"sn":"animationName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonDataAsset","t":4,"rt":$n[2].SkeletonDataAsset,"sn":"skeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.AnimationReferenceAsset end.*/

    /*Spine.Unity.AtlasAssetBase start.*/
    $m("Spine.Unity.AtlasAssetBase", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"ab":true,"a":2,"n":"GetAtlas","t":8,"pi":[{"n":"onlyMetaData","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"GetAtlas","rt":$n[1].Atlas,"p":[$n[0].Boolean]},{"ab":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ab":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ab":true,"a":2,"n":"Materials","t":16,"rt":$n[3].IEnumerable$1(UnityEngine.Material),"g":{"ab":true,"a":2,"n":"get_Materials","t":8,"rt":$n[3].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"ab":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[4].Material,"g":{"ab":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[4].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"a":1,"backing":true,"n":"<IsLoaded>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"backing":true,"n":"<MaterialCount>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<Materials>k__BackingField","t":4,"rt":$n[3].IEnumerable$1(UnityEngine.Material),"sn":"Materials"},{"a":1,"backing":true,"n":"<PrimaryMaterial>k__BackingField","t":4,"rt":$n[4].Material,"sn":"PrimaryMaterial"}]}; }, $n);
    /*Spine.Unity.AtlasAssetBase end.*/

    /*Spine.Unity.BlendModeMaterials start.*/
    $m("Spine.Unity.BlendModeMaterials", function () { return {"nested":[$n[2].BlendModeMaterials.ReplacementMaterial],"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ApplyMaterials","t":8,"pi":[{"n":"skeletonData","pt":$n[1].SkeletonData,"ps":0}],"sn":"ApplyMaterials","rt":$n[0].Void,"p":[$n[1].SkeletonData]},{"a":2,"n":"BlendModeForMaterial","t":8,"pi":[{"n":"material","pt":$n[4].Material,"ps":0}],"sn":"BlendModeForMaterial","rt":spine.BlendMode,"p":[$n[4].Material],"box":function ($v) { return Bridge.box($v, spine.BlendMode, System.Enum.toStringFn(spine.BlendMode));}},{"a":3,"n":"CloneAtlasRegionWithMaterial","t":8,"pi":[{"n":"originalRegion","pt":$n[1].AtlasRegion,"ps":0},{"n":"replacementMaterials","pt":$n[3].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"ps":1}],"sn":"CloneAtlasRegionWithMaterial","rt":$n[1].AtlasRegion,"p":[$n[1].AtlasRegion,$n[3].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)]},{"a":2,"n":"RequiresBlendModeMaterials","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_RequiresBlendModeMaterials","t":8,"rt":$n[0].Boolean,"fg":"RequiresBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_RequiresBlendModeMaterials","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"RequiresBlendModeMaterials"},"fn":"RequiresBlendModeMaterials"},{"a":2,"n":"additiveMaterials","t":4,"rt":$n[3].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"additiveMaterials"},{"a":2,"n":"applyAdditiveMaterial","t":4,"rt":$n[0].Boolean,"sn":"applyAdditiveMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"multiplyMaterials","t":4,"rt":$n[3].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"multiplyMaterials"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector()],"a":3,"n":"requiresBlendModeMaterials","t":4,"rt":$n[0].Boolean,"sn":"requiresBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"screenMaterials","t":4,"rt":$n[3].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"screenMaterials"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterials end.*/

    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial start.*/
    $m("Spine.Unity.BlendModeMaterials.ReplacementMaterial", function () { return {"td":$n[2].BlendModeMaterials,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"material","t":4,"rt":$n[4].Material,"sn":"material"},{"a":2,"n":"pageName","t":4,"rt":$n[0].String,"sn":"pageName"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial end.*/

    /*Spine.Unity.EventDataReferenceAsset start.*/
    $m("Spine.Unity.EventDataReferenceAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/EventData Reference Asset", order: 100
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"op_Implicit","is":true,"t":8,"pi":[{"n":"asset","pt":$n[2].EventDataReferenceAsset,"ps":0}],"sn":"op_Implicit","rt":spine.EventData,"p":[$n[2].EventDataReferenceAsset]},{"a":2,"n":"EventData","t":16,"rt":spine.EventData,"g":{"a":2,"n":"get_EventData","t":8,"rt":spine.EventData,"fg":"EventData"},"fn":"EventData"},{"a":1,"n":"QuietSkeletonData","is":true,"t":4,"rt":$n[0].Boolean,"sn":"QuietSkeletonData","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"eventData","t":4,"rt":spine.EventData,"sn":"eventData"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineEvent("", "skeletonDataAsset", true, false, false)],"a":3,"n":"eventName","t":4,"rt":$n[0].String,"sn":"eventName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonDataAsset","t":4,"rt":$n[2].SkeletonDataAsset,"sn":"skeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.EventDataReferenceAsset end.*/

    /*Spine.Unity.RegionlessAttachmentLoader start.*/
    $m("Spine.Unity.RegionlessAttachmentLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"NewBoundingBoxAttachment","t":8,"pi":[{"n":"skin","pt":$n[1].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewBoundingBoxAttachment","rt":spine.BoundingBoxAttachment,"p":[$n[1].Skin,$n[0].String]},{"a":2,"n":"NewClippingAttachment","t":8,"pi":[{"n":"skin","pt":$n[1].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewClippingAttachment","rt":spine.ClippingAttachment,"p":[$n[1].Skin,$n[0].String]},{"a":2,"n":"NewMeshAttachment","t":8,"pi":[{"n":"skin","pt":$n[1].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2}],"sn":"NewMeshAttachment","rt":$n[1].MeshAttachment,"p":[$n[1].Skin,$n[0].String,$n[0].String]},{"a":2,"n":"NewPathAttachment","t":8,"pi":[{"n":"skin","pt":$n[1].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPathAttachment","rt":spine.PathAttachment,"p":[$n[1].Skin,$n[0].String]},{"a":2,"n":"NewPointAttachment","t":8,"pi":[{"n":"skin","pt":$n[1].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPointAttachment","rt":$n[1].PointAttachment,"p":[$n[1].Skin,$n[0].String]},{"a":2,"n":"NewRegionAttachment","t":8,"pi":[{"n":"skin","pt":$n[1].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2}],"sn":"NewRegionAttachment","rt":$n[1].RegionAttachment,"p":[$n[1].Skin,$n[0].String,$n[0].String]},{"a":1,"n":"EmptyRegion","is":true,"t":16,"rt":$n[1].AtlasRegion,"g":{"a":1,"n":"get_EmptyRegion","t":8,"rt":$n[1].AtlasRegion,"fg":"EmptyRegion","is":true},"fn":"EmptyRegion"},{"a":1,"n":"emptyRegion","is":true,"t":4,"rt":$n[1].AtlasRegion,"sn":"emptyRegion"}]}; }, $n);
    /*Spine.Unity.RegionlessAttachmentLoader end.*/

    /*Spine.Unity.SkeletonDataAsset start.*/
    $m("Spine.Unity.SkeletonDataAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New SkeletonDataAsset", menuName: "Spine/SkeletonData Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"skeletonDataFile","pt":$n[4].TextAsset,"ps":0},{"n":"atlasAsset","pt":$n[2].AtlasAssetBase,"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"CreateRuntimeInstance","rt":$n[2].SkeletonDataAsset,"p":[$n[4].TextAsset,$n[2].AtlasAssetBase,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"skeletonDataFile","pt":$n[4].TextAsset,"ps":0},{"n":"atlasAssets","pt":System.Array.type(Spine.Unity.AtlasAssetBase),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"CreateRuntimeInstance$1","rt":$n[2].SkeletonDataAsset,"p":[$n[4].TextAsset,System.Array.type(Spine.Unity.AtlasAssetBase),$n[0].Boolean,$n[0].Single]},{"a":2,"n":"FillStateData","t":8,"sn":"FillStateData","rt":$n[0].Void},{"a":2,"n":"GetAnimationStateData","t":8,"sn":"GetAnimationStateData","rt":spine.AnimationStateData},{"a":4,"n":"GetAtlasArray","t":8,"sn":"GetAtlasArray","rt":System.Array.type(Spine.Atlas)},{"a":2,"n":"GetSkeletonData","t":8,"pi":[{"n":"quiet","pt":$n[0].Boolean,"ps":0}],"sn":"GetSkeletonData","rt":$n[1].SkeletonData,"p":[$n[0].Boolean]},{"a":4,"n":"InitializeWithData","t":8,"pi":[{"n":"sd","pt":$n[1].SkeletonData,"ps":0}],"sn":"InitializeWithData","rt":$n[0].Void,"p":[$n[1].SkeletonData]},{"a":4,"n":"ReadSkeletonData","is":true,"t":8,"pi":[{"n":"bytes","pt":$n[0].Array.type(System.Byte),"ps":0},{"n":"attachmentLoader","pt":$n[1].AttachmentLoader,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadSkeletonData","rt":$n[1].SkeletonData,"p":[$n[0].Array.type(System.Byte),$n[1].AttachmentLoader,$n[0].Single]},{"a":4,"n":"ReadSkeletonData","is":true,"t":8,"pi":[{"n":"text","pt":$n[0].String,"ps":0},{"n":"attachmentLoader","pt":$n[1].AttachmentLoader,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadSkeletonData$1","rt":$n[1].SkeletonData,"p":[$n[0].String,$n[1].AttachmentLoader,$n[0].Single]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"a":2,"n":"atlasAssets","t":4,"rt":System.Array.type(Spine.Unity.AtlasAssetBase),"sn":"atlasAssets"},{"a":2,"n":"blendModeMaterials","t":4,"rt":$n[2].BlendModeMaterials,"sn":"blendModeMaterials"},{"a":2,"n":"controller","t":4,"rt":$n[4].RuntimeAnimatorController,"sn":"controller"},{"a":2,"n":"defaultMix","t":4,"rt":$n[0].Single,"sn":"defaultMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"duration","t":4,"rt":$n[0].Array.type(System.Single),"sn":"duration"},{"at":[new Spine.Unity.SpineAnimation("", "", false, false)],"a":2,"n":"fromAnimation","t":4,"rt":$n[0].Array.type(System.String),"sn":"fromAnimation"},{"a":2,"n":"isUpgradingBlendModeMaterials","t":4,"rt":$n[0].Boolean,"sn":"isUpgradingBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"scale","t":4,"rt":$n[0].Single,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeletonData","t":4,"rt":$n[1].SkeletonData,"sn":"skeletonData"},{"at":[new UnityEngine.TooltipAttribute("Use SkeletonDataModifierAssets to apply changes to the SkeletonData after being loaded, such as apply blend mode Materials to Attachments under slots with special blend modes.")],"a":2,"n":"skeletonDataModifiers","t":4,"rt":$n[3].List$1(Spine.Unity.SkeletonDataModifierAsset),"sn":"skeletonDataModifiers"},{"a":2,"n":"skeletonJSON","t":4,"rt":$n[4].TextAsset,"sn":"skeletonJSON"},{"a":1,"n":"stateData","t":4,"rt":spine.AnimationStateData,"sn":"stateData"},{"at":[new Spine.Unity.SpineAnimation("", "", false, false)],"a":2,"n":"toAnimation","t":4,"rt":$n[0].Array.type(System.String),"sn":"toAnimation"}]}; }, $n);
    /*Spine.Unity.SkeletonDataAsset end.*/

    /*Spine.Unity.SkeletonDataCompatibility start.*/
    $m("Spine.Unity.SkeletonDataCompatibility", function () { return {"nested":[$n[2].SkeletonDataCompatibility.SourceType,$n[2].SkeletonDataCompatibility.VersionInfo,$n[2].SkeletonDataCompatibility.CompatibilityProblemInfo],"att":1048961,"a":2,"s":true}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility end.*/

    /*Spine.Unity.SkeletonDataCompatibility+SourceType start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.SourceType", function () { return {"td":$n[2].SkeletonDataCompatibility,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Binary","is":true,"t":4,"rt":$n[2].SkeletonDataCompatibility.SourceType,"sn":"Binary","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}},{"a":2,"n":"Json","is":true,"t":4,"rt":$n[2].SkeletonDataCompatibility.SourceType,"sn":"Json","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+SourceType end.*/

    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.VersionInfo", function () { return {"td":$n[2].SkeletonDataCompatibility,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"rawVersion","t":4,"rt":$n[0].String,"sn":"rawVersion"},{"a":2,"n":"sourceType","t":4,"rt":$n[2].SkeletonDataCompatibility.SourceType,"sn":"sourceType","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}},{"a":2,"n":"version","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"version"}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo end.*/

    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo", function () { return {"td":$n[2].SkeletonDataCompatibility,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"DescriptionString","t":8,"sn":"DescriptionString","rt":$n[0].String},{"a":2,"n":"actualVersion","t":4,"rt":$n[2].SkeletonDataCompatibility.VersionInfo,"sn":"actualVersion"},{"a":2,"n":"compatibleVersions","t":4,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"sn":"compatibleVersions"},{"a":2,"n":"explicitProblemDescription","t":4,"rt":$n[0].String,"sn":"explicitProblemDescription"}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo end.*/

    /*Spine.Unity.SkeletonDataModifierAsset start.*/
    $m("Spine.Unity.SkeletonDataModifierAsset", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeletonData","pt":$n[1].SkeletonData,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[1].SkeletonData]}]}; }, $n);
    /*Spine.Unity.SkeletonDataModifierAsset end.*/

    /*Spine.Unity.SpineAtlasAsset start.*/
    $m("Spine.Unity.SpineAtlasAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New Spine Atlas Asset", menuName: "Spine/Spine Atlas Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[4].TextAsset,"ps":0},{"n":"materials","pt":System.Array.type(UnityEngine.Material),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2}],"sn":"CreateRuntimeInstance","rt":$n[2].SpineAtlasAsset,"p":[$n[4].TextAsset,System.Array.type(UnityEngine.Material),$n[0].Boolean]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[4].TextAsset,"ps":0},{"n":"textures","pt":System.Array.type(UnityEngine.Texture2D),"ps":1},{"n":"materialPropertySource","pt":$n[4].Material,"ps":2},{"n":"initialize","pt":$n[0].Boolean,"ps":3}],"sn":"CreateRuntimeInstance$1","rt":$n[2].SpineAtlasAsset,"p":[$n[4].TextAsset,System.Array.type(UnityEngine.Texture2D),$n[4].Material,$n[0].Boolean]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[4].TextAsset,"ps":0},{"n":"textures","pt":System.Array.type(UnityEngine.Texture2D),"ps":1},{"n":"shader","pt":$n[4].Shader,"ps":2},{"n":"initialize","pt":$n[0].Boolean,"ps":3}],"sn":"CreateRuntimeInstance$2","rt":$n[2].SpineAtlasAsset,"p":[$n[4].TextAsset,System.Array.type(UnityEngine.Texture2D),$n[4].Shader,$n[0].Boolean]},{"a":2,"n":"GenerateMesh","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"mesh","pt":$n[4].Mesh,"ps":1},{"n":"material","out":true,"pt":$n[4].Material,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"GenerateMesh","rt":$n[4].Mesh,"p":[$n[0].String,$n[4].Mesh,$n[4].Material,$n[0].Single]},{"ov":true,"a":2,"n":"GetAtlas","t":8,"pi":[{"n":"onlyMetaData","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"GetAtlas","rt":$n[1].Atlas,"p":[$n[0].Boolean]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ov":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ov":true,"a":2,"n":"Materials","t":16,"rt":$n[3].IEnumerable$1(UnityEngine.Material),"g":{"ov":true,"a":2,"n":"get_Materials","t":8,"rt":$n[3].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"ov":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[4].Material,"g":{"ov":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[4].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"a":3,"n":"atlas","t":4,"rt":$n[1].Atlas,"sn":"atlas"},{"a":2,"n":"atlasFile","t":4,"rt":$n[4].TextAsset,"sn":"atlasFile"},{"a":2,"n":"materials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materials"}]}; }, $n);
    /*Spine.Unity.SpineAtlasAsset end.*/

    /*Spine.Unity.NoOpTextureLoader start.*/
    $m("Spine.Unity.NoOpTextureLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Load","t":8,"pi":[{"n":"page","pt":$n[1].AtlasPage,"ps":0},{"n":"path","pt":$n[0].String,"ps":1}],"sn":"Load","rt":$n[0].Void,"p":[$n[1].AtlasPage,$n[0].String]},{"a":2,"n":"Unload","t":8,"pi":[{"n":"texture","pt":$n[0].Object,"ps":0}],"sn":"Unload","rt":$n[0].Void,"p":[$n[0].Object]}]}; }, $n);
    /*Spine.Unity.NoOpTextureLoader end.*/

    /*Spine.Unity.MaterialsTextureLoader start.*/
    $m("Spine.Unity.MaterialsTextureLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[2].SpineAtlasAsset],"pi":[{"n":"atlasAsset","pt":$n[2].SpineAtlasAsset,"ps":0}],"sn":"ctor"},{"a":2,"n":"Load","t":8,"pi":[{"n":"page","pt":$n[1].AtlasPage,"ps":0},{"n":"path","pt":$n[0].String,"ps":1}],"sn":"Load","rt":$n[0].Void,"p":[$n[1].AtlasPage,$n[0].String]},{"a":2,"n":"Unload","t":8,"pi":[{"n":"texture","pt":$n[0].Object,"ps":0}],"sn":"Unload","rt":$n[0].Void,"p":[$n[0].Object]},{"a":1,"n":"atlasAsset","t":4,"rt":$n[2].SpineAtlasAsset,"sn":"atlasAsset"}]}; }, $n);
    /*Spine.Unity.MaterialsTextureLoader end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset start.*/
    $m("Spine.Unity.SpineSpriteAtlasAsset", function () { return {"nested":[$n[2].SpineSpriteAtlasAsset.SavedRegionInfo],"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New Spine SpriteAtlas Asset", menuName: "Spine/Spine SpriteAtlas Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AccessPackedSprites","is":true,"t":8,"pi":[{"n":"spriteAtlas","pt":$n[5].SpriteAtlas,"ps":0}],"sn":"AccessPackedSprites","rt":System.Array.type(UnityEngine.Sprite),"p":[$n[5].SpriteAtlas]},{"a":2,"n":"AccessPackedTexture","is":true,"t":8,"pi":[{"n":"sprites","pt":System.Array.type(UnityEngine.Sprite),"ps":0}],"sn":"AccessPackedTexture","rt":$n[4].Texture2D,"p":[System.Array.type(UnityEngine.Sprite)]},{"a":3,"n":"AssignRegionsFromSavedRegions","t":8,"pi":[{"n":"sprites","pt":System.Array.type(UnityEngine.Sprite),"ps":0},{"n":"usedAtlas","pt":$n[1].Atlas,"ps":1}],"sn":"AssignRegionsFromSavedRegions","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Sprite),$n[1].Atlas]},{"ov":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"spriteAtlasFile","pt":$n[5].SpriteAtlas,"ps":0},{"n":"materials","pt":System.Array.type(UnityEngine.Material),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2}],"sn":"CreateRuntimeInstance","rt":$n[2].SpineSpriteAtlasAsset,"p":[$n[5].SpriteAtlas,System.Array.type(UnityEngine.Material),$n[0].Boolean]},{"ov":true,"a":2,"n":"GetAtlas","t":8,"pi":[{"n":"onlyMetaData","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"GetAtlas","rt":$n[1].Atlas,"p":[$n[0].Boolean]},{"a":1,"n":"LoadAtlas","t":8,"pi":[{"n":"spriteAtlas","pt":$n[5].SpriteAtlas,"ps":0}],"sn":"LoadAtlas","rt":$n[1].Atlas,"p":[$n[5].SpriteAtlas]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ov":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ov":true,"a":2,"n":"Materials","t":16,"rt":$n[3].IEnumerable$1(UnityEngine.Material),"g":{"ov":true,"a":2,"n":"get_Materials","t":8,"rt":$n[3].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"ov":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[4].Material,"g":{"ov":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[4].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"a":3,"n":"atlas","t":4,"rt":$n[1].Atlas,"sn":"atlas"},{"a":2,"n":"materials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materials"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"savedRegions","t":4,"rt":System.Array.type(Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo),"sn":"savedRegions"},{"a":2,"n":"spriteAtlasFile","t":4,"rt":$n[5].SpriteAtlas,"sn":"spriteAtlasFile"},{"a":2,"n":"updateRegionsInPlayMode","t":4,"rt":$n[0].Boolean,"sn":"updateRegionsInPlayMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSpriteAtlasAsset end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo start.*/
    $m("Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo", function () { return {"td":$n[2].SpineSpriteAtlasAsset,"att":1056772,"a":3,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"height","t":4,"rt":$n[0].Single,"sn":"height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"packingRotation","t":4,"rt":$n[4].SpritePackingRotation,"sn":"packingRotation","box":function ($v) { return Bridge.box($v, UnityEngine.SpritePackingRotation, System.Enum.toStringFn(UnityEngine.SpritePackingRotation));}},{"a":2,"n":"width","t":4,"rt":$n[0].Single,"sn":"width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo end.*/

    /*Spine.Unity.BoneFollower start.*/
    $m("Spine.Unity.BoneFollower", function () { return {"nested":[$n[2].BoneFollower.AxisOrientation],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/BoneFollower"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoneFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"HandleRebuildRenderer","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[2].SkeletonRenderer,"ps":0}],"sn":"HandleRebuildRenderer","rt":$n[0].Void,"p":[$n[2].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"SetBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetBone","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[2].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[2].SkeletonRenderer,"fg":"SkeletonRenderer"},"s":{"a":2,"n":"set_SkeletonRenderer","t":8,"p":[$n[2].SkeletonRenderer],"rt":$n[0].Void,"fs":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":2,"n":"bone","t":4,"rt":$n[1].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "skeletonRenderer", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"followBoneRotation","t":4,"rt":$n[0].Boolean,"sn":"followBoneRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the target bone's local scale."),new UnityEngine.Serialization.FormerlySerializedAsAttribute("followScale")],"a":2,"n":"followLocalScale","t":4,"rt":$n[0].Boolean,"sn":"followLocalScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Includes the parent bone's lossy world scale. BoneFollower cannot inherit rotated/skewed scale because of UnityEngine.Transform property limitations.")],"a":2,"n":"followParentWorldScale","t":4,"rt":$n[0].Boolean,"sn":"followParentWorldScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the skeleton's flip state by controlling this Transform's local scale.")],"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followXYPosition","t":4,"rt":$n[0].Boolean,"sn":"followXYPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followZPosition","t":4,"rt":$n[0].Boolean,"sn":"followZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("resetOnAwake")],"a":2,"n":"initializeOnAwake","t":4,"rt":$n[0].Boolean,"sn":"initializeOnAwake","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Applies when 'Follow Skeleton Flip' is disabled but 'Follow Bone Rotation' is enabled. When flipping the skeleton by scaling its Transform, this follower's rotation is adjusted instead of its scale to follow the bone orientation. When one of the axes is flipped,  only one axis can be followed, either the X or the Y axis, which is selected here.")],"a":2,"n":"maintainedAxisOrientation","t":4,"rt":$n[2].BoneFollower.AxisOrientation,"sn":"maintainedAxisOrientation","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[2].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[4].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoneFollower end.*/

    /*Spine.Unity.BoneFollower+AxisOrientation start.*/
    $m("Spine.Unity.BoneFollower.AxisOrientation", function () { return {"td":$n[2].BoneFollower,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"XAxis","is":true,"t":4,"rt":$n[2].BoneFollower.AxisOrientation,"sn":"XAxis","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"YAxis","is":true,"t":4,"rt":$n[2].BoneFollower.AxisOrientation,"sn":"YAxis","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}}]}; }, $n);
    /*Spine.Unity.BoneFollower+AxisOrientation end.*/

    /*Spine.Unity.BoneFollowerGraphic start.*/
    $m("Spine.Unity.BoneFollowerGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.AddComponentMenu.ctor("Spine/UI/BoneFollowerGraphic"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoneFollowerGraphic")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"SetBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetBone","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SkeletonGraphic","t":16,"rt":$n[2].SkeletonGraphic,"g":{"a":2,"n":"get_SkeletonGraphic","t":8,"rt":$n[2].SkeletonGraphic,"fg":"SkeletonGraphic"},"s":{"a":2,"n":"set_SkeletonGraphic","t":8,"p":[$n[2].SkeletonGraphic],"rt":$n[0].Void,"fs":"SkeletonGraphic"},"fn":"SkeletonGraphic"},{"a":2,"n":"bone","t":4,"rt":$n[1].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "skeletonGraphic", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"followBoneRotation","t":4,"rt":$n[0].Boolean,"sn":"followBoneRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the target bone's local scale.")],"a":2,"n":"followLocalScale","t":4,"rt":$n[0].Boolean,"sn":"followLocalScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Includes the parent bone's lossy world scale. BoneFollower cannot inherit rotated/skewed scale because of UnityEngine.Transform property limitations.")],"a":2,"n":"followParentWorldScale","t":4,"rt":$n[0].Boolean,"sn":"followParentWorldScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the skeleton's flip state by controlling this Transform's local scale.")],"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followXYPosition","t":4,"rt":$n[0].Boolean,"sn":"followXYPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followZPosition","t":4,"rt":$n[0].Boolean,"sn":"followZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initializeOnAwake","t":4,"rt":$n[0].Boolean,"sn":"initializeOnAwake","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Applies when 'Follow Skeleton Flip' is disabled but 'Follow Bone Rotation' is enabled. When flipping the skeleton by scaling its Transform, this follower's rotation is adjusted instead of its scale to follow the bone orientation. When one of the axes is flipped,  only one axis can be followed, either the X or the Y axis, which is selected here.")],"a":2,"n":"maintainedAxisOrientation","t":4,"rt":$n[2].BoneFollower.AxisOrientation,"sn":"maintainedAxisOrientation","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[2].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[4].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoneFollowerGraphic end.*/

    /*Spine.Unity.BoundingBoxFollower start.*/
    $m("Spine.Unity.BoundingBoxFollower", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoundingBoxFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddCollidersForSkin","t":8,"pi":[{"n":"skin","pt":$n[1].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"previousColliders","pt":System.Array.type(UnityEngine.PolygonCollider2D),"ps":2},{"n":"collidersCount","ref":true,"pt":$n[0].Int32,"ps":3}],"sn":"AddCollidersForSkin","rt":$n[0].Void,"p":[$n[1].Skin,$n[0].Int32,System.Array.type(UnityEngine.PolygonCollider2D),$n[0].Int32]},{"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":1,"n":"DisposeExcessCollidersAfter","t":8,"pi":[{"n":"requiredCount","pt":$n[0].Int32,"ps":0}],"sn":"DisposeExcessCollidersAfter","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"HandleRebuild","t":8,"pi":[{"n":"sr","pt":$n[2].SkeletonRenderer,"ps":0}],"sn":"HandleRebuild","rt":$n[0].Void,"p":[$n[2].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"MatchAttachment","t":8,"pi":[{"n":"attachment","pt":spine.Attachment,"ps":0}],"sn":"MatchAttachment","rt":$n[0].Void,"p":[spine.Attachment]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"CurrentAttachment","t":16,"rt":spine.BoundingBoxAttachment,"g":{"a":2,"n":"get_CurrentAttachment","t":8,"rt":spine.BoundingBoxAttachment,"fg":"CurrentAttachment"},"fn":"CurrentAttachment"},{"a":2,"n":"CurrentAttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_CurrentAttachmentName","t":8,"rt":$n[0].String,"fg":"CurrentAttachmentName"},"fn":"CurrentAttachmentName"},{"a":2,"n":"CurrentCollider","t":16,"rt":$n[4].PolygonCollider2D,"g":{"a":2,"n":"get_CurrentCollider","t":8,"rt":$n[4].PolygonCollider2D,"fg":"CurrentCollider"},"fn":"CurrentCollider"},{"a":2,"n":"IsTrigger","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsTrigger","t":8,"rt":$n[0].Boolean,"fg":"IsTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsTrigger"},{"a":2,"n":"Slot","t":16,"rt":$n[1].Slot,"g":{"a":2,"n":"get_Slot","t":8,"rt":$n[1].Slot,"fg":"Slot"},"fn":"Slot"},{"a":4,"n":"DebugMessages","is":true,"t":4,"rt":$n[0].Boolean,"sn":"DebugMessages","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"colliderTable","t":4,"rt":$n[3].Dictionary$2(spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D),"sn":"colliderTable","ro":true},{"a":1,"n":"currentAttachment","t":4,"rt":spine.BoundingBoxAttachment,"sn":"currentAttachment"},{"a":1,"n":"currentAttachmentName","t":4,"rt":$n[0].String,"sn":"currentAttachmentName"},{"a":1,"n":"currentCollider","t":4,"rt":$n[4].PolygonCollider2D,"sn":"currentCollider"},{"a":2,"n":"isTrigger","t":4,"rt":$n[0].Boolean,"sn":"isTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nameTable","t":4,"rt":$n[3].Dictionary$2(spine.BoundingBoxAttachment,System.String),"sn":"nameTable","ro":true},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[2].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"slot","t":4,"rt":$n[1].Slot,"sn":"slot"},{"at":[new Spine.Unity.SpineSlot("", "skeletonRenderer", true, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":2,"n":"usedByComposite","t":4,"rt":$n[0].Boolean,"sn":"usedByComposite","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"usedByEffector","t":4,"rt":$n[0].Boolean,"sn":"usedByEffector","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoundingBoxFollower end.*/

    /*Spine.Unity.BoundingBoxFollowerGraphic start.*/
    $m("Spine.Unity.BoundingBoxFollowerGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoundingBoxFollowerGraphic")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddCollidersForSkin","t":8,"pi":[{"n":"skin","pt":$n[1].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"previousColliders","pt":System.Array.type(UnityEngine.PolygonCollider2D),"ps":2},{"n":"scale","pt":$n[0].Single,"ps":3},{"n":"collidersCount","ref":true,"pt":$n[0].Int32,"ps":4}],"sn":"AddCollidersForSkin","rt":$n[0].Void,"p":[$n[1].Skin,$n[0].Int32,System.Array.type(UnityEngine.PolygonCollider2D),$n[0].Single,$n[0].Int32]},{"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":1,"n":"DisposeExcessCollidersAfter","t":8,"pi":[{"n":"requiredCount","pt":$n[0].Int32,"ps":0}],"sn":"DisposeExcessCollidersAfter","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"HandleRebuild","t":8,"pi":[{"n":"sr","pt":$n[2].SkeletonGraphic,"ps":0}],"sn":"HandleRebuild","rt":$n[0].Void,"p":[$n[2].SkeletonGraphic]},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"MatchAttachment","t":8,"pi":[{"n":"attachment","pt":spine.Attachment,"ps":0}],"sn":"MatchAttachment","rt":$n[0].Void,"p":[spine.Attachment]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"CurrentAttachment","t":16,"rt":spine.BoundingBoxAttachment,"g":{"a":2,"n":"get_CurrentAttachment","t":8,"rt":spine.BoundingBoxAttachment,"fg":"CurrentAttachment"},"fn":"CurrentAttachment"},{"a":2,"n":"CurrentAttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_CurrentAttachmentName","t":8,"rt":$n[0].String,"fg":"CurrentAttachmentName"},"fn":"CurrentAttachmentName"},{"a":2,"n":"CurrentCollider","t":16,"rt":$n[4].PolygonCollider2D,"g":{"a":2,"n":"get_CurrentCollider","t":8,"rt":$n[4].PolygonCollider2D,"fg":"CurrentCollider"},"fn":"CurrentCollider"},{"a":2,"n":"IsTrigger","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsTrigger","t":8,"rt":$n[0].Boolean,"fg":"IsTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsTrigger"},{"a":2,"n":"Slot","t":16,"rt":$n[1].Slot,"g":{"a":2,"n":"get_Slot","t":8,"rt":$n[1].Slot,"fg":"Slot"},"fn":"Slot"},{"a":4,"n":"DebugMessages","is":true,"t":4,"rt":$n[0].Boolean,"sn":"DebugMessages","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"colliderTable","t":4,"rt":$n[3].Dictionary$2(spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D),"sn":"colliderTable","ro":true},{"a":1,"n":"currentAttachment","t":4,"rt":spine.BoundingBoxAttachment,"sn":"currentAttachment"},{"a":1,"n":"currentAttachmentName","t":4,"rt":$n[0].String,"sn":"currentAttachmentName"},{"a":1,"n":"currentCollider","t":4,"rt":$n[4].PolygonCollider2D,"sn":"currentCollider"},{"a":2,"n":"isTrigger","t":4,"rt":$n[0].Boolean,"sn":"isTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nameTable","t":4,"rt":$n[3].Dictionary$2(spine.BoundingBoxAttachment,System.String),"sn":"nameTable","ro":true},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[2].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":1,"n":"slot","t":4,"rt":$n[1].Slot,"sn":"slot"},{"at":[new Spine.Unity.SpineSlot("", "skeletonGraphic", true, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":2,"n":"usedByComposite","t":4,"rt":$n[0].Boolean,"sn":"usedByComposite","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"usedByEffector","t":4,"rt":$n[0].Boolean,"sn":"usedByEffector","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoundingBoxFollowerGraphic end.*/

    /*Spine.Unity.PointFollower start.*/
    $m("Spine.Unity.PointFollower", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/Point Follower"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#PointFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"HandleRebuildRenderer","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[2].SkeletonRenderer,"ps":0}],"sn":"HandleRebuildRenderer","rt":$n[0].Void,"p":[$n[2].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"UpdateReferences","t":8,"sn":"UpdateReferences","rt":$n[0].Void},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"SkeletonComponent","t":16,"rt":$n[2].ISkeletonComponent,"g":{"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[2].ISkeletonComponent,"fg":"SkeletonComponent"},"fn":"SkeletonComponent"},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[2].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[2].SkeletonRenderer,"fg":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":1,"n":"bone","t":4,"rt":$n[1].Bone,"sn":"bone"},{"a":2,"n":"followRotation","t":4,"rt":$n[0].Boolean,"sn":"followRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followSkeletonZPosition","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"point","t":4,"rt":$n[1].PointAttachment,"sn":"point"},{"at":[new Spine.Unity.SpineAttachment(true, false, false, "slotName", "skeletonRenderer", "", true, true)],"a":2,"n":"pointAttachmentName","t":4,"rt":$n[0].String,"sn":"pointAttachmentName"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[2].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[4].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSlot("", "skeletonRenderer", false, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":1,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.PointFollower end.*/

    /*Spine.Unity.SkeletonSubmeshGraphic start.*/
    $m("Spine.Unity.SkeletonSubmeshGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.CanvasRenderer)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"OnPopulateMesh","t":8,"pi":[{"n":"vh","pt":$n[6].VertexHelper,"ps":0}],"sn":"OnPopulateMesh","rt":$n[0].Void,"p":[$n[6].VertexHelper]},{"ov":true,"a":2,"n":"SetMaterialDirty","t":8,"sn":"SetMaterialDirty","rt":$n[0].Void},{"ov":true,"a":2,"n":"SetVerticesDirty","t":8,"sn":"SetVerticesDirty","rt":$n[0].Void}]}; }, $n);
    /*Spine.Unity.SkeletonSubmeshGraphic end.*/

    /*Spine.Unity.SkeletonMecanimRootMotion start.*/
    $m("Spine.Unity.SkeletonMecanimRootMotion", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonMecanimRootMotion")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[4].Vector2},{"ov":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"layerIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[4].Vector2,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"layerIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[2].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"a":1,"n":"OnClipApplied","t":8,"pi":[{"n":"animation","pt":$n[1].Animation,"ps":0},{"n":"layerIndex","pt":$n[0].Int32,"ps":1},{"n":"weight","pt":$n[0].Single,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"lastTime","pt":$n[0].Single,"ps":4},{"n":"playsBackward","pt":$n[0].Boolean,"ps":5}],"sn":"OnClipApplied","rt":$n[0].Void,"p":[$n[1].Animation,$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"ov":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"SkeletonMecanim","t":16,"rt":$n[2].SkeletonMecanim,"g":{"a":2,"n":"get_SkeletonMecanim","t":8,"rt":$n[2].SkeletonMecanim,"fg":"SkeletonMecanim"},"fn":"SkeletonMecanim"},{"a":1,"n":"DefaultMecanimLayerFlags","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultMecanimLayerFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"mecanimLayerFlags","t":4,"rt":$n[0].Int32,"sn":"mecanimLayerFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"movementDelta","t":4,"rt":$n[4].Vector2,"sn":"movementDelta"},{"a":1,"n":"skeletonMecanim","t":4,"rt":$n[2].SkeletonMecanim,"sn":"skeletonMecanim"}]}; }, $n);
    /*Spine.Unity.SkeletonMecanimRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotion start.*/
    $m("Spine.Unity.SkeletonRootMotion", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRootMotion")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"ApplyMixAlphaToDelta","t":8,"pi":[{"n":"currentDelta","ref":true,"pt":$n[4].Vector2,"ps":0},{"n":"next","pt":$n[1].TrackEntry,"ps":1},{"n":"track","pt":$n[1].TrackEntry,"ps":2}],"sn":"ApplyMixAlphaToDelta","rt":$n[0].Void,"p":[$n[4].Vector2,$n[1].TrackEntry,$n[1].TrackEntry]},{"ov":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[4].Vector2},{"ov":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[4].Vector2,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[2].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"ov":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"ov":true,"a":3,"n":"AdditionalScale","t":16,"rt":$n[0].Single,"g":{"ov":true,"a":3,"n":"get_AdditionalScale","t":8,"rt":$n[0].Single,"fg":"AdditionalScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AdditionalScale"},{"a":1,"n":"DefaultAnimationTrackFlags","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultAnimationTrackFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"animationState","t":4,"rt":$n[1].AnimationState,"sn":"animationState"},{"a":2,"n":"animationTrackFlags","t":4,"rt":$n[0].Int32,"sn":"animationTrackFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"canvas","t":4,"rt":$n[4].Canvas,"sn":"canvas"}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotionBase start.*/
    $m("Spine.Unity.SkeletonRootMotionBase", function () { return {"nested":[$n[2].SkeletonRootMotionBase.RootMotionInfo],"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AdjustRootMotionToDistance","t":8,"pi":[{"n":"distanceToTarget","pt":$n[4].Vector2,"ps":0},{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"adjustX","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"adjustY","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"minX","dv":0.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"maxX","dv":3.40282347E+38,"o":true,"pt":$n[0].Single,"ps":5},{"n":"minY","dv":0.0,"o":true,"pt":$n[0].Single,"ps":6},{"n":"maxY","dv":3.40282347E+38,"o":true,"pt":$n[0].Single,"ps":7},{"n":"allowXTranslation","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"allowYTranslation","dv":false,"o":true,"pt":$n[0].Boolean,"ps":9}],"sn":"AdjustRootMotionToDistance","rt":$n[0].Void,"p":[$n[4].Vector2,$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"ApplyRootMotion","t":8,"pi":[{"n":"skeletonDelta","pt":$n[4].Vector2,"ps":0},{"n":"parentBoneScale","pt":$n[4].Vector2,"ps":1}],"sn":"ApplyRootMotion","rt":$n[0].Void,"p":[$n[4].Vector2,$n[4].Vector2]},{"ab":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[4].Vector2},{"a":1,"n":"ClearEffectiveBoneOffsets","t":8,"pi":[{"n":"parentBoneScale","pt":$n[4].Vector2,"ps":0}],"sn":"ClearEffectiveBoneOffsets","rt":$n[0].Void,"p":[$n[4].Vector2]},{"a":3,"n":"FindRigidbodyComponent","t":8,"sn":"FindRigidbodyComponent","rt":$n[0].Void},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"GatherTopLevelBones","t":8,"sn":"GatherTopLevelBones","rt":$n[0].Void},{"a":2,"n":"GetAnimationRootMotion","t":8,"pi":[{"n":"animation","pt":$n[1].Animation,"ps":0}],"sn":"GetAnimationRootMotion","rt":$n[4].Vector2,"p":[$n[1].Animation]},{"a":2,"n":"GetAnimationRootMotion","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"animation","pt":$n[1].Animation,"ps":2}],"sn":"GetAnimationRootMotion$1","rt":$n[4].Vector2,"p":[$n[0].Single,$n[0].Single,$n[1].Animation]},{"a":2,"n":"GetAnimationRootMotionInfo","t":8,"pi":[{"n":"animation","pt":$n[1].Animation,"ps":0},{"n":"currentTime","pt":$n[0].Single,"ps":1}],"sn":"GetAnimationRootMotionInfo","rt":$n[2].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[1].Animation,$n[0].Single]},{"ab":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[4].Vector2,"p":[$n[0].Int32]},{"ab":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[2].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"a":1,"n":"GetScaleAffectingRootMotion","t":8,"sn":"GetScaleAffectingRootMotion","rt":$n[4].Vector2},{"a":1,"n":"GetScaleAffectingRootMotion","t":8,"pi":[{"n":"parentBoneScale","out":true,"pt":$n[4].Vector2,"ps":0}],"sn":"GetScaleAffectingRootMotion$1","rt":$n[4].Vector2,"p":[$n[4].Vector2]},{"a":1,"n":"GetSkeletonSpaceMovementDelta","t":8,"pi":[{"n":"boneLocalDelta","pt":$n[4].Vector2,"ps":0},{"n":"parentBoneScale","out":true,"pt":$n[4].Vector2,"ps":1}],"sn":"GetSkeletonSpaceMovementDelta","rt":$n[4].Vector2,"p":[$n[4].Vector2,$n[4].Vector2]},{"a":1,"n":"GetTimelineMovementDelta","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"timeline","pt":spine.TranslateTimeline,"ps":2},{"n":"animation","pt":$n[1].Animation,"ps":3}],"sn":"GetTimelineMovementDelta","rt":$n[4].Vector2,"p":[$n[0].Single,$n[0].Single,spine.TranslateTimeline,$n[1].Animation]},{"a":1,"n":"GetTimelineMovementDelta","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"xTimeline","pt":spine.TranslateXTimeline,"ps":2},{"n":"yTimeline","pt":spine.TranslateYTimeline,"ps":3},{"n":"animation","pt":$n[1].Animation,"ps":4}],"sn":"GetTimelineMovementDelta$1","rt":$n[4].Vector2,"p":[$n[0].Single,$n[0].Single,spine.TranslateXTimeline,spine.TranslateYTimeline,$n[1].Animation]},{"a":1,"n":"HandleUpdateLocal","t":8,"pi":[{"n":"animatedSkeletonComponent","pt":$n[2].ISkeletonAnimation,"ps":0}],"sn":"HandleUpdateLocal","rt":$n[0].Void,"p":[$n[2].ISkeletonAnimation]},{"v":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"v":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":1,"n":"SetEffectiveBoneOffsetsTo","t":8,"pi":[{"n":"displacementSkeletonSpace","pt":$n[4].Vector2,"ps":0},{"n":"parentBoneScale","pt":$n[4].Vector2,"ps":1}],"sn":"SetEffectiveBoneOffsetsTo","rt":$n[0].Void,"p":[$n[4].Vector2,$n[4].Vector2]},{"a":2,"n":"SetRootMotionBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetRootMotionBone","rt":$n[0].Void,"p":[$n[0].String]},{"v":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"v":true,"a":3,"n":"AdditionalScale","t":16,"rt":$n[0].Single,"g":{"v":true,"a":3,"n":"get_AdditionalScale","t":8,"rt":$n[0].Single,"fg":"AdditionalScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AdditionalScale"},{"a":2,"n":"UsesRigidbody","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UsesRigidbody","t":8,"rt":$n[0].Boolean,"fg":"UsesRigidbody","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"UsesRigidbody"},{"a":2,"n":"applyRigidbody2DGravity","t":4,"rt":$n[0].Boolean,"sn":"applyRigidbody2DGravity","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"initialOffset","t":4,"rt":$n[4].Vector2,"sn":"initialOffset"},{"a":2,"n":"rigidBody","t":4,"rt":$n[4].Rigidbody,"sn":"rigidBody"},{"at":[new UnityEngine.HeaderAttribute("Optional")],"a":2,"n":"rigidBody2D","t":4,"rt":$n[4].Rigidbody2D,"sn":"rigidBody2D"},{"a":3,"n":"rigidbodyDisplacement","t":4,"rt":$n[4].Vector2,"sn":"rigidbodyDisplacement"},{"a":3,"n":"rootMotionBone","t":4,"rt":$n[1].Bone,"sn":"rootMotionBone"},{"a":3,"n":"rootMotionBoneIndex","t":4,"rt":$n[0].Int32,"sn":"rootMotionBoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new Spine.Unity.SpineBone("", "", true, false),new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"rootMotionBoneName","t":4,"rt":$n[0].String,"sn":"rootMotionBoneName"},{"a":2,"n":"rootMotionScaleX","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionScaleY","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionTranslateXPerY","t":4,"rt":$n[0].Single,"sn":"rootMotionTranslateXPerY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionTranslateYPerX","t":4,"rt":$n[0].Single,"sn":"rootMotionTranslateYPerX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"skeletonComponent","t":4,"rt":$n[2].ISkeletonComponent,"sn":"skeletonComponent"},{"a":3,"n":"tempSkeletonDisplacement","t":4,"rt":$n[4].Vector2,"sn":"tempSkeletonDisplacement"},{"a":3,"n":"topLevelBones","t":4,"rt":$n[3].List$1(Spine.Bone),"sn":"topLevelBones"},{"a":2,"n":"transformPositionX","t":4,"rt":$n[0].Boolean,"sn":"transformPositionX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"transformPositionY","t":4,"rt":$n[0].Boolean,"sn":"transformPositionY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotionBase end.*/

    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo start.*/
    $m("Spine.Unity.SkeletonRootMotionBase.RootMotionInfo", function () { return {"td":$n[2].SkeletonRootMotionBase,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"current","t":4,"rt":$n[4].Vector2,"sn":"current"},{"a":2,"n":"end","t":4,"rt":$n[4].Vector2,"sn":"end"},{"a":2,"n":"mid","t":4,"rt":$n[4].Vector2,"sn":"mid"},{"a":2,"n":"start","t":4,"rt":$n[4].Vector2,"sn":"start"},{"a":2,"n":"timeIsPastMid","t":4,"rt":$n[0].Boolean,"sn":"timeIsPastMid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo end.*/

    /*Spine.Unity.SkeletonAnimation start.*/
    $m("Spine.Unity.SkeletonAnimation", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonAnimation"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonAnimation-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddToGameObject","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[4].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[2].SkeletonDataAsset,"ps":1},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"AddToGameObject","rt":$n[2].SkeletonAnimation,"p":[$n[4].GameObject,$n[2].SkeletonDataAsset,$n[0].Boolean]},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"ov":true,"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"ov":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"ov":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"NewSkeletonAnimationGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[2].SkeletonDataAsset,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"NewSkeletonAnimationGameObject","rt":$n[2].SkeletonAnimation,"p":[$n[2].SkeletonDataAsset,$n[0].Boolean]},{"ov":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update$1","rt":$n[0].Void},{"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimationStatus","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"UpdateAnimationStatus","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"AnimationName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AnimationName","t":8,"rt":$n[0].String,"fg":"AnimationName"},"s":{"a":2,"n":"set_AnimationName","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AnimationName"},"fn":"AnimationName"},{"a":2,"n":"AnimationState","t":16,"rt":$n[1].AnimationState,"g":{"a":2,"n":"get_AnimationState","t":8,"rt":$n[1].AnimationState,"fg":"AnimationState"},"fn":"AnimationState"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"_animationName","t":4,"rt":$n[0].String,"sn":"_animationName"},{"a":2,"n":"loop","t":4,"rt":$n[0].Boolean,"sn":"loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"state","t":4,"rt":$n[1].AnimationState,"sn":"state"},{"a":2,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_BeforeApply","t":2,"ad":{"a":3,"n":"add__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_BeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_BeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateComplete","t":2,"ad":{"a":3,"n":"add__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateLocal","t":2,"ad":{"a":3,"n":"add__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateWorld","t":2,"ad":{"a":3,"n":"add__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonAnimation end.*/

    /*Spine.Unity.SkeletonGraphic start.*/
    $m("Spine.Unity.SkeletonGraphic", function () { return {"nested":[Function],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.$ctor1(UnityEngine.CanvasRenderer, UnityEngine.RectTransform),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonGraphic (Unity UI Canvas)"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonGraphic-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddSkeletonGraphicComponent","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[4].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[2].SkeletonDataAsset,"ps":1},{"n":"material","pt":$n[4].Material,"ps":2}],"sn":"AddSkeletonGraphicComponent","rt":$n[2].SkeletonGraphic,"p":[$n[4].GameObject,$n[2].SkeletonDataAsset,$n[4].Material]},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"ov":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":3,"n":"DestroyMeshes","t":8,"sn":"DestroyMeshes","rt":$n[0].Void},{"a":3,"n":"DisableUnusedCanvasRenderers","t":8,"pi":[{"n":"usedCount","pt":$n[0].Int32,"ps":0}],"sn":"DisableUnusedCanvasRenderers","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"DisposeMeshBuffers","t":8,"sn":"DisposeMeshBuffers","rt":$n[0].Void},{"a":3,"n":"EnsureCanvasRendererCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureCanvasRendererCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"EnsureMeshesCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureMeshesCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"EnsureSeparatorPartCount","t":8,"sn":"EnsureSeparatorPartCount","rt":$n[0].Void},{"a":2,"n":"GetLastMesh","t":8,"sn":"GetLastMesh","rt":$n[4].Mesh},{"a":2,"n":"HasMultipleSubmeshInstructions","t":8,"sn":"HasMultipleSubmeshInstructions","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"InitMeshBuffers","t":8,"sn":"InitMeshBuffers","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":3,"n":"MatchRectTransformMultipleRenderers","t":8,"sn":"MatchRectTransformMultipleRenderers","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"MatchRectTransformSingleRenderer","t":8,"sn":"MatchRectTransformSingleRenderer","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"MatchRectTransformWithBounds","t":8,"sn":"MatchRectTransformWithBounds","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"NewSkeletonGraphicGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[2].SkeletonDataAsset,"ps":0},{"n":"parent","pt":$n[4].Transform,"ps":1},{"n":"material","pt":$n[4].Material,"ps":2}],"sn":"NewSkeletonGraphicGameObject","rt":$n[2].SkeletonGraphic,"p":[$n[2].SkeletonDataAsset,$n[4].Transform,$n[4].Material]},{"a":2,"n":"OnBecameInvisible","t":8,"sn":"OnBecameInvisible","rt":$n[0].Void},{"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"a":3,"n":"OnCullStateChanged","t":8,"pi":[{"n":"culled","pt":$n[0].Boolean,"ps":0}],"sn":"OnCullStateChanged","rt":$n[0].Void,"p":[$n[0].Boolean]},{"ov":true,"a":3,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"ReapplySeparatorSlotNames","t":8,"sn":"ReapplySeparatorSlotNames","rt":$n[0].Void},{"ov":true,"a":2,"n":"Rebuild","t":8,"pi":[{"n":"update","pt":$n[6].CanvasUpdate,"ps":0}],"sn":"Rebuild","rt":$n[0].Void,"p":[$n[6].CanvasUpdate]},{"a":1,"n":"SetRectTransformBounds","t":8,"pi":[{"n":"combinedBounds","pt":$n[4].Bounds,"ps":0}],"sn":"SetRectTransformBounds","rt":$n[0].Void,"p":[$n[4].Bounds]},{"a":3,"n":"SyncSubmeshGraphicsWithCanvasRenderers","t":8,"sn":"SyncSubmeshGraphicsWithCanvasRenderers","rt":$n[0].Void},{"a":2,"n":"TrimRenderers","t":8,"sn":"TrimRenderers","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update$1","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimationStatus","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"UpdateAnimationStatus","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"UpdateMesh","t":8,"pi":[{"n":"keepRendererCount","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"UpdateMesh","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":3,"n":"UpdateMeshMultipleCanvasRenderers","t":8,"pi":[{"n":"currentInstructions","pt":$n[2].SkeletonRendererInstruction,"ps":0},{"n":"keepRendererCount","pt":$n[0].Boolean,"ps":1}],"sn":"UpdateMeshMultipleCanvasRenderers","rt":$n[0].Void,"p":[$n[2].SkeletonRendererInstruction,$n[0].Boolean]},{"a":3,"n":"UpdateMeshSingleCanvasRenderer","t":8,"sn":"UpdateMeshSingleCanvasRenderer","rt":$n[0].Void},{"a":3,"n":"UpdateSeparatorPartParents","t":8,"sn":"UpdateSeparatorPartParents","rt":$n[0].Void},{"a":2,"n":"AnimationState","t":16,"rt":$n[1].AnimationState,"g":{"a":2,"n":"get_AnimationState","t":8,"rt":$n[1].AnimationState,"fg":"AnimationState"},"fn":"AnimationState"},{"a":2,"n":"CustomMaterialOverride","t":16,"rt":$n[3].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"g":{"a":2,"n":"get_CustomMaterialOverride","t":8,"rt":$n[3].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"fg":"CustomMaterialOverride"},"fn":"CustomMaterialOverride"},{"a":2,"n":"CustomTextureOverride","t":16,"rt":$n[3].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"g":{"a":2,"n":"get_CustomTextureOverride","t":8,"rt":$n[3].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"fg":"CustomTextureOverride"},"fn":"CustomTextureOverride"},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"MeshGenerator","t":16,"rt":$n[2].MeshGenerator,"g":{"a":2,"n":"get_MeshGenerator","t":8,"rt":$n[2].MeshGenerator,"fg":"MeshGenerator"},"fn":"MeshGenerator"},{"a":2,"n":"OverrideTexture","t":16,"rt":$n[4].Texture,"g":{"a":2,"n":"get_OverrideTexture","t":8,"rt":$n[4].Texture,"fg":"OverrideTexture"},"s":{"a":2,"n":"set_OverrideTexture","t":8,"p":[$n[4].Texture],"rt":$n[0].Void,"fs":"OverrideTexture"},"fn":"OverrideTexture"},{"a":2,"n":"SeparatorParts","t":16,"rt":$n[3].List$1(UnityEngine.Transform),"g":{"a":2,"n":"get_SeparatorParts","t":8,"rt":$n[3].List$1(UnityEngine.Transform),"fg":"SeparatorParts"},"fn":"SeparatorParts"},{"a":2,"n":"Skeleton","t":16,"rt":$n[1].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[1].Skeleton,"fg":"Skeleton"},"s":{"a":2,"n":"set_Skeleton","t":8,"p":[$n[1].Skeleton],"rt":$n[0].Void,"fs":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonData","t":16,"rt":$n[1].SkeletonData,"g":{"a":2,"n":"get_SkeletonData","t":8,"rt":$n[1].SkeletonData,"fg":"SkeletonData"},"fn":"SkeletonData"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[2].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[2].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":2,"n":"UpdateMode","t":16,"rt":$n[2].UpdateMode,"g":{"a":2,"n":"get_UpdateMode","t":8,"rt":$n[2].UpdateMode,"fg":"UpdateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},"s":{"a":2,"n":"set_UpdateMode","t":8,"p":[$n[2].UpdateMode],"rt":$n[0].Void,"fs":"UpdateMode"},"fn":"UpdateMode"},{"ov":true,"a":2,"n":"mainTexture","t":16,"rt":$n[4].Texture,"g":{"ov":true,"a":2,"n":"get_mainTexture","t":8,"rt":$n[4].Texture,"fg":"mainTexture"},"fn":"mainTexture"},{"a":2,"n":"SeparatorPartGameObjectName","is":true,"t":4,"rt":$n[0].String,"sn":"SeparatorPartGameObjectName"},{"a":2,"n":"additiveMaterial","t":4,"rt":$n[4].Material,"sn":"additiveMaterial"},{"a":2,"n":"allowMultipleCanvasRenderers","t":4,"rt":$n[0].Boolean,"sn":"allowMultipleCanvasRenderers","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"baseTexture","t":4,"rt":$n[4].Texture,"sn":"baseTexture"},{"a":2,"n":"canvasRenderers","t":4,"rt":$n[3].List$1(UnityEngine.CanvasRenderer),"sn":"canvasRenderers"},{"a":1,"n":"currentInstructions","t":4,"rt":$n[2].SkeletonRendererInstruction,"sn":"currentInstructions"},{"a":1,"n":"customMaterialOverride","t":4,"rt":$n[3].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"sn":"customMaterialOverride","ro":true},{"a":1,"n":"customTextureOverride","t":4,"rt":$n[3].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"sn":"customTextureOverride","ro":true},{"a":2,"n":"enableSeparatorSlots","t":4,"rt":$n[0].Boolean,"sn":"enableSeparatorSlots","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"freeze","t":4,"rt":$n[0].Boolean,"sn":"freeze","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipX","t":4,"rt":$n[0].Boolean,"sn":"initialFlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipY","t":4,"rt":$n[0].Boolean,"sn":"initialFlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSkin("", "skeletonDataAsset", true, false, true)],"a":2,"n":"initialSkinName","t":4,"rt":$n[0].String,"sn":"initialSkinName"},{"a":1,"n":"meshBuffers","t":4,"rt":$n[2].DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh),"sn":"meshBuffers"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"meshGenerator","t":4,"rt":$n[2].MeshGenerator,"sn":"meshGenerator"},{"a":1,"n":"meshes","t":4,"rt":$n[1].ExposedList$1(UnityEngine.Mesh),"sn":"meshes","ro":true},{"a":2,"n":"multiplyMaterial","t":4,"rt":$n[4].Material,"sn":"multiplyMaterial"},{"a":1,"n":"overrideTexture","t":4,"rt":$n[4].Texture,"sn":"overrideTexture"},{"a":2,"n":"screenMaterial","t":4,"rt":$n[4].Material,"sn":"screenMaterial"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"separatorParts","t":4,"rt":$n[3].List$1(UnityEngine.Transform),"sn":"separatorParts"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineSlot("", "", false, true, false)],"a":3,"n":"separatorSlotNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"separatorSlotNames"},{"a":2,"n":"separatorSlots","t":4,"rt":$n[3].List$1(Spine.Slot),"sn":"separatorSlots","ro":true},{"a":3,"n":"skeleton","t":4,"rt":$n[1].Skeleton,"sn":"skeleton"},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[2].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"at":[new Spine.Unity.SpineAnimation("", "skeletonDataAsset", true, false)],"a":2,"n":"startingAnimation","t":4,"rt":$n[0].String,"sn":"startingAnimation"},{"a":2,"n":"startingLoop","t":4,"rt":$n[0].Boolean,"sn":"startingLoop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"state","t":4,"rt":$n[1].AnimationState,"sn":"state"},{"a":3,"n":"submeshGraphics","t":4,"rt":$n[3].List$1(Spine.Unity.SkeletonSubmeshGraphic),"sn":"submeshGraphics"},{"a":2,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"unscaledTime","t":4,"rt":$n[0].Boolean,"sn":"unscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"updateMode","t":4,"rt":$n[2].UpdateMode,"sn":"updateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"updateSeparatorPartLocation","t":4,"rt":$n[0].Boolean,"sn":"updateSeparatorPartLocation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"updateWhenInvisible","t":4,"rt":$n[2].UpdateMode,"sn":"updateWhenInvisible","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":3,"n":"usedRenderersCount","t":4,"rt":$n[0].Int32,"sn":"usedRenderersCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnPostProcessVertices","t":2,"ad":{"a":2,"n":"add_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnPostProcessVertices","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnPostProcessVertices","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnRebuild","t":2,"ad":{"a":2,"n":"add_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonGraphic end.*/

    /*Spine.Unity.SkeletonMecanim start.*/
    $m("Spine.Unity.SkeletonMecanim", function () { return {"nested":[$n[2].SkeletonMecanim.MecanimTranslator],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Animator),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonMecanim-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"ov":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"ov":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"ov":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"Translator","t":16,"rt":$n[2].SkeletonMecanim.MecanimTranslator,"g":{"a":2,"n":"get_Translator","t":8,"rt":$n[2].SkeletonMecanim.MecanimTranslator,"fg":"Translator"},"fn":"Translator"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"translator","t":4,"rt":$n[2].SkeletonMecanim.MecanimTranslator,"sn":"translator"},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_BeforeApply","t":2,"ad":{"a":3,"n":"add__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_BeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_BeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateComplete","t":2,"ad":{"a":3,"n":"add__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateLocal","t":2,"ad":{"a":3,"n":"add__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateWorld","t":2,"ad":{"a":3,"n":"add__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator", function () { return {"td":$n[2].SkeletonMecanim,"nested":[Function,$n[2].SkeletonMecanim.MecanimTranslator.MixMode,$n[2].SkeletonMecanim.MecanimTranslator.ClipInfos,$n[2].SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer,$n[2].SkeletonMecanim.MecanimTranslator.IntEqualityComparer],"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AnimationTime","is":true,"t":8,"pi":[{"n":"normalizedTime","pt":$n[0].Single,"ps":0},{"n":"clipLength","pt":$n[0].Single,"ps":1},{"n":"reversed","pt":$n[0].Boolean,"ps":2}],"sn":"AnimationTime","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"AnimationTime","is":true,"t":8,"pi":[{"n":"normalizedTime","pt":$n[0].Single,"ps":0},{"n":"clipLength","pt":$n[0].Single,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"reversed","pt":$n[0].Boolean,"ps":3}],"sn":"AnimationTime$1","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[1].Skeleton,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[1].Skeleton]},{"a":1,"n":"ApplyAnimation","t":8,"pi":[{"n":"skeleton","pt":$n[1].Skeleton,"ps":0},{"n":"info","pt":$n[4].AnimatorClipInfo,"ps":1},{"n":"stateInfo","pt":$n[4].AnimatorStateInfo,"ps":2},{"n":"layerIndex","pt":$n[0].Int32,"ps":3},{"n":"layerWeight","pt":$n[0].Single,"ps":4},{"n":"layerBlendMode","pt":spine.MixBlend,"ps":5},{"n":"useClipWeight1","dv":false,"o":true,"pt":$n[0].Boolean,"ps":6}],"sn":"ApplyAnimation","rt":$n[0].Boolean,"p":[$n[1].Skeleton,$n[4].AnimatorClipInfo,$n[4].AnimatorStateInfo,$n[0].Int32,$n[0].Single,spine.MixBlend,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ApplyInterruptionAnimation","t":8,"pi":[{"n":"skeleton","pt":$n[1].Skeleton,"ps":0},{"n":"interpolateWeightTo1","pt":$n[0].Boolean,"ps":1},{"n":"info","pt":$n[4].AnimatorClipInfo,"ps":2},{"n":"stateInfo","pt":$n[4].AnimatorStateInfo,"ps":3},{"n":"layerIndex","pt":$n[0].Int32,"ps":4},{"n":"layerWeight","pt":$n[0].Single,"ps":5},{"n":"layerBlendMode","pt":spine.MixBlend,"ps":6},{"n":"interruptingClipTimeAddition","pt":$n[0].Single,"ps":7},{"n":"useClipWeight1","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8}],"sn":"ApplyInterruptionAnimation","rt":$n[0].Boolean,"p":[$n[1].Skeleton,$n[0].Boolean,$n[4].AnimatorClipInfo,$n[4].AnimatorStateInfo,$n[0].Int32,$n[0].Single,spine.MixBlend,$n[0].Single,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ClearClipInfosForLayers","t":8,"sn":"ClearClipInfosForLayers","rt":$n[0].Void},{"a":2,"n":"GetActiveAnimationAndTime","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0}],"sn":"GetActiveAnimationAndTime","rt":$n[3].KeyValuePair$2(Spine.Animation,System.Single),"p":[$n[0].Int32]},{"a":1,"n":"GetAnimation","t":8,"pi":[{"n":"clip","pt":$n[4].AnimationClip,"ps":0}],"sn":"GetAnimation","rt":$n[1].Animation,"p":[$n[4].AnimationClip]},{"a":1,"n":"GetAnimatorClipInfos","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"isInterruptionActive","out":true,"pt":$n[0].Boolean,"ps":1},{"n":"clipInfoCount","out":true,"pt":$n[0].Int32,"ps":2},{"n":"nextClipInfoCount","out":true,"pt":$n[0].Int32,"ps":3},{"n":"interruptingClipInfoCount","out":true,"pt":$n[0].Int32,"ps":4},{"n":"clipInfo","out":true,"pt":$n[3].IList$1(UnityEngine.AnimatorClipInfo),"ps":5},{"n":"nextClipInfo","out":true,"pt":$n[3].IList$1(UnityEngine.AnimatorClipInfo),"ps":6},{"n":"interruptingClipInfo","out":true,"pt":$n[3].IList$1(UnityEngine.AnimatorClipInfo),"ps":7},{"n":"shallInterpolateWeightTo1","out":true,"pt":$n[0].Boolean,"ps":8}],"sn":"GetAnimatorClipInfos","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[3].IList$1(UnityEngine.AnimatorClipInfo),$n[3].IList$1(UnityEngine.AnimatorClipInfo),$n[3].IList$1(UnityEngine.AnimatorClipInfo),$n[0].Boolean]},{"a":1,"n":"GetAnimatorStateInfos","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"isInterruptionActive","out":true,"pt":$n[0].Boolean,"ps":1},{"n":"stateInfo","out":true,"pt":$n[4].AnimatorStateInfo,"ps":2},{"n":"nextStateInfo","out":true,"pt":$n[4].AnimatorStateInfo,"ps":3},{"n":"interruptingStateInfo","out":true,"pt":$n[4].AnimatorStateInfo,"ps":4},{"n":"interruptingClipTimeAddition","out":true,"pt":$n[0].Single,"ps":5}],"sn":"GetAnimatorStateInfos","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[4].AnimatorStateInfo,$n[4].AnimatorStateInfo,$n[4].AnimatorStateInfo,$n[0].Single]},{"a":1,"n":"GetMixMode","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"layerBlendMode","pt":spine.MixBlend,"ps":1}],"sn":"GetMixMode","rt":$n[2].SkeletonMecanim.MecanimTranslator.MixMode,"p":[$n[0].Int32,spine.MixBlend],"box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":1,"n":"GetStateUpdatesFromAnimator","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0}],"sn":"GetStateUpdatesFromAnimator","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"InitClipInfosForLayers","t":8,"sn":"InitClipInfosForLayers","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"animator","pt":$n[4].Animator,"ps":0},{"n":"skeletonDataAsset","pt":$n[2].SkeletonDataAsset,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[4].Animator,$n[2].SkeletonDataAsset]},{"a":1,"n":"OnClipAppliedCallback","t":8,"pi":[{"n":"clip","pt":$n[1].Animation,"ps":0},{"n":"stateInfo","pt":$n[4].AnimatorStateInfo,"ps":1},{"n":"layerIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"isLooping","pt":$n[0].Boolean,"ps":4},{"n":"weight","pt":$n[0].Single,"ps":5}],"sn":"OnClipAppliedCallback","rt":$n[0].Void,"p":[$n[1].Animation,$n[4].AnimatorStateInfo,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"Animator","t":16,"rt":$n[4].Animator,"g":{"a":2,"n":"get_Animator","t":8,"rt":$n[4].Animator,"fg":"Animator"},"fn":"Animator"},{"a":2,"n":"MecanimLayerCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_MecanimLayerCount","t":8,"rt":$n[0].Int32,"fg":"MecanimLayerCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MecanimLayerCount"},{"a":2,"n":"MecanimLayerNames","t":16,"rt":$n[0].Array.type(System.String),"g":{"a":2,"n":"get_MecanimLayerNames","t":8,"rt":$n[0].Array.type(System.String),"fg":"MecanimLayerNames"},"fn":"MecanimLayerNames"},{"a":1,"n":"WeightEpsilon","is":true,"t":4,"rt":$n[0].Single,"sn":"WeightEpsilon","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"animationTable","t":4,"rt":$n[3].Dictionary$2(System.Int32,Spine.Animation),"sn":"animationTable","ro":true},{"a":1,"n":"animator","t":4,"rt":$n[4].Animator,"sn":"animator"},{"a":2,"n":"autoReset","t":4,"rt":$n[0].Boolean,"sn":"autoReset","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"clipNameHashCodeTable","t":4,"rt":$n[3].Dictionary$2(UnityEngine.AnimationClip,System.Int32),"sn":"clipNameHashCodeTable","ro":true},{"a":2,"n":"layerBlendModes","t":4,"rt":System.Array.type(spine.MixBlend),"sn":"layerBlendModes"},{"a":3,"n":"layerClipInfos","t":4,"rt":System.Array.type(Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos),"sn":"layerClipInfos"},{"a":2,"n":"layerMixModes","t":4,"rt":System.Array.type(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode),"sn":"layerMixModes"},{"a":1,"n":"previousAnimations","t":4,"rt":$n[3].List$1(Spine.Animation),"sn":"previousAnimations","ro":true},{"a":2,"n":"useCustomMixMode","t":4,"rt":$n[0].Boolean,"sn":"useCustomMixMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"OnClipApplied","t":2,"ad":{"a":2,"n":"add_OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnClipApplied","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnClipApplied","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnClipApplied","t":2,"ad":{"a":3,"n":"add__OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnClipApplied","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnClipApplied","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode", function () { return {"td":$n[2].SkeletonMecanim.MecanimTranslator,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AlwaysMix","is":true,"t":4,"rt":$n[2].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"AlwaysMix","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":2,"n":"Hard","is":true,"t":4,"rt":$n[2].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"Hard","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":2,"n":"MixNext","is":true,"t":4,"rt":$n[2].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"MixNext","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos", function () { return {"td":$n[2].SkeletonMecanim.MecanimTranslator,"att":1048580,"a":3,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"clipInfoCount","t":4,"rt":$n[0].Int32,"sn":"clipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"clipInfos","t":4,"rt":$n[3].List$1(UnityEngine.AnimatorClipInfo),"sn":"clipInfos","ro":true},{"a":2,"n":"interruptingClipInfoCount","t":4,"rt":$n[0].Int32,"sn":"interruptingClipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"interruptingClipInfos","t":4,"rt":$n[3].List$1(UnityEngine.AnimatorClipInfo),"sn":"interruptingClipInfos","ro":true},{"a":2,"n":"interruptingClipTimeAddition","t":4,"rt":$n[0].Single,"sn":"interruptingClipTimeAddition","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"interruptingStateInfo","t":4,"rt":$n[4].AnimatorStateInfo,"sn":"interruptingStateInfo"},{"a":2,"n":"isInterruptionActive","t":4,"rt":$n[0].Boolean,"sn":"isInterruptionActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"isLastFrameOfInterruption","t":4,"rt":$n[0].Boolean,"sn":"isLastFrameOfInterruption","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nextClipInfoCount","t":4,"rt":$n[0].Int32,"sn":"nextClipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"nextClipInfos","t":4,"rt":$n[3].List$1(UnityEngine.AnimatorClipInfo),"sn":"nextClipInfos","ro":true},{"a":2,"n":"nextStateInfo","t":4,"rt":$n[4].AnimatorStateInfo,"sn":"nextStateInfo"},{"a":2,"n":"stateInfo","t":4,"rt":$n[4].AnimatorStateInfo,"sn":"stateInfo"}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer", function () { return {"td":$n[2].SkeletonMecanim.MecanimTranslator,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"x","pt":$n[4].AnimationClip,"ps":0},{"n":"y","pt":$n[4].AnimationClip,"ps":1}],"sn":"equals2","rt":$n[0].Boolean,"p":[$n[4].AnimationClip,$n[4].AnimationClip],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetHashCode","t":8,"pi":[{"n":"o","pt":$n[4].AnimationClip,"ps":0}],"sn":"getHashCode2","rt":$n[0].Int32,"p":[$n[4].AnimationClip],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[3].IEqualityComparer$1(UnityEngine.AnimationClip),"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer", function () { return {"td":$n[2].SkeletonMecanim.MecanimTranslator,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"x","pt":$n[0].Int32,"ps":0},{"n":"y","pt":$n[0].Int32,"ps":1}],"sn":"equals2","rt":$n[0].Boolean,"p":[$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetHashCode","t":8,"pi":[{"n":"o","pt":$n[0].Int32,"ps":0}],"sn":"getHashCode2","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[3].IEqualityComparer$1(System.Int32),"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer end.*/

    /*Spine.Unity.SkeletonRenderer start.*/
    $m("Spine.Unity.SkeletonRenderer", function () { return {"nested":[$n[2].SkeletonRenderer.SpriteMaskInteractionMaterials,Function,Function],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.MeshRenderer),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderer-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddSpineComponent","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[4].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[2].SkeletonDataAsset,"ps":1},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"tpc":1,"tprm":["T"],"sn":"AddSpineComponent","rt":System.Object,"p":[$n[4].GameObject,$n[2].SkeletonDataAsset,$n[0].Boolean]},{"a":1,"n":"AssignSpriteMaskMaterials","t":8,"sn":"AssignSpriteMaskMaterials","rt":$n[0].Void},{"v":true,"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"v":true,"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":2,"n":"EnsureMeshGeneratorCapacity","t":8,"pi":[{"n":"minimumVertexCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureMeshGeneratorCapacity","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"FindAndApplySeparatorSlots","t":8,"pi":[{"n":"slotNamePredicate","pt":Function,"ps":0},{"n":"clearExistingSeparators","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"updateStringArray","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"FindAndApplySeparatorSlots","rt":$n[0].Void,"p":[Function,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"FindAndApplySeparatorSlots","t":8,"pi":[{"n":"startsWith","pt":$n[0].String,"ps":0},{"n":"clearExistingSeparators","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"updateStringArray","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"FindAndApplySeparatorSlots$1","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"InitSpriteMaskMaterialsForMaskType","t":8,"pi":[{"n":"maskFunction","pt":$n[7].CompareFunction,"ps":0},{"n":"materialsToFill","ref":true,"pt":System.Array.type(UnityEngine.Material),"ps":1}],"sn":"InitSpriteMaskMaterialsForMaskType","rt":$n[0].Boolean,"p":[$n[7].CompareFunction,System.Array.type(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"InitSpriteMaskMaterialsInsideMask","t":8,"sn":"InitSpriteMaskMaterialsInsideMask","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"InitSpriteMaskMaterialsOutsideMask","t":8,"sn":"InitSpriteMaskMaterialsOutsideMask","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"v":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"v":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"v":true,"a":2,"n":"LateUpdateMesh","t":8,"sn":"LateUpdateMesh","rt":$n[0].Void},{"a":2,"n":"NewSpineGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[2].SkeletonDataAsset,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"tpc":1,"tprm":["T"],"sn":"NewSpineGameObject","rt":System.Object,"p":[$n[2].SkeletonDataAsset,$n[0].Boolean]},{"a":2,"n":"OnBecameInvisible","t":8,"sn":"OnBecameInvisible","rt":$n[0].Void},{"v":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"ReapplySeparatorSlotNames","t":8,"sn":"ReapplySeparatorSlotNames","rt":$n[0].Void},{"a":1,"n":"SetMaterialSettingsToFixDrawOrder","t":8,"sn":"SetMaterialSettingsToFixDrawOrder","rt":$n[0].Void},{"a":2,"n":"SetMeshSettings","t":8,"pi":[{"n":"settings","pt":$n[2].MeshGenerator.Settings,"ps":0}],"sn":"SetMeshSettings","rt":$n[0].Void,"p":[$n[2].MeshGenerator.Settings]},{"a":2,"n":"CustomMaterialOverride","t":16,"rt":$n[3].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"g":{"a":2,"n":"get_CustomMaterialOverride","t":8,"rt":$n[3].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"fg":"CustomMaterialOverride"},"fn":"CustomMaterialOverride"},{"a":2,"n":"CustomSlotMaterials","t":16,"rt":$n[3].Dictionary$2(Spine.Slot,UnityEngine.Material),"g":{"a":2,"n":"get_CustomSlotMaterials","t":8,"rt":$n[3].Dictionary$2(Spine.Slot,UnityEngine.Material),"fg":"CustomSlotMaterials"},"fn":"CustomSlotMaterials"},{"a":2,"n":"Skeleton","t":16,"rt":$n[1].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[1].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[2].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[2].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":2,"n":"UpdateMode","t":16,"rt":$n[2].UpdateMode,"g":{"a":2,"n":"get_UpdateMode","t":8,"rt":$n[2].UpdateMode,"fg":"UpdateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},"s":{"a":2,"n":"set_UpdateMode","t":8,"p":[$n[2].UpdateMode],"rt":$n[0].Void,"fs":"UpdateMode"},"fn":"UpdateMode"},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_NONE","is":true,"t":4,"rt":$n[7].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_NONE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE","is":true,"t":4,"rt":$n[7].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE","is":true,"t":4,"rt":$n[7].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_PARAM_ID","is":true,"t":4,"rt":$n[0].Int32,"sn":"STENCIL_COMP_PARAM_ID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SUBMESH_DUMMY_PARAM_ID","is":true,"t":4,"rt":$n[0].Int32,"sn":"SUBMESH_DUMMY_PARAM_ID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("calculateNormals")],"a":2,"n":"addNormals","t":4,"rt":$n[0].Boolean,"sn":"addNormals","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"calculateTangents","t":4,"rt":$n[0].Boolean,"sn":"calculateTangents","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"currentInstructions","t":4,"rt":$n[2].SkeletonRendererInstruction,"sn":"currentInstructions","ro":true},{"a":1,"n":"customMaterialOverride","t":4,"rt":$n[3].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"sn":"customMaterialOverride","ro":true},{"a":1,"n":"customSlotMaterials","t":4,"rt":$n[3].Dictionary$2(Spine.Slot,UnityEngine.Material),"sn":"customSlotMaterials","ro":true},{"a":2,"n":"disableRenderingOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableRenderingOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"fixDrawOrder","t":4,"rt":$n[0].Boolean,"sn":"fixDrawOrder","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipX","t":4,"rt":$n[0].Boolean,"sn":"initialFlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipY","t":4,"rt":$n[0].Boolean,"sn":"initialFlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSkin("", "", true, false, true)],"a":2,"n":"initialSkinName","t":4,"rt":$n[0].String,"sn":"initialSkinName"},{"a":2,"n":"maskInteraction","t":4,"rt":$n[4].SpriteMaskInteraction,"sn":"maskInteraction","box":function ($v) { return Bridge.box($v, UnityEngine.SpriteMaskInteraction, System.Enum.toStringFn(UnityEngine.SpriteMaskInteraction));}},{"a":2,"n":"maskMaterials","t":4,"rt":$n[2].SkeletonRenderer.SpriteMaskInteractionMaterials,"sn":"maskMaterials"},{"a":1,"n":"meshFilter","t":4,"rt":$n[4].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshGenerator","t":4,"rt":$n[2].MeshGenerator,"sn":"meshGenerator","ro":true},{"a":1,"n":"meshRenderer","t":4,"rt":$n[4].MeshRenderer,"sn":"meshRenderer"},{"a":2,"n":"pmaVertexColors","t":4,"rt":$n[0].Boolean,"sn":"pmaVertexColors","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"rendererBuffers","t":4,"rt":$n[2].MeshRendererBuffers,"sn":"rendererBuffers","ro":true},{"a":1,"n":"reusedPropertyBlock","t":4,"rt":$n[4].MaterialPropertyBlock,"sn":"reusedPropertyBlock"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("submeshSeparators"),new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineSlot("", "", false, true, false)],"a":3,"n":"separatorSlotNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"separatorSlotNames"},{"a":2,"n":"separatorSlots","t":4,"rt":$n[3].List$1(Spine.Slot),"sn":"separatorSlots","ro":true},{"a":2,"n":"singleSubmesh","t":4,"rt":$n[0].Boolean,"sn":"singleSubmesh","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"skeleton","t":4,"rt":$n[1].Skeleton,"sn":"skeleton"},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[2].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"a":2,"n":"tintBlack","t":4,"rt":$n[0].Boolean,"sn":"tintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"updateMode","t":4,"rt":$n[2].UpdateMode,"sn":"updateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"updateWhenInvisible","t":4,"rt":$n[2].UpdateMode,"sn":"updateWhenInvisible","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"useClipping","t":4,"rt":$n[0].Boolean,"sn":"useClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.RangeAttribute(-0.1, 0.0)],"a":2,"n":"zSpacing","t":4,"rt":$n[0].Single,"sn":"zSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GenerateMeshOverride","t":2,"ad":{"a":2,"n":"add_GenerateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addGenerateMeshOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_GenerateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeGenerateMeshOverride","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnPostProcessVertices","t":2,"ad":{"a":2,"n":"add_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnPostProcessVertices","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnPostProcessVertices","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnRebuild","t":2,"ad":{"a":2,"n":"add_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRebuild","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"generateMeshOverride","t":2,"ad":{"a":1,"n":"add_generateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addgenerateMeshOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_generateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removegenerateMeshOverride","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRenderer end.*/

    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials start.*/
    $m("Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials", function () { return {"td":$n[2].SkeletonRenderer,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AnyMaterialCreated","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_AnyMaterialCreated","t":8,"rt":$n[0].Boolean,"fg":"AnyMaterialCreated","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"AnyMaterialCreated"},{"a":2,"n":"materialsInsideMask","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsInsideMask"},{"a":2,"n":"materialsMaskDisabled","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsMaskDisabled"},{"a":2,"n":"materialsOutsideMask","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsOutsideMask"}]}; }, $n);
    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials", function () { return {"nested":[$n[2].SkeletonGraphicCustomMaterials.AtlasMaterialOverride,$n[2].SkeletonGraphicCustomMaterials.AtlasTextureOverride],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonGraphicCustomMaterials")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"RemoveCustomMaterialOverrides","t":8,"sn":"RemoveCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"RemoveCustomTextureOverrides","t":8,"sn":"RemoveCustomTextureOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomMaterialOverrides","t":8,"sn":"SetCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomTextureOverrides","t":8,"sn":"SetCustomTextureOverrides","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customMaterialOverrides","t":4,"rt":$n[3].List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride),"sn":"customMaterialOverrides"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customTextureOverrides","t":4,"rt":$n[3].List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride),"sn":"customTextureOverrides"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[2].SkeletonGraphic,"sn":"skeletonGraphic"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride", function () { return {"td":$n[2].SkeletonGraphicCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[2].SkeletonGraphicCustomMaterials.AtlasMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[2].SkeletonGraphicCustomMaterials.AtlasMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalTexture","t":4,"rt":$n[4].Texture,"sn":"originalTexture"},{"a":2,"n":"overrideEnabled","t":4,"rt":$n[0].Boolean,"sn":"overrideEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementMaterial","t":4,"rt":$n[4].Material,"sn":"replacementMaterial"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride", function () { return {"td":$n[2].SkeletonGraphicCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[2].SkeletonGraphicCustomMaterials.AtlasTextureOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[2].SkeletonGraphicCustomMaterials.AtlasTextureOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalTexture","t":4,"rt":$n[4].Texture,"sn":"originalTexture"},{"a":2,"n":"overrideEnabled","t":4,"rt":$n[0].Boolean,"sn":"overrideEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementTexture","t":4,"rt":$n[4].Texture,"sn":"replacementTexture"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials", function () { return {"nested":[$n[2].SkeletonRendererCustomMaterials.SlotMaterialOverride,$n[2].SkeletonRendererCustomMaterials.AtlasMaterialOverride],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRendererCustomMaterials")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"RemoveCustomMaterialOverrides","t":8,"sn":"RemoveCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"RemoveCustomSlotMaterials","t":8,"sn":"RemoveCustomSlotMaterials","rt":$n[0].Void},{"a":1,"n":"SetCustomMaterialOverrides","t":8,"sn":"SetCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomSlotMaterials","t":8,"sn":"SetCustomSlotMaterials","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customMaterialOverrides","t":4,"rt":$n[3].List$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride),"sn":"customMaterialOverrides"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customSlotMaterials","t":4,"rt":$n[3].List$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride),"sn":"customSlotMaterials"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[2].SkeletonRenderer,"sn":"skeletonRenderer"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride", function () { return {"td":$n[2].SkeletonRendererCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[2].SkeletonRendererCustomMaterials.SlotMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[2].SkeletonRendererCustomMaterials.SlotMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"material","t":4,"rt":$n[4].Material,"sn":"material"},{"a":2,"n":"overrideDisabled","t":4,"rt":$n[0].Boolean,"sn":"overrideDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride", function () { return {"td":$n[2].SkeletonRendererCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[2].SkeletonRendererCustomMaterials.AtlasMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[2].SkeletonRendererCustomMaterials.AtlasMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalMaterial","t":4,"rt":$n[4].Material,"sn":"originalMaterial"},{"a":2,"n":"overrideDisabled","t":4,"rt":$n[0].Boolean,"sn":"overrideDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementMaterial","t":4,"rt":$n[4].Material,"sn":"replacementMaterial"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonPartsRenderer start.*/
    $m("Spine.Unity.SkeletonPartsRenderer", function () { return {"nested":[Function],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.$ctor1(UnityEngine.MeshRenderer, UnityEngine.MeshFilter),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderSeparator")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClearMesh","t":8,"sn":"ClearMesh","rt":$n[0].Void},{"a":1,"n":"LazyIntialize","t":8,"sn":"LazyIntialize","rt":$n[0].Void},{"a":2,"n":"NewPartsRendererGameObject","is":true,"t":8,"pi":[{"n":"parent","pt":$n[4].Transform,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"sortingOrder","dv":0,"o":true,"pt":$n[0].Int32,"ps":2}],"sn":"NewPartsRendererGameObject","rt":$n[2].SkeletonPartsRenderer,"p":[$n[4].Transform,$n[0].String,$n[0].Int32]},{"a":2,"n":"RenderParts","t":8,"pi":[{"n":"instructions","pt":$n[1].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"startSubmesh","pt":$n[0].Int32,"ps":1},{"n":"endSubmesh","pt":$n[0].Int32,"ps":2}],"sn":"RenderParts","rt":$n[0].Void,"p":[$n[1].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"SetPropertyBlock","t":8,"pi":[{"n":"block","pt":$n[4].MaterialPropertyBlock,"ps":0}],"sn":"SetPropertyBlock","rt":$n[0].Void,"p":[$n[4].MaterialPropertyBlock]},{"a":2,"n":"MeshFilter","t":16,"rt":$n[4].MeshFilter,"g":{"a":2,"n":"get_MeshFilter","t":8,"rt":$n[4].MeshFilter,"fg":"MeshFilter"},"fn":"MeshFilter"},{"a":2,"n":"MeshGenerator","t":16,"rt":$n[2].MeshGenerator,"g":{"a":2,"n":"get_MeshGenerator","t":8,"rt":$n[2].MeshGenerator,"fg":"MeshGenerator"},"fn":"MeshGenerator"},{"a":2,"n":"MeshRenderer","t":16,"rt":$n[4].MeshRenderer,"g":{"a":2,"n":"get_MeshRenderer","t":8,"rt":$n[4].MeshRenderer,"fg":"MeshRenderer"},"fn":"MeshRenderer"},{"a":1,"n":"buffers","t":4,"rt":$n[2].MeshRendererBuffers,"sn":"buffers"},{"a":1,"n":"currentInstructions","t":4,"rt":$n[2].SkeletonRendererInstruction,"sn":"currentInstructions"},{"a":1,"n":"meshFilter","t":4,"rt":$n[4].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshGenerator","t":4,"rt":$n[2].MeshGenerator,"sn":"meshGenerator"},{"a":1,"n":"meshRenderer","t":4,"rt":$n[4].MeshRenderer,"sn":"meshRenderer"},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonPartsRenderer end.*/

    /*Spine.Unity.SkeletonRenderSeparator start.*/
    $m("Spine.Unity.SkeletonRenderSeparator", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderSeparator")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddPartsRenderer","t":8,"pi":[{"n":"sortingOrderIncrement","dv":5,"o":true,"pt":$n[0].Int32,"ps":0},{"n":"name","dv":null,"o":true,"pt":$n[0].String,"ps":1}],"sn":"AddPartsRenderer","rt":$n[2].SkeletonPartsRenderer,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"AddToSkeletonRenderer","is":true,"t":8,"pi":[{"n":"skeletonRenderer","pt":$n[2].SkeletonRenderer,"ps":0},{"n":"sortingLayerID","dv":0,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"extraPartsRenderers","dv":0,"o":true,"pt":$n[0].Int32,"ps":2},{"n":"sortingOrderIncrement","dv":5,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"baseSortingOrder","dv":0,"o":true,"pt":$n[0].Int32,"ps":4},{"n":"addMinimumPartsRenderers","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"AddToSkeletonRenderer","rt":$n[2].SkeletonRenderSeparator,"p":[$n[2].SkeletonRenderer,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Boolean]},{"a":1,"n":"HandleRender","t":8,"pi":[{"n":"instruction","pt":$n[2].SkeletonRendererInstruction,"ps":0}],"sn":"HandleRender","rt":$n[0].Void,"p":[$n[2].SkeletonRendererInstruction]},{"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[2].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[2].SkeletonRenderer,"fg":"SkeletonRenderer"},"s":{"a":2,"n":"set_SkeletonRenderer","t":8,"p":[$n[2].SkeletonRenderer],"rt":$n[0].Void,"fs":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":2,"n":"DefaultSortingOrderIncrement","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultSortingOrderIncrement","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"copiedBlock","t":4,"rt":$n[4].MaterialPropertyBlock,"sn":"copiedBlock"},{"at":[new UnityEngine.TooltipAttribute("Copies MeshRenderer flags into each parts renderer")],"a":2,"n":"copyMeshRendererFlags","t":4,"rt":$n[0].Boolean,"sn":"copyMeshRendererFlags","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"copyPropertyBlock","t":4,"rt":$n[0].Boolean,"sn":"copyPropertyBlock","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"mainMeshRenderer","t":4,"rt":$n[4].MeshRenderer,"sn":"mainMeshRenderer"},{"a":2,"n":"partsRenderers","t":4,"rt":$n[3].List$1(Spine.Unity.SkeletonPartsRenderer),"sn":"partsRenderers"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonRenderer","t":4,"rt":$n[2].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRenderSeparator end.*/

    /*Spine.Unity.ActivateBasedOnFlipDirection start.*/
    $m("Spine.Unity.ActivateBasedOnFlipDirection", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CompensateMovementAfterFlipX","t":8,"pi":[{"n":"toActivate","pt":$n[4].Transform,"ps":0},{"n":"toDeactivate","pt":$n[4].Transform,"ps":1}],"sn":"CompensateMovementAfterFlipX","rt":$n[0].Void,"p":[$n[4].Transform,$n[4].Transform]},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"HandleFlip","t":8,"pi":[{"n":"isFlippedX","pt":$n[0].Boolean,"ps":0}],"sn":"HandleFlip","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"ResetJointPositions","t":8,"pi":[{"n":"joints","pt":System.Array.type(UnityEngine.HingeJoint2D),"ps":0}],"sn":"ResetJointPositions","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.HingeJoint2D)]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"activeOnFlippedX","t":4,"rt":$n[4].GameObject,"sn":"activeOnFlippedX"},{"a":2,"n":"activeOnNormalX","t":4,"rt":$n[4].GameObject,"sn":"activeOnNormalX"},{"a":1,"n":"jointsFlippedX","t":4,"rt":System.Array.type(UnityEngine.HingeJoint2D),"sn":"jointsFlippedX"},{"a":1,"n":"jointsNormalX","t":4,"rt":System.Array.type(UnityEngine.HingeJoint2D),"sn":"jointsNormalX"},{"a":1,"n":"skeletonComponent","t":4,"rt":$n[2].ISkeletonComponent,"sn":"skeletonComponent"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[2].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[2].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"wasFlippedXBefore","t":4,"rt":$n[0].Boolean,"sn":"wasFlippedXBefore","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.ActivateBasedOnFlipDirection end.*/

    /*Spine.Unity.SkeletonUtility start.*/
    $m("Spine.Unity.SkeletonUtility", function () { return {"nested":[Function],"att":1048833,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(Spine.Unity.ISkeletonAnimation),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtility")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddBoneRigidbody2D","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[4].GameObject,"ps":0},{"n":"isKinematic","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"gravityScale","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"AddBoneRigidbody2D","rt":$n[4].Rigidbody2D,"p":[$n[4].GameObject,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AddBoundingBoxAsComponent","is":true,"t":8,"pi":[{"n":"box","pt":spine.BoundingBoxAttachment,"ps":0},{"n":"slot","pt":$n[1].Slot,"ps":1},{"n":"gameObject","pt":$n[4].GameObject,"ps":2},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"AddBoundingBoxAsComponent","rt":$n[4].PolygonCollider2D,"p":[spine.BoundingBoxAttachment,$n[1].Slot,$n[4].GameObject,$n[0].Boolean]},{"a":2,"n":"AddBoundingBoxGameObject","is":true,"t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"box","pt":spine.BoundingBoxAttachment,"ps":1},{"n":"slot","pt":$n[1].Slot,"ps":2},{"n":"parent","pt":$n[4].Transform,"ps":3},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"AddBoundingBoxGameObject$1","rt":$n[4].PolygonCollider2D,"p":[$n[0].String,spine.BoundingBoxAttachment,$n[1].Slot,$n[4].Transform,$n[0].Boolean]},{"a":2,"n":"AddBoundingBoxGameObject","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[1].Skeleton,"ps":0},{"n":"skinName","pt":$n[0].String,"ps":1},{"n":"slotName","pt":$n[0].String,"ps":2},{"n":"attachmentName","pt":$n[0].String,"ps":3},{"n":"parent","pt":$n[4].Transform,"ps":4},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"AddBoundingBoxGameObject","rt":$n[4].PolygonCollider2D,"p":[$n[1].Skeleton,$n[0].String,$n[0].String,$n[0].String,$n[4].Transform,$n[0].Boolean]},{"a":2,"n":"CollectBones","t":8,"sn":"CollectBones","rt":$n[0].Void},{"a":2,"n":"GetBoneRoot","t":8,"sn":"GetBoneRoot","rt":$n[4].Transform},{"a":2,"n":"GetBoundingBoxBounds","is":true,"t":8,"pi":[{"n":"boundingBox","pt":spine.BoundingBoxAttachment,"ps":0},{"n":"depth","dv":0.0,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"GetBoundingBoxBounds","rt":$n[4].Bounds,"p":[spine.BoundingBoxAttachment,$n[0].Single]},{"a":1,"n":"HandleRendererReset","t":8,"pi":[{"n":"g","pt":$n[2].SkeletonGraphic,"ps":0}],"sn":"HandleRendererReset","rt":$n[0].Void,"p":[$n[2].SkeletonGraphic]},{"a":1,"n":"HandleRendererReset","t":8,"pi":[{"n":"r","pt":$n[2].SkeletonRenderer,"ps":0}],"sn":"HandleRendererReset$1","rt":$n[0].Void,"p":[$n[2].SkeletonRenderer]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"RegisterBone","t":8,"pi":[{"n":"bone","pt":$n[2].SkeletonUtilityBone,"ps":0}],"sn":"RegisterBone","rt":$n[0].Void,"p":[$n[2].SkeletonUtilityBone]},{"a":2,"n":"RegisterConstraint","t":8,"pi":[{"n":"constraint","pt":$n[2].SkeletonUtilityConstraint,"ps":0}],"sn":"RegisterConstraint","rt":$n[0].Void,"p":[$n[2].SkeletonUtilityConstraint]},{"a":2,"n":"ResubscribeEvents","t":8,"sn":"ResubscribeEvents","rt":$n[0].Void},{"a":2,"n":"SetColliderPointsLocal","is":true,"t":8,"pi":[{"n":"collider","pt":$n[4].PolygonCollider2D,"ps":0},{"n":"slot","pt":$n[1].Slot,"ps":1},{"n":"box","pt":spine.BoundingBoxAttachment,"ps":2},{"n":"scale","dv":1.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"SetColliderPointsLocal","rt":$n[0].Void,"p":[$n[4].PolygonCollider2D,$n[1].Slot,spine.BoundingBoxAttachment,$n[0].Single]},{"a":2,"n":"SpawnBone","t":8,"pi":[{"n":"bone","pt":$n[1].Bone,"ps":0},{"n":"parent","pt":$n[4].Transform,"ps":1},{"n":"mode","pt":$n[2].SkeletonUtilityBone.Mode,"ps":2},{"n":"pos","pt":$n[0].Boolean,"ps":3},{"n":"rot","pt":$n[0].Boolean,"ps":4},{"n":"sca","pt":$n[0].Boolean,"ps":5}],"sn":"SpawnBone","rt":$n[4].GameObject,"p":[$n[1].Bone,$n[4].Transform,$n[2].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnBoneRecursively","t":8,"pi":[{"n":"bone","pt":$n[1].Bone,"ps":0},{"n":"parent","pt":$n[4].Transform,"ps":1},{"n":"mode","pt":$n[2].SkeletonUtilityBone.Mode,"ps":2},{"n":"pos","pt":$n[0].Boolean,"ps":3},{"n":"rot","pt":$n[0].Boolean,"ps":4},{"n":"sca","pt":$n[0].Boolean,"ps":5}],"sn":"SpawnBoneRecursively","rt":$n[4].GameObject,"p":[$n[1].Bone,$n[4].Transform,$n[2].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnHierarchy","t":8,"pi":[{"n":"mode","pt":$n[2].SkeletonUtilityBone.Mode,"ps":0},{"n":"pos","pt":$n[0].Boolean,"ps":1},{"n":"rot","pt":$n[0].Boolean,"ps":2},{"n":"sca","pt":$n[0].Boolean,"ps":3}],"sn":"SpawnHierarchy","rt":$n[4].GameObject,"p":[$n[2].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnRoot","t":8,"pi":[{"n":"mode","pt":$n[2].SkeletonUtilityBone.Mode,"ps":0},{"n":"pos","pt":$n[0].Boolean,"ps":1},{"n":"rot","pt":$n[0].Boolean,"ps":2},{"n":"sca","pt":$n[0].Boolean,"ps":3}],"sn":"SpawnRoot","rt":$n[4].GameObject,"p":[$n[2].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"UnregisterBone","t":8,"pi":[{"n":"bone","pt":$n[2].SkeletonUtilityBone,"ps":0}],"sn":"UnregisterBone","rt":$n[0].Void,"p":[$n[2].SkeletonUtilityBone]},{"a":2,"n":"UnregisterConstraint","t":8,"pi":[{"n":"constraint","pt":$n[2].SkeletonUtilityConstraint,"ps":0}],"sn":"UnregisterConstraint","rt":$n[0].Void,"p":[$n[2].SkeletonUtilityConstraint]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"UpdateAllBones","t":8,"pi":[{"n":"phase","pt":$n[2].SkeletonUtilityBone.UpdatePhase,"ps":0}],"sn":"UpdateAllBones","rt":$n[0].Void,"p":[$n[2].SkeletonUtilityBone.UpdatePhase]},{"a":1,"n":"UpdateComplete","t":8,"pi":[{"n":"anim","pt":$n[2].ISkeletonAnimation,"ps":0}],"sn":"UpdateComplete","rt":$n[0].Void,"p":[$n[2].ISkeletonAnimation]},{"a":1,"n":"UpdateLocal","t":8,"pi":[{"n":"anim","pt":$n[2].ISkeletonAnimation,"ps":0}],"sn":"UpdateLocal","rt":$n[0].Void,"p":[$n[2].ISkeletonAnimation]},{"a":1,"n":"UpdateWorld","t":8,"pi":[{"n":"anim","pt":$n[2].ISkeletonAnimation,"ps":0}],"sn":"UpdateWorld","rt":$n[0].Void,"p":[$n[2].ISkeletonAnimation]},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"PositionScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_PositionScale","t":8,"rt":$n[0].Single,"fg":"PositionScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"PositionScale"},{"a":2,"n":"Skeleton","t":16,"rt":$n[1].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[1].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonComponent","t":16,"rt":$n[2].ISkeletonComponent,"g":{"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[2].ISkeletonComponent,"fg":"SkeletonComponent"},"fn":"SkeletonComponent"},{"a":2,"n":"boneComponents","t":4,"rt":$n[3].List$1(Spine.Unity.SkeletonUtilityBone),"sn":"boneComponents"},{"a":2,"n":"boneRoot","t":4,"rt":$n[4].Transform,"sn":"boneRoot"},{"a":1,"n":"canvas","t":4,"rt":$n[4].Canvas,"sn":"canvas"},{"a":2,"n":"constraintComponents","t":4,"rt":$n[3].List$1(Spine.Unity.SkeletonUtilityConstraint),"sn":"constraintComponents"},{"a":2,"n":"flipBy180DegreeRotation","t":4,"rt":$n[0].Boolean,"sn":"flipBy180DegreeRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hasConstraints","t":4,"rt":$n[0].Boolean,"sn":"hasConstraints","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hasOverrideBones","t":4,"rt":$n[0].Boolean,"sn":"hasOverrideBones","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"needToReprocessBones","t":4,"rt":$n[0].Boolean,"sn":"needToReprocessBones","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"positionScale","t":4,"rt":$n[0].Single,"sn":"positionScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"skeletonAnimation","t":4,"rt":$n[2].ISkeletonAnimation,"sn":"skeletonAnimation"},{"a":1,"n":"skeletonComponent","t":4,"rt":$n[2].ISkeletonComponent,"sn":"skeletonComponent"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"skeletonGraphic","t":4,"rt":$n[2].SkeletonGraphic,"sn":"skeletonGraphic"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"skeletonRenderer","t":4,"rt":$n[2].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":2,"n":"OnReset","t":2,"ad":{"a":2,"n":"add_OnReset","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnReset","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnReset","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnReset","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonUtility end.*/

    /*Spine.Unity.SkeletonUtilityBone start.*/
    $m("Spine.Unity.SkeletonUtilityBone", function () { return {"nested":[$n[2].SkeletonUtilityBone.Mode,$n[2].SkeletonUtilityBone.UpdatePhase],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonUtilityBone"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtilityBone")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddBoundingBox","t":8,"pi":[{"n":"skinName","pt":$n[0].String,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2}],"sn":"AddBoundingBox","rt":$n[0].Void,"p":[$n[0].String,$n[0].String,$n[0].String]},{"a":2,"n":"BoneTransformModeIncompatible","is":true,"t":8,"pi":[{"n":"bone","pt":$n[1].Bone,"ps":0}],"sn":"BoneTransformModeIncompatible","rt":$n[0].Boolean,"p":[$n[1].Bone],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"DoUpdate","t":8,"pi":[{"n":"phase","pt":$n[2].SkeletonUtilityBone.UpdatePhase,"ps":0}],"sn":"DoUpdate","rt":$n[0].Void,"p":[$n[2].SkeletonUtilityBone.UpdatePhase]},{"a":1,"n":"HandleOnReset","t":8,"sn":"HandleOnReset","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"IncompatibleTransformMode","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IncompatibleTransformMode","t":8,"rt":$n[0].Boolean,"fg":"IncompatibleTransformMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IncompatibleTransformMode"},{"a":2,"n":"bone","t":4,"rt":$n[1].Bone,"sn":"bone"},{"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":1,"n":"cachedTransform","t":4,"rt":$n[4].Transform,"sn":"cachedTransform"},{"a":2,"n":"hierarchy","t":4,"rt":$n[2].SkeletonUtility,"sn":"hierarchy"},{"a":1,"n":"incompatibleTransformMode","t":4,"rt":$n[0].Boolean,"sn":"incompatibleTransformMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"mode","t":4,"rt":$n[2].SkeletonUtilityBone.Mode,"sn":"mode","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"overrideAlpha","t":4,"rt":$n[0].Single,"sn":"overrideAlpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"parentReference","t":4,"rt":$n[4].Transform,"sn":"parentReference"},{"a":2,"n":"position","t":4,"rt":$n[0].Boolean,"sn":"position","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rotation","t":4,"rt":$n[0].Boolean,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"scale","t":4,"rt":$n[0].Boolean,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[4].Transform,"sn":"skeletonTransform"},{"a":2,"n":"transformLerpComplete","t":4,"rt":$n[0].Boolean,"sn":"transformLerpComplete","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"zPosition","t":4,"rt":$n[0].Boolean,"sn":"zPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone end.*/

    /*Spine.Unity.SkeletonUtilityBone+Mode start.*/
    $m("Spine.Unity.SkeletonUtilityBone.Mode", function () { return {"td":$n[2].SkeletonUtilityBone,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Follow","is":true,"t":4,"rt":$n[2].SkeletonUtilityBone.Mode,"sn":"Follow","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}},{"a":2,"n":"Override","is":true,"t":4,"rt":$n[2].SkeletonUtilityBone.Mode,"sn":"Override","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone+Mode end.*/

    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase start.*/
    $m("Spine.Unity.SkeletonUtilityBone.UpdatePhase", function () { return {"td":$n[2].SkeletonUtilityBone,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","is":true,"t":4,"rt":$n[2].SkeletonUtilityBone.UpdatePhase,"sn":"Complete","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}},{"a":2,"n":"Local","is":true,"t":4,"rt":$n[2].SkeletonUtilityBone.UpdatePhase,"sn":"Local","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}},{"a":2,"n":"World","is":true,"t":4,"rt":$n[2].SkeletonUtilityBone.UpdatePhase,"sn":"World","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase end.*/

    /*Spine.Unity.SkeletonUtilityConstraint start.*/
    $m("Spine.Unity.SkeletonUtilityConstraint", function () { return {"att":1048705,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(Spine.Unity.SkeletonUtilityBone),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtilityConstraint")],"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"DoUpdate","t":8,"sn":"DoUpdate","rt":$n[0].Void},{"v":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"v":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":3,"n":"bone","t":4,"rt":$n[2].SkeletonUtilityBone,"sn":"bone"},{"a":3,"n":"hierarchy","t":4,"rt":$n[2].SkeletonUtility,"sn":"hierarchy"}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityConstraint end.*/

    /*Spine.Unity.UpdateMode start.*/
    $m("Spine.Unity.UpdateMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"EverythingExceptMesh","is":true,"t":4,"rt":$n[2].UpdateMode,"sn":"EverythingExceptMesh","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"FullUpdate","is":true,"t":4,"rt":$n[2].UpdateMode,"sn":"FullUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"Nothing","is":true,"t":4,"rt":$n[2].UpdateMode,"sn":"Nothing","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"OnlyAnimationStatus","is":true,"t":4,"rt":$n[2].UpdateMode,"sn":"OnlyAnimationStatus","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"OnlyEventTimelines","is":true,"t":4,"rt":$n[2].UpdateMode,"sn":"OnlyEventTimelines","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}}]}; }, $n);
    /*Spine.Unity.UpdateMode end.*/

    /*Spine.Unity.ISpineComponent start.*/
    $m("Spine.Unity.ISpineComponent", function () { return {"att":1048737,"a":2}; }, $n);
    /*Spine.Unity.ISpineComponent end.*/

    /*Spine.Unity.ISpineComponentExtensions start.*/
    $m("Spine.Unity.ISpineComponentExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"IsNullOrDestroyed","is":true,"t":8,"pi":[{"n":"component","pt":$n[2].ISpineComponent,"ps":0}],"sn":"IsNullOrDestroyed","rt":$n[0].Boolean,"p":[$n[2].ISpineComponent],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.ISpineComponentExtensions end.*/

    /*Spine.Unity.ISkeletonAnimation start.*/
    $m("Spine.Unity.ISkeletonAnimation", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"Skeleton","t":16,"rt":$n[1].Skeleton,"g":{"ab":true,"a":2,"n":"get_Skeleton","t":8,"rt":$n[1].Skeleton,"fg":"Spine$Unity$ISkeletonAnimation$Skeleton"},"fn":"Spine$Unity$ISkeletonAnimation$Skeleton"},{"ab":true,"a":2,"n":"UpdateComplete","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateLocal","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateWorld","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":1,"backing":true,"n":"<Skeleton>k__BackingField","t":4,"rt":$n[1].Skeleton,"sn":"Spine$Unity$ISkeletonAnimation$Skeleton"}]}; }, $n);
    /*Spine.Unity.ISkeletonAnimation end.*/

    /*Spine.Unity.IHasSkeletonDataAsset start.*/
    $m("Spine.Unity.IHasSkeletonDataAsset", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[2].SkeletonDataAsset,"g":{"ab":true,"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[2].SkeletonDataAsset,"fg":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"},"fn":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"},{"a":1,"backing":true,"n":"<SkeletonDataAsset>k__BackingField","t":4,"rt":$n[2].SkeletonDataAsset,"sn":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonDataAsset end.*/

    /*Spine.Unity.ISkeletonComponent start.*/
    $m("Spine.Unity.ISkeletonComponent", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"Skeleton","t":16,"rt":$n[1].Skeleton,"g":{"ab":true,"a":2,"n":"get_Skeleton","t":8,"rt":$n[1].Skeleton,"fg":"Spine$Unity$ISkeletonComponent$Skeleton"},"fn":"Spine$Unity$ISkeletonComponent$Skeleton"},{"ab":true,"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[2].SkeletonDataAsset,"g":{"ab":true,"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[2].SkeletonDataAsset,"fg":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"},"fn":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"},{"a":1,"backing":true,"n":"<Skeleton>k__BackingField","t":4,"rt":$n[1].Skeleton,"sn":"Spine$Unity$ISkeletonComponent$Skeleton"},{"a":1,"backing":true,"n":"<SkeletonDataAsset>k__BackingField","t":4,"rt":$n[2].SkeletonDataAsset,"sn":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.ISkeletonComponent end.*/

    /*Spine.Unity.IAnimationStateComponent start.*/
    $m("Spine.Unity.IAnimationStateComponent", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"AnimationState","t":16,"rt":$n[1].AnimationState,"g":{"ab":true,"a":2,"n":"get_AnimationState","t":8,"rt":$n[1].AnimationState,"fg":"Spine$Unity$IAnimationStateComponent$AnimationState"},"fn":"Spine$Unity$IAnimationStateComponent$AnimationState"},{"a":1,"backing":true,"n":"<AnimationState>k__BackingField","t":4,"rt":$n[1].AnimationState,"sn":"Spine$Unity$IAnimationStateComponent$AnimationState"}]}; }, $n);
    /*Spine.Unity.IAnimationStateComponent end.*/

    /*Spine.Unity.IHasSkeletonRenderer start.*/
    $m("Spine.Unity.IHasSkeletonRenderer", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[2].SkeletonRenderer,"g":{"ab":true,"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[2].SkeletonRenderer,"fg":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"},"fn":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"},{"a":1,"backing":true,"n":"<SkeletonRenderer>k__BackingField","t":4,"rt":$n[2].SkeletonRenderer,"sn":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonRenderer end.*/

    /*Spine.Unity.IHasSkeletonComponent start.*/
    $m("Spine.Unity.IHasSkeletonComponent", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonComponent","t":16,"rt":$n[2].ISkeletonComponent,"g":{"ab":true,"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[2].ISkeletonComponent,"fg":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"},"fn":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"},{"a":1,"backing":true,"n":"<SkeletonComponent>k__BackingField","t":4,"rt":$n[2].ISkeletonComponent,"sn":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonComponent end.*/

    /*Spine.Unity.DoubleBuffered$1 start.*/
    $m("Spine.Unity.DoubleBuffered$1", function (T) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetCurrent","t":8,"sn":"GetCurrent","rt":T},{"a":2,"n":"GetNext","t":8,"sn":"GetNext","rt":T},{"a":1,"n":"a","t":4,"rt":T,"sn":"a","ro":true},{"a":1,"n":"b","t":4,"rt":T,"sn":"b","ro":true},{"a":1,"n":"usingA","t":4,"rt":$n[0].Boolean,"sn":"usingA","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.DoubleBuffered$1 end.*/

    /*Spine.Unity.MeshGeneratorBuffers start.*/
    $m("Spine.Unity.MeshGeneratorBuffers", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"colorBuffer","t":4,"rt":System.Array.type(UnityEngine.Color32),"sn":"colorBuffer"},{"a":2,"n":"meshGenerator","t":4,"rt":$n[2].MeshGenerator,"sn":"meshGenerator"},{"a":2,"n":"uvBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector2),"sn":"uvBuffer"},{"a":2,"n":"vertexBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"vertexBuffer"},{"a":2,"n":"vertexCount","t":4,"rt":$n[0].Int32,"sn":"vertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.MeshGeneratorBuffers end.*/

    /*Spine.Unity.MeshGenerator start.*/
    $m("Spine.Unity.MeshGenerator", function () { return {"nested":[$n[2].MeshGenerator.Settings],"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddAttachmentTintBlack","t":8,"pi":[{"n":"r2","pt":$n[0].Single,"ps":0},{"n":"g2","pt":$n[0].Single,"ps":1},{"n":"b2","pt":$n[0].Single,"ps":2},{"n":"a","pt":$n[0].Single,"ps":3},{"n":"vertexCount","pt":$n[0].Int32,"ps":4}],"sn":"AddAttachmentTintBlack","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Int32]},{"a":2,"n":"AddSubmesh","t":8,"pi":[{"n":"instruction","pt":$n[2].SubmeshInstruction,"ps":0},{"n":"updateTriangles","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"AddSubmesh","rt":$n[0].Void,"p":[$n[2].SubmeshInstruction,$n[0].Boolean]},{"a":2,"n":"Begin","t":8,"sn":"Begin","rt":$n[0].Void},{"a":2,"n":"BuildMesh","t":8,"pi":[{"n":"instruction","pt":$n[2].SkeletonRendererInstruction,"ps":0},{"n":"updateTriangles","pt":$n[0].Boolean,"ps":1}],"sn":"BuildMesh","rt":$n[0].Void,"p":[$n[2].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"BuildMeshWithArrays","t":8,"pi":[{"n":"instruction","pt":$n[2].SkeletonRendererInstruction,"ps":0},{"n":"updateTriangles","pt":$n[0].Boolean,"ps":1}],"sn":"BuildMeshWithArrays","rt":$n[0].Void,"p":[$n[2].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"EnsureVertexCapacity","t":8,"pi":[{"n":"minimumVertexCount","pt":$n[0].Int32,"ps":0},{"n":"inlcudeTintBlack","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"includeTangents","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"includeNormals","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"EnsureVertexCapacity","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"FillLateVertexData","t":8,"pi":[{"n":"mesh","pt":$n[4].Mesh,"ps":0}],"sn":"FillLateVertexData","rt":$n[0].Void,"p":[$n[4].Mesh]},{"a":2,"n":"FillMeshLocal","is":true,"t":8,"pi":[{"n":"mesh","pt":$n[4].Mesh,"ps":0},{"n":"regionAttachment","pt":$n[1].RegionAttachment,"ps":1}],"sn":"FillMeshLocal$1","rt":$n[0].Void,"p":[$n[4].Mesh,$n[1].RegionAttachment]},{"a":2,"n":"FillMeshLocal","is":true,"t":8,"pi":[{"n":"mesh","pt":$n[4].Mesh,"ps":0},{"n":"meshAttachment","pt":$n[1].MeshAttachment,"ps":1},{"n":"skeletonData","pt":$n[1].SkeletonData,"ps":2}],"sn":"FillMeshLocal","rt":$n[0].Void,"p":[$n[4].Mesh,$n[1].MeshAttachment,$n[1].SkeletonData]},{"a":2,"n":"FillTriangles","t":8,"pi":[{"n":"mesh","pt":$n[4].Mesh,"ps":0}],"sn":"FillTriangles","rt":$n[0].Void,"p":[$n[4].Mesh]},{"a":2,"n":"FillVertexData","t":8,"pi":[{"n":"mesh","pt":$n[4].Mesh,"ps":0}],"sn":"FillVertexData","rt":$n[0].Void,"p":[$n[4].Mesh]},{"a":2,"n":"GenerateSingleSubmeshInstruction","is":true,"t":8,"pi":[{"n":"instructionOutput","pt":$n[2].SkeletonRendererInstruction,"ps":0},{"n":"skeleton","pt":$n[1].Skeleton,"ps":1},{"n":"material","pt":$n[4].Material,"ps":2}],"sn":"GenerateSingleSubmeshInstruction","rt":$n[0].Void,"p":[$n[2].SkeletonRendererInstruction,$n[1].Skeleton,$n[4].Material]},{"a":2,"n":"GenerateSkeletonRendererInstruction","is":true,"t":8,"pi":[{"n":"instructionOutput","pt":$n[2].SkeletonRendererInstruction,"ps":0},{"n":"skeleton","pt":$n[1].Skeleton,"ps":1},{"n":"customSlotMaterials","pt":$n[3].Dictionary$2(Spine.Slot,UnityEngine.Material),"ps":2},{"n":"separatorSlots","pt":$n[3].List$1(Spine.Slot),"ps":3},{"n":"generateMeshOverride","pt":$n[0].Boolean,"ps":4},{"n":"immutableTriangles","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"GenerateSkeletonRendererInstruction","rt":$n[0].Void,"p":[$n[2].SkeletonRendererInstruction,$n[1].Skeleton,$n[3].Dictionary$2(Spine.Slot,UnityEngine.Material),$n[3].List$1(Spine.Slot),$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"GetMeshBounds","t":8,"sn":"GetMeshBounds","rt":$n[4].Bounds},{"a":2,"n":"RequiresMultipleSubmeshesByDrawOrder","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[1].Skeleton,"ps":0}],"sn":"RequiresMultipleSubmeshesByDrawOrder","rt":$n[0].Boolean,"p":[$n[1].Skeleton],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ScaleVertexData","t":8,"pi":[{"n":"scale","pt":$n[0].Single,"ps":0}],"sn":"ScaleVertexData","rt":$n[0].Void,"p":[$n[0].Single]},{"a":4,"n":"SolveTangents2DBuffer","is":true,"t":8,"pi":[{"n":"tangents","pt":System.Array.type(UnityEngine.Vector4),"ps":0},{"n":"tempTanBuffer","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"vertexCount","pt":$n[0].Int32,"ps":2}],"sn":"SolveTangents2DBuffer","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector4),System.Array.type(UnityEngine.Vector2),$n[0].Int32]},{"a":4,"n":"SolveTangents2DEnsureSize","is":true,"t":8,"pi":[{"n":"tangentBuffer","ref":true,"pt":System.Array.type(UnityEngine.Vector4),"ps":0},{"n":"tempTanBuffer","ref":true,"pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"vertexCount","pt":$n[0].Int32,"ps":2},{"n":"vertexBufferLength","pt":$n[0].Int32,"ps":3}],"sn":"SolveTangents2DEnsureSize","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector4),System.Array.type(UnityEngine.Vector2),$n[0].Int32,$n[0].Int32]},{"a":4,"n":"SolveTangents2DTriangles","is":true,"t":8,"pi":[{"n":"tempTanBuffer","pt":System.Array.type(UnityEngine.Vector2),"ps":0},{"n":"triangles","pt":$n[0].Array.type(System.Int32),"ps":1},{"n":"triangleCount","pt":$n[0].Int32,"ps":2},{"n":"vertices","pt":System.Array.type(UnityEngine.Vector3),"ps":3},{"n":"uvs","pt":System.Array.type(UnityEngine.Vector2),"ps":4},{"n":"vertexCount","pt":$n[0].Int32,"ps":5}],"sn":"SolveTangents2DTriangles","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector2),$n[0].Array.type(System.Int32),$n[0].Int32,System.Array.type(UnityEngine.Vector3),System.Array.type(UnityEngine.Vector2),$n[0].Int32]},{"a":2,"n":"SubmeshIndexCount","t":8,"pi":[{"n":"submeshIndex","pt":$n[0].Int32,"ps":0}],"sn":"SubmeshIndexCount","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"TrimExcess","t":8,"sn":"TrimExcess","rt":$n[0].Void},{"a":2,"n":"TryReplaceMaterials","is":true,"t":8,"pi":[{"n":"workingSubmeshInstructions","pt":$n[1].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"customMaterialOverride","pt":$n[3].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"ps":1}],"sn":"TryReplaceMaterials","rt":$n[0].Void,"p":[$n[1].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[3].Dictionary$2(UnityEngine.Material,UnityEngine.Material)]},{"a":2,"n":"Buffers","t":16,"rt":$n[2].MeshGeneratorBuffers,"g":{"a":2,"n":"get_Buffers","t":8,"rt":$n[2].MeshGeneratorBuffers,"fg":"Buffers"},"fn":"Buffers"},{"a":2,"n":"VertexCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_VertexCount","t":8,"rt":$n[0].Int32,"fg":"VertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"VertexCount"},{"a":1,"n":"AttachmentColors32","is":true,"t":4,"rt":$n[3].List$1(UnityEngine.Color32),"sn":"AttachmentColors32"},{"a":1,"n":"AttachmentIndices","is":true,"t":4,"rt":$n[3].List$1(System.Int32),"sn":"AttachmentIndices"},{"a":1,"n":"AttachmentUVs","is":true,"t":4,"rt":$n[3].List$1(UnityEngine.Vector2),"sn":"AttachmentUVs"},{"a":1,"n":"AttachmentVerts","is":true,"t":4,"rt":$n[3].List$1(UnityEngine.Vector3),"sn":"AttachmentVerts"},{"a":1,"n":"BoundsMaxDefault","is":true,"t":4,"rt":$n[0].Single,"sn":"BoundsMaxDefault","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"BoundsMinDefault","is":true,"t":4,"rt":$n[0].Single,"sn":"BoundsMinDefault","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"clipper","t":4,"rt":$n[1].SkeletonClipping,"sn":"clipper"},{"a":3,"n":"colorBuffer","t":4,"rt":$n[1].ExposedList$1(UnityEngine.Color32),"sn":"colorBuffer","ro":true},{"a":1,"n":"meshBoundsMax","t":4,"rt":$n[4].Vector2,"sn":"meshBoundsMax"},{"a":1,"n":"meshBoundsMin","t":4,"rt":$n[4].Vector2,"sn":"meshBoundsMin"},{"a":1,"n":"meshBoundsThickness","t":4,"rt":$n[0].Single,"sn":"meshBoundsThickness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"normals","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"normals"},{"a":1,"n":"regionTriangles","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"regionTriangles"},{"a":2,"n":"settings","t":4,"rt":$n[2].MeshGenerator.Settings,"sn":"settings"},{"a":1,"n":"submeshIndex","t":4,"rt":$n[0].Int32,"sn":"submeshIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"submeshes","t":4,"rt":$n[1].ExposedList$1(Spine.ExposedList$1(System.Int32)),"sn":"submeshes","ro":true},{"a":1,"n":"tangents","t":4,"rt":System.Array.type(UnityEngine.Vector4),"sn":"tangents"},{"a":1,"n":"tempTanBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector2),"sn":"tempTanBuffer"},{"a":1,"n":"tempVerts","t":4,"rt":$n[0].Array.type(System.Single),"sn":"tempVerts"},{"a":1,"n":"uv2","t":4,"rt":$n[1].ExposedList$1(UnityEngine.Vector2),"sn":"uv2"},{"a":1,"n":"uv3","t":4,"rt":$n[1].ExposedList$1(UnityEngine.Vector2),"sn":"uv3"},{"a":3,"n":"uvBuffer","t":4,"rt":$n[1].ExposedList$1(UnityEngine.Vector2),"sn":"uvBuffer","ro":true},{"a":3,"n":"vertexBuffer","t":4,"rt":$n[1].ExposedList$1(UnityEngine.Vector3),"sn":"vertexBuffer","ro":true}]}; }, $n);
    /*Spine.Unity.MeshGenerator end.*/

    /*Spine.Unity.MeshGenerator+Settings start.*/
    $m("Spine.Unity.MeshGenerator.Settings", function () { return {"td":$n[2].MeshGenerator,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Default","is":true,"t":16,"rt":$n[2].MeshGenerator.Settings,"g":{"a":2,"n":"get_Default","t":8,"rt":$n[2].MeshGenerator.Settings,"fg":"Default","is":true},"fn":"Default"},{"a":2,"n":"addNormals","t":4,"rt":$n[0].Boolean,"sn":"addNormals","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"calculateTangents","t":4,"rt":$n[0].Boolean,"sn":"calculateTangents","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Enable when using Additive blend mode at SkeletonGraphic under a CanvasGroup. When enabled, Additive alpha value is stored at uv2.g instead of color.a to capture CanvasGroup modifying color.a.")],"a":2,"n":"canvasGroupTintBlack","t":4,"rt":$n[0].Boolean,"sn":"canvasGroupTintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.HeaderAttribute("Vertex Data")],"a":2,"n":"pmaVertexColors","t":4,"rt":$n[0].Boolean,"sn":"pmaVertexColors","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"tintBlack","t":4,"rt":$n[0].Boolean,"sn":"tintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"useClipping","t":4,"rt":$n[0].Boolean,"sn":"useClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.RangeAttribute(-0.1, 0.0)],"a":2,"n":"zSpacing","t":4,"rt":$n[0].Single,"sn":"zSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.MeshGenerator+Settings end.*/

    /*Spine.Unity.MeshRendererBuffers start.*/
    $m("Spine.Unity.MeshRendererBuffers", function () { return {"nested":[$n[2].MeshRendererBuffers.SmartMesh],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"GetNextMesh","t":8,"sn":"GetNextMesh","rt":$n[2].MeshRendererBuffers.SmartMesh},{"a":2,"n":"GetUpdatedSharedMaterialsArray","t":8,"sn":"GetUpdatedSharedMaterialsArray","rt":System.Array.type(UnityEngine.Material)},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"MaterialsChangedInLastUpdate","t":8,"sn":"MaterialsChangedInLastUpdate","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"UpdateSharedMaterials","t":8,"pi":[{"n":"instructions","pt":$n[1].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0}],"sn":"UpdateSharedMaterials","rt":$n[0].Void,"p":[$n[1].ExposedList$1(Spine.Unity.SubmeshInstruction)]},{"a":1,"n":"doubleBufferedMesh","t":4,"rt":$n[2].DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh),"sn":"doubleBufferedMesh"},{"a":4,"n":"sharedMaterials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"sharedMaterials"},{"a":4,"n":"submeshMaterials","t":4,"rt":$n[1].ExposedList$1(UnityEngine.Material),"sn":"submeshMaterials","ro":true}]}; }, $n);
    /*Spine.Unity.MeshRendererBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers+SmartMesh start.*/
    $m("Spine.Unity.MeshRendererBuffers.SmartMesh", function () { return {"td":$n[2].MeshRendererBuffers,"att":1048578,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"instructionUsed","t":4,"rt":$n[2].SkeletonRendererInstruction,"sn":"instructionUsed"},{"a":2,"n":"mesh","t":4,"rt":$n[4].Mesh,"sn":"mesh"}]}; }, $n);
    /*Spine.Unity.MeshRendererBuffers+SmartMesh end.*/

    /*Spine.Unity.SkeletonRendererInstruction start.*/
    $m("Spine.Unity.SkeletonRendererInstruction", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"GeometryNotEqual","is":true,"t":8,"pi":[{"n":"a","pt":$n[2].SkeletonRendererInstruction,"ps":0},{"n":"b","pt":$n[2].SkeletonRendererInstruction,"ps":1}],"sn":"GeometryNotEqual","rt":$n[0].Boolean,"p":[$n[2].SkeletonRendererInstruction,$n[2].SkeletonRendererInstruction],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Set","t":8,"pi":[{"n":"other","pt":$n[2].SkeletonRendererInstruction,"ps":0}],"sn":"Set","rt":$n[0].Void,"p":[$n[2].SkeletonRendererInstruction]},{"a":2,"n":"SetWithSubset","t":8,"pi":[{"n":"instructions","pt":$n[1].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"startSubmesh","pt":$n[0].Int32,"ps":1},{"n":"endSubmesh","pt":$n[0].Int32,"ps":2}],"sn":"SetWithSubset","rt":$n[0].Void,"p":[$n[1].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"attachments","t":4,"rt":$n[1].ExposedList$1(spine.Attachment),"sn":"attachments","ro":true},{"a":2,"n":"hasActiveClipping","t":4,"rt":$n[0].Boolean,"sn":"hasActiveClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rawVertexCount","t":4,"rt":$n[0].Int32,"sn":"rawVertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"submeshInstructions","t":4,"rt":$n[1].ExposedList$1(Spine.Unity.SubmeshInstruction),"sn":"submeshInstructions","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonRendererInstruction end.*/

    /*Spine.Unity.SpineMesh start.*/
    $m("Spine.Unity.SpineMesh", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"NewSkeletonMesh","is":true,"t":8,"sn":"NewSkeletonMesh","rt":$n[4].Mesh},{"a":4,"n":"MeshHideflags","is":true,"t":4,"rt":$n[4].HideFlags,"sn":"MeshHideflags","box":function ($v) { return Bridge.box($v, UnityEngine.HideFlags, System.Enum.toStringFn(UnityEngine.HideFlags));}}]}; }, $n);
    /*Spine.Unity.SpineMesh end.*/

    /*Spine.Unity.SubmeshInstruction start.*/
    $m("Spine.Unity.SubmeshInstruction", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"SlotCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotCount","t":8,"rt":$n[0].Int32,"fg":"SlotCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotCount"},{"a":2,"n":"endSlot","t":4,"rt":$n[0].Int32,"sn":"endSlot","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"forceSeparate","t":4,"rt":$n[0].Boolean,"sn":"forceSeparate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"hasClipping","t":4,"rt":$n[0].Boolean,"sn":"hasClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"hasPMAAdditiveSlot","t":4,"rt":$n[0].Boolean,"sn":"hasPMAAdditiveSlot","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"material","t":4,"rt":$n[4].Material,"sn":"material"},{"a":2,"n":"preActiveClippingSlotSource","t":4,"rt":$n[0].Int32,"sn":"preActiveClippingSlotSource","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawFirstVertexIndex","t":4,"rt":$n[0].Int32,"sn":"rawFirstVertexIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawTriangleCount","t":4,"rt":$n[0].Int32,"sn":"rawTriangleCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawVertexCount","t":4,"rt":$n[0].Int32,"sn":"rawVertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"skeleton","t":4,"rt":$n[1].Skeleton,"sn":"skeleton"},{"a":2,"n":"startSlot","t":4,"rt":$n[0].Int32,"sn":"startSlot","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.SubmeshInstruction end.*/

    /*Spine.Unity.BlendModeMaterialsAsset start.*/
    $m("Spine.Unity.BlendModeMaterialsAsset", function () { return {"nested":[$n[2].BlendModeMaterialsAsset.AtlasMaterialCache],"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/SkeletonData Modifiers/Blend Mode Materials", order: 200
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeletonData","pt":$n[1].SkeletonData,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[1].SkeletonData]},{"a":2,"n":"ApplyMaterials","is":true,"t":8,"pi":[{"n":"skeletonData","pt":$n[1].SkeletonData,"ps":0},{"n":"multiplyTemplate","pt":$n[4].Material,"ps":1},{"n":"screenTemplate","pt":$n[4].Material,"ps":2},{"n":"additiveTemplate","pt":$n[4].Material,"ps":3},{"n":"includeAdditiveSlots","pt":$n[0].Boolean,"ps":4}],"sn":"ApplyMaterials","rt":$n[0].Void,"p":[$n[1].SkeletonData,$n[4].Material,$n[4].Material,$n[4].Material,$n[0].Boolean]},{"a":2,"n":"additiveMaterialTemplate","t":4,"rt":$n[4].Material,"sn":"additiveMaterialTemplate"},{"a":2,"n":"applyAdditiveMaterial","t":4,"rt":$n[0].Boolean,"sn":"applyAdditiveMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"multiplyMaterialTemplate","t":4,"rt":$n[4].Material,"sn":"multiplyMaterialTemplate"},{"a":2,"n":"screenMaterialTemplate","t":4,"rt":$n[4].Material,"sn":"screenMaterialTemplate"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterialsAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache start.*/
    $m("Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache", function () { return {"td":$n[2].BlendModeMaterialsAsset,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"CloneAtlasRegionWithMaterial","t":8,"pi":[{"n":"originalRegion","pt":$n[1].AtlasRegion,"ps":0},{"n":"materialTemplate","pt":$n[4].Material,"ps":1}],"sn":"CloneAtlasRegionWithMaterial","rt":$n[1].AtlasRegion,"p":[$n[1].AtlasRegion,$n[4].Material]},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":1,"n":"GetAtlasPageWithMaterial","t":8,"pi":[{"n":"originalPage","pt":$n[1].AtlasPage,"ps":0},{"n":"materialTemplate","pt":$n[4].Material,"ps":1}],"sn":"GetAtlasPageWithMaterial","rt":$n[1].AtlasPage,"p":[$n[1].AtlasPage,$n[4].Material]},{"a":1,"n":"cache","t":4,"rt":$n[3].Dictionary$2(System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material),Spine.AtlasPage),"sn":"cache","ro":true}]}; }, $n);
    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache end.*/

    /*Spine.Unity.SpineAttributeBase start.*/
    $m("Spine.Unity.SpineAttributeBase", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"dataField","t":4,"rt":$n[0].String,"sn":"dataField"},{"a":2,"n":"fallbackToTextField","t":4,"rt":$n[0].Boolean,"sn":"fallbackToTextField","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"includeNone","t":4,"rt":$n[0].Boolean,"sn":"includeNone","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"startsWith","t":4,"rt":$n[0].String,"sn":"startsWith"}]}; }, $n);
    /*Spine.Unity.SpineAttributeBase end.*/

    /*Spine.Unity.SpineBone start.*/
    $m("Spine.Unity.SpineBone", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"},{"a":2,"n":"GetBone","is":true,"t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0},{"n":"renderer","pt":$n[2].SkeletonRenderer,"ps":1}],"sn":"getBone","rt":$n[1].Bone,"p":[$n[0].String,$n[2].SkeletonRenderer]},{"a":2,"n":"GetBoneData","is":true,"t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0},{"n":"skeletonDataAsset","pt":$n[2].SkeletonDataAsset,"ps":1}],"sn":"getBoneData","rt":spine.BoneData,"p":[$n[0].String,$n[2].SkeletonDataAsset]}]}; }, $n);
    /*Spine.Unity.SpineBone end.*/

    /*Spine.Unity.SpineSlot start.*/
    $m("Spine.Unity.SpineSlot", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"containsBoundingBoxes","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"containsBoundingBoxes","t":4,"rt":$n[0].Boolean,"sn":"containsBoundingBoxes","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSlot end.*/

    /*Spine.Unity.SpineAnimation start.*/
    $m("Spine.Unity.SpineAnimation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineAnimation end.*/

    /*Spine.Unity.SpineEvent start.*/
    $m("Spine.Unity.SpineEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"audioOnly","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"audioOnly","t":4,"rt":$n[0].Boolean,"sn":"audioOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineEvent end.*/

    /*Spine.Unity.SpineIkConstraint start.*/
    $m("Spine.Unity.SpineIkConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineIkConstraint end.*/

    /*Spine.Unity.SpineTransformConstraint start.*/
    $m("Spine.Unity.SpineTransformConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineTransformConstraint end.*/

    /*Spine.Unity.SpinePathConstraint start.*/
    $m("Spine.Unity.SpinePathConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpinePathConstraint end.*/

    /*Spine.Unity.SpineSkin start.*/
    $m("Spine.Unity.SpineSkin", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"defaultAsEmptyString","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"defaultAsEmptyString","t":4,"rt":$n[0].Boolean,"sn":"defaultAsEmptyString","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSkin end.*/

    /*Spine.Unity.SpineAttachment start.*/
    $m("Spine.Unity.SpineAttachment", function () { return {"nested":[$n[2].SpineAttachment.Hierarchy],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].String,$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"currentSkinOnly","dv":true,"o":true,"pt":$n[0].Boolean,"ps":0},{"n":"returnAttachmentPath","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"placeholdersOnly","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"slotField","dv":"","o":true,"pt":$n[0].String,"ps":3},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":4},{"n":"skinField","dv":"","o":true,"pt":$n[0].String,"ps":5},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":7}],"sn":"ctor"},{"a":2,"n":"GetAttachment","is":true,"t":8,"pi":[{"n":"attachmentPath","pt":$n[0].String,"ps":0},{"n":"skeletonData","pt":$n[1].SkeletonData,"ps":1}],"sn":"getAttachment","rt":spine.Attachment,"p":[$n[0].String,$n[1].SkeletonData]},{"a":2,"n":"GetAttachment","is":true,"t":8,"pi":[{"n":"attachmentPath","pt":$n[0].String,"ps":0},{"n":"skeletonDataAsset","pt":$n[2].SkeletonDataAsset,"ps":1}],"sn":"getAttachment$1","rt":spine.Attachment,"p":[$n[0].String,$n[2].SkeletonDataAsset]},{"a":2,"n":"GetHierarchy","is":true,"t":8,"pi":[{"n":"fullPath","pt":$n[0].String,"ps":0}],"sn":"getHierarchy","rt":$n[2].SpineAttachment.Hierarchy,"p":[$n[0].String]},{"a":2,"n":"currentSkinOnly","t":4,"rt":$n[0].Boolean,"sn":"currentSkinOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"placeholdersOnly","t":4,"rt":$n[0].Boolean,"sn":"placeholdersOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"returnAttachmentPath","t":4,"rt":$n[0].Boolean,"sn":"returnAttachmentPath","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"skinField","t":4,"rt":$n[0].String,"sn":"skinField"},{"a":2,"n":"slotField","t":4,"rt":$n[0].String,"sn":"slotField"}]}; }, $n);
    /*Spine.Unity.SpineAttachment end.*/

    /*Spine.Unity.SpineAttachment+Hierarchy start.*/
    $m("Spine.Unity.SpineAttachment.Hierarchy", function () { return {"td":$n[2].SpineAttachment,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"fullPath","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":2,"n":"skin","t":4,"rt":$n[0].String,"sn":"skin"},{"a":2,"n":"slot","t":4,"rt":$n[0].String,"sn":"slot"}]}; }, $n);
    /*Spine.Unity.SpineAttachment+Hierarchy end.*/

    /*Spine.Unity.SpineAtlasRegion start.*/
    $m("Spine.Unity.SpineAtlasRegion", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"atlasAssetField","dv":"","o":true,"pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"atlasAssetField","t":4,"rt":$n[0].String,"sn":"atlasAssetField"}]}; }, $n);
    /*Spine.Unity.SpineAtlasRegion end.*/

    /*Spine.Unity.SkeletonExtensions start.*/
    $m("Spine.Unity.SkeletonExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"a","pt":$n[1].MeshAttachment,"ps":0}],"sn":"GetColor","rt":$n[4].Color,"p":[$n[1].MeshAttachment]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"a","pt":$n[1].RegionAttachment,"ps":0}],"sn":"GetColor$1","rt":$n[4].Color,"p":[$n[1].RegionAttachment]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Skeleton,"ps":0}],"sn":"GetColor$2","rt":$n[4].Color,"p":[$n[1].Skeleton]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Slot,"ps":0}],"sn":"GetColor$3","rt":$n[4].Color,"p":[$n[1].Slot]},{"a":2,"n":"GetColorTintBlack","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Slot,"ps":0}],"sn":"GetColorTintBlack","rt":$n[4].Color,"p":[$n[1].Slot]},{"a":2,"n":"GetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[1].Bone,"ps":0}],"sn":"GetLocalPosition","rt":$n[4].Vector2,"p":[$n[1].Bone]},{"a":2,"n":"GetLocalQuaternion","is":true,"t":8,"pi":[{"n":"bone","pt":$n[1].Bone,"ps":0}],"sn":"GetLocalQuaternion","rt":$n[4].Quaternion,"p":[$n[1].Bone]},{"a":2,"n":"GetLocalScale","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[1].Skeleton,"ps":0}],"sn":"GetLocalScale","rt":$n[4].Vector2,"p":[$n[1].Skeleton]},{"a":2,"n":"GetLocalVertices","is":true,"t":8,"pi":[{"n":"va","pt":spine.VertexAttachment,"ps":0},{"n":"slot","pt":$n[1].Slot,"ps":1},{"n":"buffer","pt":System.Array.type(UnityEngine.Vector2),"ps":2}],"sn":"GetLocalVertices","rt":System.Array.type(UnityEngine.Vector2),"p":[spine.VertexAttachment,$n[1].Slot,System.Array.type(UnityEngine.Vector2)]},{"a":2,"n":"GetMaterial","is":true,"t":8,"pi":[{"n":"a","pt":spine.Attachment,"ps":0}],"sn":"GetMaterial","rt":$n[4].Material,"p":[spine.Attachment]},{"a":2,"n":"GetMatrix4x4","is":true,"t":8,"pi":[{"n":"bone","pt":$n[1].Bone,"ps":0}],"sn":"GetMatrix4x4","rt":$n[4].Matrix4x4,"p":[$n[1].Bone]},{"a":2,"n":"GetQuaternion","is":true,"t":8,"pi":[{"n":"bone","pt":$n[1].Bone,"ps":0}],"sn":"GetQuaternion","rt":$n[4].Quaternion,"p":[$n[1].Bone]},{"a":2,"n":"GetSkeletonSpacePosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[1].Bone,"ps":0}],"sn":"GetSkeletonSpacePosition","rt":$n[4].Vector2,"p":[$n[1].Bone]},{"a":2,"n":"GetSkeletonSpacePosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[1].Bone,"ps":0},{"n":"boneLocal","pt":$n[4].Vector2,"ps":1}],"sn":"GetSkeletonSpacePosition$1","rt":$n[4].Vector2,"p":[$n[1].Bone,$n[4].Vector2]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[1].Bone,"ps":0},{"n":"spineGameObjectTransform","pt":$n[4].Transform,"ps":1}],"sn":"GetWorldPosition","rt":$n[4].Vector3,"p":[$n[1].Bone,$n[4].Transform]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[1].Bone,"ps":0},{"n":"spineGameObjectTransform","pt":$n[4].Transform,"ps":1},{"n":"positionScale","pt":$n[0].Single,"ps":2}],"sn":"GetWorldPosition$1","rt":$n[4].Vector3,"p":[$n[1].Bone,$n[4].Transform,$n[0].Single]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[1].PointAttachment,"ps":0},{"n":"bone","pt":$n[1].Bone,"ps":1},{"n":"spineGameObjectTransform","pt":$n[4].Transform,"ps":2}],"sn":"GetWorldPosition$2","rt":$n[4].Vector3,"p":[$n[1].PointAttachment,$n[1].Bone,$n[4].Transform]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[1].PointAttachment,"ps":0},{"n":"slot","pt":$n[1].Slot,"ps":1},{"n":"spineGameObjectTransform","pt":$n[4].Transform,"ps":2}],"sn":"GetWorldPosition$3","rt":$n[4].Vector3,"p":[$n[1].PointAttachment,$n[1].Slot,$n[4].Transform]},{"a":2,"n":"GetWorldToLocalMatrix","is":true,"t":8,"pi":[{"n":"bone","pt":$n[1].Bone,"ps":0},{"n":"ia","out":true,"pt":$n[0].Single,"ps":1},{"n":"ib","out":true,"pt":$n[0].Single,"ps":2},{"n":"ic","out":true,"pt":$n[0].Single,"ps":3},{"n":"id","out":true,"pt":$n[0].Single,"ps":4}],"sn":"GetWorldToLocalMatrix","rt":$n[0].Void,"p":[$n[1].Bone,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"GetWorldVertices","is":true,"t":8,"pi":[{"n":"a","pt":spine.VertexAttachment,"ps":0},{"n":"slot","pt":$n[1].Slot,"ps":1},{"n":"buffer","pt":System.Array.type(UnityEngine.Vector2),"ps":2}],"sn":"GetWorldVertices","rt":System.Array.type(UnityEngine.Vector2),"p":[spine.VertexAttachment,$n[1].Slot,System.Array.type(UnityEngine.Vector2)]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[1].MeshAttachment,"ps":0},{"n":"color","pt":$n[4].Color,"ps":1}],"sn":"SetColor","rt":$n[0].Void,"p":[$n[1].MeshAttachment,$n[4].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[1].MeshAttachment,"ps":0},{"n":"color","pt":$n[4].Color32,"ps":1}],"sn":"SetColor$1","rt":$n[0].Void,"p":[$n[1].MeshAttachment,$n[4].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[1].RegionAttachment,"ps":0},{"n":"color","pt":$n[4].Color,"ps":1}],"sn":"SetColor$2","rt":$n[0].Void,"p":[$n[1].RegionAttachment,$n[4].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[1].RegionAttachment,"ps":0},{"n":"color","pt":$n[4].Color32,"ps":1}],"sn":"SetColor$3","rt":$n[0].Void,"p":[$n[1].RegionAttachment,$n[4].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[1].Skeleton,"ps":0},{"n":"color","pt":$n[4].Color,"ps":1}],"sn":"SetColor$4","rt":$n[0].Void,"p":[$n[1].Skeleton,$n[4].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[1].Skeleton,"ps":0},{"n":"color","pt":$n[4].Color32,"ps":1}],"sn":"SetColor$5","rt":$n[0].Void,"p":[$n[1].Skeleton,$n[4].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"slot","pt":$n[1].Slot,"ps":0},{"n":"color","pt":$n[4].Color,"ps":1}],"sn":"SetColor$6","rt":$n[0].Void,"p":[$n[1].Slot,$n[4].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"slot","pt":$n[1].Slot,"ps":0},{"n":"color","pt":$n[4].Color32,"ps":1}],"sn":"SetColor$7","rt":$n[0].Void,"p":[$n[1].Slot,$n[4].Color32]},{"a":2,"n":"SetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[1].Bone,"ps":0},{"n":"position","pt":$n[4].Vector2,"ps":1}],"sn":"SetLocalPosition","rt":$n[0].Void,"p":[$n[1].Bone,$n[4].Vector2]},{"a":2,"n":"SetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[1].Bone,"ps":0},{"n":"position","pt":$n[4].Vector3,"ps":1}],"sn":"SetLocalPosition$1","rt":$n[0].Void,"p":[$n[1].Bone,$n[4].Vector3]},{"a":2,"n":"SetLocalScale","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[1].Skeleton,"ps":0},{"n":"scale","pt":$n[4].Vector2,"ps":1}],"sn":"SetLocalScale","rt":$n[0].Void,"p":[$n[1].Skeleton,$n[4].Vector2]},{"a":2,"n":"SetPositionSkeletonSpace","is":true,"t":8,"pi":[{"n":"bone","pt":$n[1].Bone,"ps":0},{"n":"skeletonSpacePosition","pt":$n[4].Vector2,"ps":1}],"sn":"SetPositionSkeletonSpace","rt":$n[4].Vector2,"p":[$n[1].Bone,$n[4].Vector2]},{"a":2,"n":"WorldToLocal","is":true,"t":8,"pi":[{"n":"bone","pt":$n[1].Bone,"ps":0},{"n":"worldPosition","pt":$n[4].Vector2,"ps":1}],"sn":"WorldToLocal","rt":$n[4].Vector2,"p":[$n[1].Bone,$n[4].Vector2]},{"a":1,"n":"ByteToFloat","is":true,"t":4,"rt":$n[0].Single,"sn":"ByteToFloat","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.SkeletonExtensions end.*/

    /*Spine.Unity.WaitForSpineEvent start.*/
    $m("Spine.Unity.WaitForSpineEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[1].AnimationState,spine.EventData,$n[0].Boolean],"pi":[{"n":"state","pt":$n[1].AnimationState,"ps":0},{"n":"eventDataReference","pt":spine.EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[1].AnimationState,$n[0].String,$n[0].Boolean],"pi":[{"n":"state","pt":$n[1].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[2].SkeletonAnimation,spine.EventData,$n[0].Boolean],"pi":[{"n":"skeletonAnimation","pt":$n[2].SkeletonAnimation,"ps":0},{"n":"eventDataReference","pt":spine.EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor2"},{"a":2,"n":".ctor","t":1,"p":[$n[2].SkeletonAnimation,$n[0].String,$n[0].Boolean],"pi":[{"n":"skeletonAnimation","pt":$n[2].SkeletonAnimation,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor3"},{"a":1,"n":"Clear","t":8,"pi":[{"n":"state","pt":$n[1].AnimationState,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[1].AnimationState]},{"a":1,"n":"HandleAnimationStateEvent","t":8,"pi":[{"n":"trackEntry","pt":$n[1].TrackEntry,"ps":0},{"n":"e","pt":spine.Event,"ps":1}],"sn":"HandleAnimationStateEvent","rt":$n[0].Void,"p":[$n[1].TrackEntry,spine.Event]},{"a":1,"n":"HandleAnimationStateEventByName","t":8,"pi":[{"n":"trackEntry","pt":$n[1].TrackEntry,"ps":0},{"n":"e","pt":spine.Event,"ps":1}],"sn":"HandleAnimationStateEventByName","rt":$n[0].Void,"p":[$n[1].TrackEntry,spine.Event]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"state","pt":$n[1].AnimationState,"ps":0},{"n":"eventDataReference","pt":spine.EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"NowWaitFor","rt":$n[2].WaitForSpineEvent,"p":[$n[1].AnimationState,spine.EventData,$n[0].Boolean]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"state","pt":$n[1].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"NowWaitFor$1","rt":$n[2].WaitForSpineEvent,"p":[$n[1].AnimationState,$n[0].String,$n[0].Boolean]},{"a":1,"n":"Subscribe","t":8,"pi":[{"n":"state","pt":$n[1].AnimationState,"ps":0},{"n":"eventDataReference","pt":spine.EventData,"ps":1},{"n":"unsubscribe","pt":$n[0].Boolean,"ps":2}],"sn":"Subscribe","rt":$n[0].Void,"p":[$n[1].AnimationState,spine.EventData,$n[0].Boolean]},{"a":1,"n":"SubscribeByName","t":8,"pi":[{"n":"state","pt":$n[1].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribe","pt":$n[0].Boolean,"ps":2}],"sn":"SubscribeByName","rt":$n[0].Void,"p":[$n[1].AnimationState,$n[0].String,$n[0].Boolean]},{"a":2,"n":"WillUnsubscribeAfterFiring","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_WillUnsubscribeAfterFiring","t":8,"rt":$n[0].Boolean,"fg":"WillUnsubscribeAfterFiring","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_WillUnsubscribeAfterFiring","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"WillUnsubscribeAfterFiring"},"fn":"WillUnsubscribeAfterFiring"},{"a":1,"n":"m_AnimationState","t":4,"rt":$n[1].AnimationState,"sn":"m_AnimationState"},{"a":1,"n":"m_EventName","t":4,"rt":$n[0].String,"sn":"m_EventName"},{"a":1,"n":"m_TargetEvent","t":4,"rt":spine.EventData,"sn":"m_TargetEvent"},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"m_unsubscribeAfterFiring","t":4,"rt":$n[0].Boolean,"sn":"m_unsubscribeAfterFiring","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineEvent end.*/

    /*Spine.Unity.AnimationTools.TimelineExtensions start.*/
    $m("Spine.Unity.AnimationTools.TimelineExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.TranslateTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"skeletonData","dv":null,"o":true,"pt":$n[1].SkeletonData,"ps":2}],"sn":"Evaluate","rt":$n[4].Vector2,"p":[spine.TranslateTimeline,$n[0].Single,$n[1].SkeletonData]},{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"xTimeline","pt":spine.TranslateXTimeline,"ps":0},{"n":"yTimeline","pt":spine.TranslateYTimeline,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"skeletonData","dv":null,"o":true,"pt":$n[1].SkeletonData,"ps":3}],"sn":"Evaluate$1","rt":$n[4].Vector2,"p":[spine.TranslateXTimeline,spine.TranslateYTimeline,$n[0].Single,$n[1].SkeletonData]},{"a":2,"n":"FindTimelineForBone","is":true,"t":8,"pi":[{"n":"a","pt":$n[1].Animation,"ps":0},{"n":"boneIndex","pt":$n[0].Int32,"ps":1}],"tpc":1,"tprm":["T"],"sn":"FindTimelineForBone","rt":System.Object,"p":[$n[1].Animation,$n[0].Int32]},{"a":2,"n":"FindTranslateTimelineForBone","is":true,"t":8,"pi":[{"n":"a","pt":$n[1].Animation,"ps":0},{"n":"boneIndex","pt":$n[0].Int32,"ps":1}],"sn":"FindTranslateTimelineForBone","rt":spine.TranslateTimeline,"p":[$n[1].Animation,$n[0].Int32]}]}; }, $n);
    /*Spine.Unity.AnimationTools.TimelineExtensions end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities start.*/
    $m("Spine.Unity.AttachmentTools.AtlasUtilities", function () { return {"nested":[$n[8].AtlasUtilities.IntAndAtlasRegionKey],"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"ClearCache","is":true,"t":8,"sn":"ClearCache","rt":$n[0].Void},{"a":1,"n":"CopyTexture","is":true,"t":8,"pi":[{"n":"source","pt":$n[4].Texture2D,"ps":0},{"n":"sourceRect","pt":$n[4].Rect,"ps":1},{"n":"destination","pt":$n[4].Texture2D,"ps":2}],"sn":"CopyTexture","rt":$n[0].Void,"p":[$n[4].Texture2D,$n[4].Rect,$n[4].Texture2D]},{"a":1,"n":"CopyTextureApplyPMA","is":true,"t":8,"pi":[{"n":"source","pt":$n[4].Texture2D,"ps":0},{"n":"sourceRect","pt":$n[4].Rect,"ps":1},{"n":"destination","pt":$n[4].Texture2D,"ps":2}],"sn":"CopyTextureApplyPMA","rt":$n[0].Void,"p":[$n[4].Texture2D,$n[4].Rect,$n[4].Texture2D]},{"a":1,"n":"CopyTextureAttributesFrom","is":true,"t":8,"pi":[{"n":"destination","pt":$n[4].Texture2D,"ps":0},{"n":"source","pt":$n[4].Texture2D,"ps":1}],"sn":"CopyTextureAttributesFrom","rt":$n[0].Void,"p":[$n[4].Texture2D,$n[4].Texture2D]},{"a":1,"n":"GetClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Texture2D,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[4].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"GetClone","rt":$n[4].Texture2D,"p":[$n[4].Texture2D,$n[4].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"GetMainTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[1].AtlasRegion,"ps":0}],"sn":"GetMainTexture","rt":$n[4].Texture2D,"p":[$n[1].AtlasRegion]},{"a":2,"n":"GetRepackedAttachments","is":true,"t":8,"pi":[{"n":"sourceAttachments","pt":$n[3].List$1(spine.Attachment),"ps":0},{"n":"outputAttachments","pt":$n[3].List$1(spine.Attachment),"ps":1},{"n":"materialPropertySource","pt":$n[4].Material,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[4].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[4].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[4].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"newAssetName","dv":"Repacked Attachments","o":true,"pt":$n[0].String,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":11},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":12},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":13},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":14},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":15}],"sn":"GetRepackedAttachments","rt":$n[0].Void,"p":[$n[3].List$1(spine.Attachment),$n[3].List$1(spine.Attachment),$n[4].Material,$n[4].Material,$n[4].Texture2D,$n[0].Int32,$n[0].Int32,$n[4].TextureFormat,$n[0].Boolean,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":2,"n":"GetRepackedAttachments","is":true,"t":8,"pi":[{"n":"sourceAttachments","pt":$n[3].List$1(spine.Attachment),"ps":0},{"n":"outputAttachments","pt":$n[3].List$1(spine.Attachment),"ps":1},{"n":"shader","pt":$n[4].Shader,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[4].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[4].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[4].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"newAssetName","dv":"Repacked Attachments","o":true,"pt":$n[0].String,"ps":9},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[4].Material,"ps":10},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":11},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":12},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":13},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":14},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":15},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":16}],"sn":"GetRepackedAttachments$1","rt":$n[0].Void,"p":[$n[3].List$1(spine.Attachment),$n[3].List$1(spine.Attachment),$n[4].Shader,$n[4].Material,$n[4].Texture2D,$n[0].Int32,$n[0].Int32,$n[4].TextureFormat,$n[0].Boolean,$n[0].String,$n[4].Material,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":2,"n":"GetRepackedSkin","is":true,"t":8,"pi":[{"n":"o","pt":$n[1].Skin,"ps":0},{"n":"newName","pt":$n[0].String,"ps":1},{"n":"materialPropertySource","pt":$n[4].Material,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[4].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[4].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[4].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":11},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":12},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":13},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":14}],"sn":"GetRepackedSkin","rt":$n[1].Skin,"p":[$n[1].Skin,$n[0].String,$n[4].Material,$n[4].Material,$n[4].Texture2D,$n[0].Int32,$n[0].Int32,$n[4].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":2,"n":"GetRepackedSkin","is":true,"t":8,"pi":[{"n":"o","pt":$n[1].Skin,"ps":0},{"n":"newName","pt":$n[0].String,"ps":1},{"n":"shader","pt":$n[4].Shader,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[4].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[4].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[4].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[4].Material,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":11},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":12},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":13},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":14},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":15}],"sn":"GetRepackedSkin$1","rt":$n[1].Skin,"p":[$n[1].Skin,$n[0].String,$n[4].Shader,$n[4].Material,$n[4].Texture2D,$n[0].Int32,$n[0].Int32,$n[4].TextureFormat,$n[0].Boolean,$n[4].Material,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":1,"n":"GetSpineAtlasRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[1].AtlasRegion,"ps":0},{"n":"includeRotate","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"GetSpineAtlasRect","rt":$n[4].Rect,"p":[$n[1].AtlasRegion,$n[0].Boolean]},{"a":1,"n":"GetTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[1].AtlasRegion,"ps":0},{"n":"texturePropertyId","pt":$n[0].Int32,"ps":1}],"sn":"GetTexture","rt":$n[4].Texture2D,"p":[$n[1].AtlasRegion,$n[0].Int32]},{"a":1,"n":"GetTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[1].AtlasRegion,"ps":0},{"n":"texturePropertyName","pt":$n[0].String,"ps":1}],"sn":"GetTexture$1","rt":$n[4].Texture2D,"p":[$n[1].AtlasRegion,$n[0].String]},{"a":1,"n":"GetUnityRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[1].AtlasRegion,"ps":0}],"sn":"GetUnityRect","rt":$n[4].Rect,"p":[$n[1].AtlasRegion]},{"a":1,"n":"GetUnityRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[1].AtlasRegion,"ps":0},{"n":"textureHeight","pt":$n[0].Int32,"ps":1}],"sn":"GetUnityRect$1","rt":$n[4].Rect,"p":[$n[1].AtlasRegion,$n[0].Int32]},{"at":[new UnityEngine.RuntimeInitializeOnLoadMethodAttribute.$ctor1(4)],"a":1,"n":"Init","is":true,"t":8,"sn":"Init","rt":$n[0].Void},{"a":1,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0},{"n":"b","pt":$n[0].Single,"ps":1},{"n":"value","pt":$n[0].Single,"ps":2}],"sn":"InverseLerp","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"IsRenderable","is":true,"t":8,"pi":[{"n":"a","pt":spine.Attachment,"ps":0}],"sn":"IsRenderable","rt":$n[0].Boolean,"p":[spine.Attachment],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"SpineUnityFlipRect","is":true,"t":8,"pi":[{"n":"rect","pt":$n[4].Rect,"ps":0},{"n":"textureHeight","pt":$n[0].Int32,"ps":1}],"sn":"SpineUnityFlipRect","rt":$n[4].Rect,"p":[$n[4].Rect,$n[0].Int32]},{"a":1,"n":"TextureRectToUVRect","is":true,"t":8,"pi":[{"n":"textureRect","pt":$n[4].Rect,"ps":0},{"n":"texWidth","pt":$n[0].Int32,"ps":1},{"n":"texHeight","pt":$n[0].Int32,"ps":2}],"sn":"TextureRectToUVRect","rt":$n[4].Rect,"p":[$n[4].Rect,$n[0].Int32,$n[0].Int32]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[4].Sprite,"ps":0},{"n":"page","pt":$n[1].AtlasPage,"ps":1}],"sn":"ToAtlasRegion","rt":$n[1].AtlasRegion,"p":[$n[4].Sprite,$n[1].AtlasPage]},{"a":4,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[4].Sprite,"ps":0},{"n":"isolatedTexture","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"ToAtlasRegion$4","rt":$n[1].AtlasRegion,"p":[$n[4].Sprite,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[4].Sprite,"ps":0},{"n":"material","pt":$n[4].Material,"ps":1}],"sn":"ToAtlasRegion$1","rt":$n[1].AtlasRegion,"p":[$n[4].Sprite,$n[4].Material]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Texture2D,"ps":0},{"n":"materialPropertySource","pt":$n[4].Material,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToAtlasRegion$2","rt":$n[1].AtlasRegion,"p":[$n[4].Texture2D,$n[4].Material,$n[0].Single]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Texture2D,"ps":0},{"n":"shader","pt":$n[4].Shader,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[4].Material,"ps":3}],"sn":"ToAtlasRegion$3","rt":$n[1].AtlasRegion,"p":[$n[4].Texture2D,$n[4].Shader,$n[0].Single,$n[4].Material]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"s","pt":$n[4].Sprite,"ps":0},{"n":"materialPropertySource","pt":$n[4].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[4].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ToAtlasRegionPMAClone","rt":$n[1].AtlasRegion,"p":[$n[4].Sprite,$n[4].Material,$n[4].TextureFormat,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Texture2D,"ps":0},{"n":"materialPropertySource","pt":$n[4].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[4].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ToAtlasRegionPMAClone$2","rt":$n[1].AtlasRegion,"p":[$n[4].Texture2D,$n[4].Material,$n[4].TextureFormat,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"s","pt":$n[4].Sprite,"ps":0},{"n":"shader","pt":$n[4].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[4].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[4].Material,"ps":4}],"sn":"ToAtlasRegionPMAClone$1","rt":$n[1].AtlasRegion,"p":[$n[4].Sprite,$n[4].Shader,$n[4].TextureFormat,$n[0].Boolean,$n[4].Material]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Texture2D,"ps":0},{"n":"shader","pt":$n[4].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[4].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[4].Material,"ps":4}],"sn":"ToAtlasRegionPMAClone$3","rt":$n[1].AtlasRegion,"p":[$n[4].Texture2D,$n[4].Shader,$n[4].TextureFormat,$n[0].Boolean,$n[4].Material]},{"a":2,"n":"ToSpineAtlasPage","is":true,"t":8,"pi":[{"n":"m","pt":$n[4].Material,"ps":0}],"sn":"ToSpineAtlasPage","rt":$n[1].AtlasPage,"p":[$n[4].Material]},{"a":2,"n":"ToSprite","is":true,"t":8,"pi":[{"n":"ar","pt":$n[1].AtlasRegion,"ps":0},{"n":"pixelsPerUnit","dv":100.0,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"ToSprite","rt":$n[4].Sprite,"p":[$n[1].AtlasRegion,$n[0].Single]},{"a":1,"n":"ToTexture","is":true,"t":8,"pi":[{"n":"s","pt":$n[4].Sprite,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[4].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ToTexture$1","rt":$n[4].Texture2D,"p":[$n[4].Sprite,$n[4].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"ToTexture","is":true,"t":8,"pi":[{"n":"ar","pt":$n[1].AtlasRegion,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[4].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"texturePropertyId","dv":0,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"ToTexture","rt":$n[4].Texture2D,"p":[$n[1].AtlasRegion,$n[4].TextureFormat,$n[0].Boolean,$n[0].Int32,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"UVRectToAtlasRegion","is":true,"t":8,"pi":[{"n":"uvRect","pt":$n[4].Rect,"ps":0},{"n":"referenceRegion","pt":$n[1].AtlasRegion,"ps":1},{"n":"page","pt":$n[1].AtlasPage,"ps":2}],"sn":"UVRectToAtlasRegion","rt":$n[1].AtlasRegion,"p":[$n[4].Rect,$n[1].AtlasRegion,$n[1].AtlasPage]},{"a":1,"n":"UVRectToTextureRect","is":true,"t":8,"pi":[{"n":"uvRect","pt":$n[4].Rect,"ps":0},{"n":"texWidth","pt":$n[0].Int32,"ps":1},{"n":"texHeight","pt":$n[0].Int32,"ps":2}],"sn":"UVRectToTextureRect","rt":$n[4].Rect,"p":[$n[4].Rect,$n[0].Int32,$n[0].Int32]},{"a":1,"n":"CachedRegionTextures","is":true,"t":4,"rt":$n[3].Dictionary$2(Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey,UnityEngine.Texture2D),"sn":"CachedRegionTextures"},{"a":1,"n":"CachedRegionTexturesList","is":true,"t":4,"rt":$n[3].List$1(UnityEngine.Texture2D),"sn":"CachedRegionTexturesList"},{"a":4,"n":"DefaultMipmapBias","is":true,"t":4,"rt":$n[0].Single,"sn":"DefaultMipmapBias","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"DefaultScale","is":true,"t":4,"rt":$n[0].Single,"sn":"DefaultScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"NonrenderingRegion","is":true,"t":4,"rt":$n[0].Int32,"sn":"NonrenderingRegion","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"SpineTextureFormat","is":true,"t":4,"rt":$n[4].TextureFormat,"sn":"SpineTextureFormat","box":function ($v) { return Bridge.box($v, UnityEngine.TextureFormat, System.Enum.toStringFn(UnityEngine.TextureFormat));}},{"a":4,"n":"UseMipMaps","is":true,"t":4,"rt":$n[0].Boolean,"sn":"UseMipMaps","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"existingRegions","is":true,"t":4,"rt":$n[3].Dictionary$2(Spine.AtlasRegion,System.Int32),"sn":"existingRegions","ro":true},{"a":1,"n":"inoutAttachments","is":true,"t":4,"rt":$n[3].List$1(spine.Attachment),"sn":"inoutAttachments"},{"a":1,"n":"originalRegions","is":true,"t":4,"rt":$n[3].List$1(Spine.AtlasRegion),"sn":"originalRegions","ro":true},{"a":1,"n":"regionIndices","is":true,"t":4,"rt":$n[3].List$1(System.Int32),"sn":"regionIndices","ro":true},{"a":1,"n":"repackedRegions","is":true,"t":4,"rt":$n[3].List$1(Spine.AtlasRegion),"sn":"repackedRegions","ro":true},{"a":1,"n":"texturesToPackAtParam","is":true,"t":4,"rt":System.Array.type(System.Collections.Generic.List$1(UnityEngine.Texture2D)),"sn":"texturesToPackAtParam"}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AtlasUtilities end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey start.*/
    $m("Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey", function () { return {"td":$n[8].AtlasUtilities,"att":1048843,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[1].AtlasRegion],"pi":[{"n":"i","pt":$n[0].Int32,"ps":0},{"n":"region","pt":$n[1].AtlasRegion,"ps":1}],"sn":"$ctor1"},{"ov":true,"a":2,"n":"GetHashCode","t":8,"sn":"getHashCode","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"i","t":4,"rt":$n[0].Int32,"sn":"i","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"region","t":4,"rt":$n[1].AtlasRegion,"sn":"region"}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey end.*/

    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions start.*/
    $m("Spine.Unity.AttachmentTools.AttachmentCloneExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"GetRemappedClone","is":true,"t":8,"pi":[{"n":"o","pt":spine.Attachment,"ps":0},{"n":"atlasRegion","pt":$n[1].AtlasRegion,"ps":1},{"n":"cloneMeshAsLinked","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"useOriginalRegionSize","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":4}],"sn":"GetRemappedClone","rt":spine.Attachment,"p":[spine.Attachment,$n[1].AtlasRegion,$n[0].Boolean,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"GetRemappedClone","is":true,"t":8,"pi":[{"n":"o","pt":spine.Attachment,"ps":0},{"n":"sprite","pt":$n[4].Sprite,"ps":1},{"n":"sourceMaterial","pt":$n[4].Material,"ps":2},{"n":"premultiplyAlpha","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"cloneMeshAsLinked","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"useOriginalRegionSize","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"pivotShiftsMeshUVCoords","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"useOriginalRegionScale","dv":false,"o":true,"pt":$n[0].Boolean,"ps":7}],"sn":"GetRemappedClone$1","rt":spine.Attachment,"p":[spine.Attachment,$n[4].Sprite,$n[4].Material,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions end.*/

    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions start.*/
    $m("Spine.Unity.AttachmentTools.AttachmentRegionExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"SetPositionOffset","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[1].RegionAttachment,"ps":0},{"n":"offset","pt":$n[4].Vector2,"ps":1}],"sn":"SetPositionOffset$1","rt":$n[0].Void,"p":[$n[1].RegionAttachment,$n[4].Vector2]},{"a":2,"n":"SetPositionOffset","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[1].RegionAttachment,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetPositionOffset","rt":$n[0].Void,"p":[$n[1].RegionAttachment,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRegion","is":true,"t":8,"pi":[{"n":"attachment","pt":spine.Attachment,"ps":0},{"n":"region","pt":$n[1].AtlasRegion,"ps":1},{"n":"updateOffset","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"SetRegion","rt":$n[0].Void,"p":[spine.Attachment,$n[1].AtlasRegion,$n[0].Boolean]},{"a":2,"n":"SetRegion","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[1].MeshAttachment,"ps":0},{"n":"region","pt":$n[1].AtlasRegion,"ps":1},{"n":"updateUVs","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"SetRegion$1","rt":$n[0].Void,"p":[$n[1].MeshAttachment,$n[1].AtlasRegion,$n[0].Boolean]},{"a":2,"n":"SetRegion","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[1].RegionAttachment,"ps":0},{"n":"region","pt":$n[1].AtlasRegion,"ps":1},{"n":"updateOffset","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"SetRegion$2","rt":$n[0].Void,"p":[$n[1].RegionAttachment,$n[1].AtlasRegion,$n[0].Boolean]},{"a":2,"n":"SetRotation","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[1].RegionAttachment,"ps":0},{"n":"rotation","pt":$n[0].Single,"ps":1}],"sn":"SetRotation","rt":$n[0].Void,"p":[$n[1].RegionAttachment,$n[0].Single]},{"a":2,"n":"SetScale","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[1].RegionAttachment,"ps":0},{"n":"scale","pt":$n[4].Vector2,"ps":1}],"sn":"SetScale$1","rt":$n[0].Void,"p":[$n[1].RegionAttachment,$n[4].Vector2]},{"a":2,"n":"SetScale","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[1].RegionAttachment,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetScale","rt":$n[0].Void,"p":[$n[1].RegionAttachment,$n[0].Single,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[4].Sprite,"ps":0},{"n":"page","pt":$n[1].AtlasPage,"ps":1},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToRegionAttachment$1","rt":$n[1].RegionAttachment,"p":[$n[4].Sprite,$n[1].AtlasPage,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[4].Sprite,"ps":0},{"n":"material","pt":$n[4].Material,"ps":1},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToRegionAttachment$2","rt":$n[1].RegionAttachment,"p":[$n[4].Sprite,$n[4].Material,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"region","pt":$n[1].AtlasRegion,"ps":0},{"n":"attachmentName","pt":$n[0].String,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"ToRegionAttachment","rt":$n[1].RegionAttachment,"p":[$n[1].AtlasRegion,$n[0].String,$n[0].Single,$n[0].Single]},{"a":2,"n":"ToRegionAttachmentPMAClone","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[4].Sprite,"ps":0},{"n":"materialPropertySource","pt":$n[4].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[4].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":4}],"sn":"ToRegionAttachmentPMAClone","rt":$n[1].RegionAttachment,"p":[$n[4].Sprite,$n[4].Material,$n[4].TextureFormat,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"ToRegionAttachmentPMAClone","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[4].Sprite,"ps":0},{"n":"shader","pt":$n[4].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[4].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[4].Material,"ps":4},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":5}],"sn":"ToRegionAttachmentPMAClone$1","rt":$n[1].RegionAttachment,"p":[$n[4].Sprite,$n[4].Shader,$n[4].TextureFormat,$n[0].Boolean,$n[4].Material,$n[0].Single]}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions end.*/

    /*Do.AudioManager start.*/
    $m("Do.AudioManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"InitBoolean","t":8,"sn":"InitBoolean","rt":$n[0].Void},{"a":1,"n":"InitSource","t":8,"sn":"InitSource","rt":$n[0].Void},{"a":2,"n":"Play","t":8,"pi":[{"n":"musicType","pt":MusicType,"ps":0}],"sn":"Play","rt":$n[0].Void,"p":[MusicType]},{"a":2,"n":"Play","t":8,"pi":[{"n":"soundType","pt":SoundType,"ps":0}],"sn":"Play$1","rt":$n[0].Void,"p":[SoundType]},{"a":2,"n":"PlayCache","t":8,"pi":[{"n":"soundType","pt":SoundType,"ps":0}],"sn":"PlayCache","rt":$n[0].Void,"p":[SoundType]},{"a":2,"n":"SetMusicMute","t":8,"sn":"SetMusicMute","rt":$n[0].Void},{"a":2,"n":"SetSoundMute","t":8,"sn":"SetSoundMute","rt":$n[0].Void},{"a":2,"n":"StopAll","t":8,"sn":"StopAll","rt":$n[0].Void},{"a":2,"n":"StopMusic","t":8,"sn":"StopMusic","rt":$n[0].Void},{"a":2,"n":"StopSound","t":8,"sn":"StopSound","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"Music","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Music","t":8,"rt":$n[0].Boolean,"fg":"Music","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Music","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Music"},"fn":"Music"},{"a":2,"n":"Sound","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Sound","t":8,"rt":$n[0].Boolean,"fg":"Sound","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Sound","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Sound"},"fn":"Sound"},{"a":2,"n":"Vibration","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Vibration","t":8,"rt":$n[0].Boolean,"fg":"Vibration","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Vibration","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Vibration"},"fn":"Vibration"},{"a":1,"n":"KEY_MUSIC","is":true,"t":4,"rt":$n[0].String,"sn":"KEY_MUSIC"},{"a":1,"n":"KEY_SOUND","is":true,"t":4,"rt":$n[0].String,"sn":"KEY_SOUND"},{"a":1,"n":"KEY_VIBRATION","is":true,"t":4,"rt":$n[0].String,"sn":"KEY_VIBRATION"},{"at":[new UnityEngine.HeaderAttribute("Variable")],"a":1,"n":"_dictionaryMusic","t":4,"rt":$n[3].Dictionary$2(MusicType,System.Int32),"sn":"_dictionaryMusic","ro":true},{"a":1,"n":"_dictionarySound","t":4,"rt":$n[3].Dictionary$2(SoundType,System.Int32),"sn":"_dictionarySound","ro":true},{"a":1,"n":"_dictionarySoundDuration","t":4,"rt":$n[3].Dictionary$2(SoundType,System.Single),"sn":"_dictionarySoundDuration","ro":true},{"a":1,"n":"_dictionarySoundTimes","t":4,"rt":$n[3].Dictionary$2(SoundType,System.Single),"sn":"_dictionarySoundTimes","ro":true},{"a":1,"n":"_music","t":4,"rt":$n[0].Boolean,"sn":"_music","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_sound","t":4,"rt":$n[0].Boolean,"sn":"_sound","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_vibration","t":4,"rt":$n[0].Boolean,"sn":"_vibration","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"instance","is":true,"t":4,"rt":$n[9].AudioManager,"sn":"instance"},{"at":[new UnityEngine.HeaderAttribute("Source"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"musicClipSource","t":4,"rt":$n[3].List$1(Do.AudioMusic),"sn":"musicClipSource"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundClipSource","t":4,"rt":$n[3].List$1(Do.AudioSound),"sn":"soundClipSource"}]}; }, $n);
    /*Do.AudioManager end.*/

    /*Do.AudioMusic start.*/
    $m("Do.AudioMusic", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"musicType","t":4,"rt":MusicType,"sn":"musicType","box":function ($v) { return Bridge.box($v, MusicType, System.Enum.toStringFn(MusicType));}}]}; }, $n);
    /*Do.AudioMusic end.*/

    /*Do.AudioSound start.*/
    $m("Do.AudioSound", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"duration","t":4,"rt":$n[0].Single,"sn":"duration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"soundType","t":4,"rt":SoundType,"sn":"soundType","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}}]}; }, $n);
    /*Do.AudioSound end.*/

    /*DG.Tweening.DOTweenModuleAudio start.*/
    $m("DG.Tweening.DOTweenModuleAudio", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOComplete","is":true,"t":8,"pi":[{"n":"target","pt":$n[10].AudioMixer,"ps":0},{"n":"withCallbacks","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DOComplete","rt":$n[0].Int32,"p":[$n[10].AudioMixer,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].AudioSource,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[11].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[4].AudioSource,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFlip","is":true,"t":8,"pi":[{"n":"target","pt":$n[10].AudioMixer,"ps":0}],"sn":"DOFlip","rt":$n[0].Int32,"p":[$n[10].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOGoto","is":true,"t":8,"pi":[{"n":"target","pt":$n[10].AudioMixer,"ps":0},{"n":"to","pt":$n[0].Single,"ps":1},{"n":"andPlay","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"DOGoto","rt":$n[0].Int32,"p":[$n[10].AudioMixer,$n[0].Single,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOKill","is":true,"t":8,"pi":[{"n":"target","pt":$n[10].AudioMixer,"ps":0},{"n":"complete","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DOKill","rt":$n[0].Int32,"p":[$n[10].AudioMixer,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPause","is":true,"t":8,"pi":[{"n":"target","pt":$n[10].AudioMixer,"ps":0}],"sn":"DOPause","rt":$n[0].Int32,"p":[$n[10].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPitch","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].AudioSource,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPitch","rt":$n[11].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[4].AudioSource,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPlay","is":true,"t":8,"pi":[{"n":"target","pt":$n[10].AudioMixer,"ps":0}],"sn":"DOPlay","rt":$n[0].Int32,"p":[$n[10].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPlayBackwards","is":true,"t":8,"pi":[{"n":"target","pt":$n[10].AudioMixer,"ps":0}],"sn":"DOPlayBackwards","rt":$n[0].Int32,"p":[$n[10].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPlayForward","is":true,"t":8,"pi":[{"n":"target","pt":$n[10].AudioMixer,"ps":0}],"sn":"DOPlayForward","rt":$n[0].Int32,"p":[$n[10].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DORestart","is":true,"t":8,"pi":[{"n":"target","pt":$n[10].AudioMixer,"ps":0}],"sn":"DORestart","rt":$n[0].Int32,"p":[$n[10].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DORewind","is":true,"t":8,"pi":[{"n":"target","pt":$n[10].AudioMixer,"ps":0}],"sn":"DORewind","rt":$n[0].Int32,"p":[$n[10].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOSetFloat","is":true,"t":8,"pi":[{"n":"target","pt":$n[10].AudioMixer,"ps":0},{"n":"floatName","pt":$n[0].String,"ps":1},{"n":"endValue","pt":$n[0].Single,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOSetFloat","rt":$n[11].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[10].AudioMixer,$n[0].String,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOSmoothRewind","is":true,"t":8,"pi":[{"n":"target","pt":$n[10].AudioMixer,"ps":0}],"sn":"DOSmoothRewind","rt":$n[0].Int32,"p":[$n[10].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOTogglePause","is":true,"t":8,"pi":[{"n":"target","pt":$n[10].AudioMixer,"ps":0}],"sn":"DOTogglePause","rt":$n[0].Int32,"p":[$n[10].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*DG.Tweening.DOTweenModuleAudio end.*/

    /*DG.Tweening.DOTweenModulePhysics start.*/
    $m("DG.Tweening.DOTweenModulePhysics", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOJump","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Rigidbody,"ps":0},{"n":"endValue","pt":$n[4].Vector3,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJump","rt":$n[12].Sequence,"p":[$n[4].Rigidbody,$n[4].Vector3,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Rigidbody,"ps":0},{"n":"path","pt":$n[13].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[12].PathMode,"ps":3}],"sn":"DOLocalPath$1","rt":$n[11].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[4].Rigidbody,$n[13].Path,$n[0].Single,$n[12].PathMode]},{"a":2,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Rigidbody,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector3),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[12].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[12].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOLocalPath","rt":$n[11].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[4].Rigidbody,System.Array.type(UnityEngine.Vector3),$n[0].Single,$n[12].PathType,$n[12].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DOLookAt","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Rigidbody,"ps":0},{"n":"towards","pt":$n[4].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"axisConstraint","dv":0,"o":true,"pt":$n[12].AxisConstraint,"ps":3},{"n":"up","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Vector3),"ps":4}],"sn":"DOLookAt","rt":$n[11].TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions),"p":[$n[4].Rigidbody,$n[4].Vector3,$n[0].Single,$n[12].AxisConstraint,$n[0].Nullable$1(UnityEngine.Vector3)]},{"a":2,"n":"DOMove","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Rigidbody,"ps":0},{"n":"endValue","pt":$n[4].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMove","rt":$n[11].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].Rigidbody,$n[4].Vector3,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveX","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveX","rt":$n[11].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveY","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveY","rt":$n[11].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveZ","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveZ","rt":$n[11].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Rigidbody,"ps":0},{"n":"path","pt":$n[13].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[12].PathMode,"ps":3}],"sn":"DOPath$1","rt":$n[11].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[4].Rigidbody,$n[13].Path,$n[0].Single,$n[12].PathMode]},{"a":2,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Rigidbody,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector3),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[12].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[12].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOPath","rt":$n[11].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[4].Rigidbody,System.Array.type(UnityEngine.Vector3),$n[0].Single,$n[12].PathType,$n[12].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DORotate","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Rigidbody,"ps":0},{"n":"endValue","pt":$n[4].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"mode","dv":0,"o":true,"pt":$n[12].RotateMode,"ps":3}],"sn":"DORotate","rt":$n[11].TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions),"p":[$n[4].Rigidbody,$n[4].Vector3,$n[0].Single,$n[12].RotateMode]}]}; }, $n);
    /*DG.Tweening.DOTweenModulePhysics end.*/

    /*DG.Tweening.DOTweenModulePhysics2D start.*/
    $m("DG.Tweening.DOTweenModulePhysics2D", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOJump","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[4].Vector2,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJump","rt":$n[12].Sequence,"p":[$n[4].Rigidbody2D,$n[4].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Rigidbody2D,"ps":0},{"n":"path","pt":$n[13].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[12].PathMode,"ps":3}],"sn":"DOLocalPath$1","rt":$n[11].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[4].Rigidbody2D,$n[13].Path,$n[0].Single,$n[12].PathMode]},{"a":2,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Rigidbody2D,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[12].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[12].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOLocalPath","rt":$n[11].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[4].Rigidbody2D,System.Array.type(UnityEngine.Vector2),$n[0].Single,$n[12].PathType,$n[12].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DOMove","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[4].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMove","rt":$n[11].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].Rigidbody2D,$n[4].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveX","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveX","rt":$n[11].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].Rigidbody2D,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveY","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveY","rt":$n[11].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].Rigidbody2D,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Rigidbody2D,"ps":0},{"n":"path","pt":$n[13].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[12].PathMode,"ps":3}],"sn":"DOPath$1","rt":$n[11].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[4].Rigidbody2D,$n[13].Path,$n[0].Single,$n[12].PathMode]},{"a":2,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Rigidbody2D,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[12].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[12].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOPath","rt":$n[11].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[4].Rigidbody2D,System.Array.type(UnityEngine.Vector2),$n[0].Single,$n[12].PathType,$n[12].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DORotate","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DORotate","rt":$n[11].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[4].Rigidbody2D,$n[0].Single,$n[0].Single]}]}; }, $n);
    /*DG.Tweening.DOTweenModulePhysics2D end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    $m("DG.Tweening.DOTweenModuleSprite", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[4].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[12].Tweener,"p":[$n[4].SpriteRenderer,$n[4].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[4].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor","rt":$n[11].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[4].SpriteRenderer,$n[4].Color,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[11].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[4].SpriteRenderer,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].SpriteRenderer,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[12].Sequence,"p":[$n[4].SpriteRenderer,pc.ColorGradient,$n[0].Single]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    $m("DG.Tweening.DOTweenModuleUI", function () { return {"nested":[$n[12].DOTweenModuleUI.Utils],"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOAnchorMax","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].RectTransform,"ps":0},{"n":"endValue","pt":$n[4].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorMax","rt":$n[11].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].RectTransform,$n[4].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorMin","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].RectTransform,"ps":0},{"n":"endValue","pt":$n[4].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorMin","rt":$n[11].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].RectTransform,$n[4].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].RectTransform,"ps":0},{"n":"endValue","pt":$n[4].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos","rt":$n[11].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].RectTransform,$n[4].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3D","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].RectTransform,"ps":0},{"n":"endValue","pt":$n[4].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3D","rt":$n[11].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].RectTransform,$n[4].Vector3,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DX","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DX","rt":$n[11].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DY","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DY","rt":$n[11].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DZ","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DZ","rt":$n[11].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPosX","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPosX","rt":$n[11].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPosY","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPosY","rt":$n[11].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Graphic,"ps":0},{"n":"endValue","pt":$n[4].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[12].Tweener,"p":[$n[6].Graphic,$n[4].Color,$n[0].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Image,"ps":0},{"n":"endValue","pt":$n[4].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor$1","rt":$n[12].Tweener,"p":[$n[6].Image,$n[4].Color,$n[0].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Text,"ps":0},{"n":"endValue","pt":$n[4].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor$2","rt":$n[12].Tweener,"p":[$n[6].Text,$n[4].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Graphic,"ps":0},{"n":"endValue","pt":$n[4].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor","rt":$n[11].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[6].Graphic,$n[4].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Image,"ps":0},{"n":"endValue","pt":$n[4].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$1","rt":$n[11].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[6].Image,$n[4].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Outline,"ps":0},{"n":"endValue","pt":$n[4].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$2","rt":$n[11].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[6].Outline,$n[4].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Text,"ps":0},{"n":"endValue","pt":$n[4].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$3","rt":$n[11].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[6].Text,$n[4].Color,$n[0].Single]},{"a":2,"n":"DOCounter","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Text,"ps":0},{"n":"fromValue","pt":$n[0].Int32,"ps":1},{"n":"endValue","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3},{"n":"addThousandsSeparator","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"culture","dv":null,"o":true,"pt":$n[14].CultureInfo,"ps":5}],"sn":"DOCounter","rt":$n[11].TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions),"p":[$n[6].Text,$n[0].Int32,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[14].CultureInfo]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].CanvasGroup,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[11].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[4].CanvasGroup,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Graphic,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$1","rt":$n[11].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[6].Graphic,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Image,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$2","rt":$n[11].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[6].Image,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Outline,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$3","rt":$n[11].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[6].Outline,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Text,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$4","rt":$n[11].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[6].Text,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFillAmount","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Image,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFillAmount","rt":$n[11].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[6].Image,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFlexibleSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].LayoutElement,"ps":0},{"n":"endValue","pt":$n[4].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOFlexibleSize","rt":$n[11].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[6].LayoutElement,$n[4].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Image,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[12].Sequence,"p":[$n[6].Image,pc.ColorGradient,$n[0].Single]},{"a":2,"n":"DOHorizontalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].ScrollRect,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOHorizontalNormalizedPos","rt":$n[12].Tweener,"p":[$n[6].ScrollRect,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOJumpAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].RectTransform,"ps":0},{"n":"endValue","pt":$n[4].Vector2,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJumpAnchorPos","rt":$n[12].Sequence,"p":[$n[4].RectTransform,$n[4].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMinSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].LayoutElement,"ps":0},{"n":"endValue","pt":$n[4].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMinSize","rt":$n[11].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[6].LayoutElement,$n[4].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DONormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].ScrollRect,"ps":0},{"n":"endValue","pt":$n[4].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DONormalizedPos","rt":$n[12].Tweener,"p":[$n[6].ScrollRect,$n[4].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPivot","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].RectTransform,"ps":0},{"n":"endValue","pt":$n[4].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivot","rt":$n[11].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].RectTransform,$n[4].Vector2,$n[0].Single]},{"a":2,"n":"DOPivotX","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivotX","rt":$n[11].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].RectTransform,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPivotY","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivotY","rt":$n[11].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].RectTransform,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPreferredSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].LayoutElement,"ps":0},{"n":"endValue","pt":$n[4].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOPreferredSize","rt":$n[11].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[6].LayoutElement,$n[4].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPunchAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].RectTransform,"ps":0},{"n":"punch","pt":$n[4].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"elasticity","dv":1.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOPunchAnchorPos","rt":$n[12].Tweener,"p":[$n[4].RectTransform,$n[4].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOScale","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Outline,"ps":0},{"n":"endValue","pt":$n[4].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOScale","rt":$n[11].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[6].Outline,$n[4].Vector2,$n[0].Single]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].RectTransform,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"strength","dv":100.0,"o":true,"pt":$n[0].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"randomnessMode","dv":0,"o":true,"pt":$n[12].ShakeRandomnessMode,"ps":7}],"sn":"DOShakeAnchorPos","rt":$n[12].Tweener,"p":[$n[4].RectTransform,$n[0].Single,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Boolean,$n[12].ShakeRandomnessMode]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].RectTransform,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"strength","pt":$n[4].Vector2,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"randomnessMode","dv":0,"o":true,"pt":$n[12].ShakeRandomnessMode,"ps":7}],"sn":"DOShakeAnchorPos$1","rt":$n[12].Tweener,"p":[$n[4].RectTransform,$n[0].Single,$n[4].Vector2,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Boolean,$n[12].ShakeRandomnessMode]},{"a":2,"n":"DOShapeCircle","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].RectTransform,"ps":0},{"n":"center","pt":$n[4].Vector2,"ps":1},{"n":"endValueDegrees","pt":$n[0].Single,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3},{"n":"relativeCenter","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOShapeCircle","rt":$n[11].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.CircleOptions),"p":[$n[4].RectTransform,$n[4].Vector2,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"DOSizeDelta","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].RectTransform,"ps":0},{"n":"endValue","pt":$n[4].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOSizeDelta","rt":$n[11].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].RectTransform,$n[4].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOText","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Text,"ps":0},{"n":"endValue","pt":$n[0].String,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"richTextEnabled","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"scrambleMode","dv":0,"o":true,"pt":$n[12].ScrambleMode,"ps":4},{"n":"scrambleChars","dv":null,"o":true,"pt":$n[0].String,"ps":5}],"sn":"DOText","rt":$n[11].TweenerCore$3(System.String,System.String,DG.Tweening.Plugins.Options.StringOptions),"p":[$n[6].Text,$n[0].String,$n[0].Single,$n[0].Boolean,$n[12].ScrambleMode,$n[0].String]},{"a":2,"n":"DOValue","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Slider,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOValue","rt":$n[11].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[6].Slider,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOVerticalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].ScrollRect,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOVerticalNormalizedPos","rt":$n[12].Tweener,"p":[$n[6].ScrollRect,$n[0].Single,$n[0].Single,$n[0].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    $m("DG.Tweening.DOTweenModuleUI.Utils", function () { return {"td":$n[12].DOTweenModuleUI,"att":1048962,"a":2,"s":true,"m":[{"a":2,"n":"SwitchToRectTransform","is":true,"t":8,"pi":[{"n":"from","pt":$n[4].RectTransform,"ps":0},{"n":"to","pt":$n[4].RectTransform,"ps":1}],"sn":"SwitchToRectTransform","rt":$n[4].Vector2,"p":[$n[4].RectTransform,$n[4].RectTransform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    $m("DG.Tweening.DOTweenModuleUnityVersion", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Material,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[12].Sequence,"p":[$n[4].Material,pc.ColorGradient,$n[0].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Material,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"property","pt":$n[0].String,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOGradientColor$1","rt":$n[12].Sequence,"p":[$n[4].Material,pc.ColorGradient,$n[0].String,$n[0].Single]},{"a":2,"n":"DOOffset","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Material,"ps":0},{"n":"endValue","pt":$n[4].Vector2,"ps":1},{"n":"propertyID","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOOffset","rt":$n[11].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].Material,$n[4].Vector2,$n[0].Int32,$n[0].Single]},{"a":2,"n":"DOTiling","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Material,"ps":0},{"n":"endValue","pt":$n[4].Vector2,"ps":1},{"n":"propertyID","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOTiling","rt":$n[11].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].Material,$n[4].Vector2,$n[0].Int32,$n[0].Single]},{"a":2,"n":"WaitForCompletion","is":true,"t":8,"pi":[{"n":"t","pt":$n[12].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForCompletion","rt":$n[4].CustomYieldInstruction,"p":[$n[12].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForElapsedLoops","is":true,"t":8,"pi":[{"n":"t","pt":$n[12].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[0].Int32,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":2}],"sn":"WaitForElapsedLoops","rt":$n[4].CustomYieldInstruction,"p":[$n[12].Tween,$n[0].Int32,$n[0].Boolean]},{"a":2,"n":"WaitForKill","is":true,"t":8,"pi":[{"n":"t","pt":$n[12].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForKill","rt":$n[4].CustomYieldInstruction,"p":[$n[12].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForPosition","is":true,"t":8,"pi":[{"n":"t","pt":$n[12].Tween,"ps":0},{"n":"position","pt":$n[0].Single,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":2}],"sn":"WaitForPosition","rt":$n[4].CustomYieldInstruction,"p":[$n[12].Tween,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"WaitForRewind","is":true,"t":8,"pi":[{"n":"t","pt":$n[12].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForRewind","rt":$n[4].CustomYieldInstruction,"p":[$n[12].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForStart","is":true,"t":8,"pi":[{"n":"t","pt":$n[12].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForStart","rt":$n[4].CustomYieldInstruction,"p":[$n[12].Tween,$n[0].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    $m("DG.Tweening.DOTweenCYInstruction", function () { return {"nested":[$n[12].DOTweenCYInstruction.WaitForCompletion,$n[12].DOTweenCYInstruction.WaitForRewind,$n[12].DOTweenCYInstruction.WaitForKill,$n[12].DOTweenCYInstruction.WaitForElapsedLoops,$n[12].DOTweenCYInstruction.WaitForPosition,$n[12].DOTweenCYInstruction.WaitForStart],"att":1048961,"a":2,"s":true}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", function () { return {"td":$n[12].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[12].Tween],"pi":[{"n":"tween","pt":$n[12].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[12].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForRewind", function () { return {"td":$n[12].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[12].Tween],"pi":[{"n":"tween","pt":$n[12].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[12].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForKill", function () { return {"td":$n[12].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[12].Tween],"pi":[{"n":"tween","pt":$n[12].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[12].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", function () { return {"td":$n[12].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[12].Tween,$n[0].Int32],"pi":[{"n":"tween","pt":$n[12].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[0].Int32,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"elapsedLoops","t":4,"rt":$n[0].Int32,"sn":"elapsedLoops","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"t","t":4,"rt":$n[12].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForPosition", function () { return {"td":$n[12].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[12].Tween,$n[0].Single],"pi":[{"n":"tween","pt":$n[12].Tween,"ps":0},{"n":"position","pt":$n[0].Single,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"position","t":4,"rt":$n[0].Single,"sn":"position","ro":true,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"t","t":4,"rt":$n[12].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForStart", function () { return {"td":$n[12].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[12].Tween],"pi":[{"n":"tween","pt":$n[12].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[12].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    $m("DG.Tweening.DOTweenModuleUtils", function () { return {"nested":[$n[12].DOTweenModuleUtils.Physics],"att":1048961,"a":2,"s":true,"m":[{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"Init","is":true,"t":8,"sn":"Init","rt":$n[0].Void},{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":1,"n":"Preserver","is":true,"t":8,"sn":"Preserver","rt":$n[0].Void},{"a":1,"n":"_initialized","is":true,"t":4,"rt":$n[0].Boolean,"sn":"_initialized","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    $m("DG.Tweening.DOTweenModuleUtils.Physics", function () { return {"td":$n[12].DOTweenModuleUtils,"att":1048962,"a":2,"s":true,"m":[{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"CreateDOTweenPathTween","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].MonoBehaviour,"ps":0},{"n":"tweenRigidbody","pt":$n[0].Boolean,"ps":1},{"n":"isLocal","pt":$n[0].Boolean,"ps":2},{"n":"path","pt":$n[13].Path,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"pathMode","pt":$n[12].PathMode,"ps":5}],"sn":"CreateDOTweenPathTween","rt":$n[11].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[4].MonoBehaviour,$n[0].Boolean,$n[0].Boolean,$n[13].Path,$n[0].Single,$n[12].PathMode]},{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"HasRigidbody","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Component,"ps":0}],"sn":"HasRigidbody","rt":$n[0].Boolean,"p":[$n[4].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"HasRigidbody2D","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Component,"ps":0}],"sn":"HasRigidbody2D","rt":$n[0].Boolean,"p":[$n[4].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SetOrientationOnPath","is":true,"t":8,"pi":[{"n":"options","pt":$n[15].PathOptions,"ps":0},{"n":"t","pt":$n[12].Tween,"ps":1},{"n":"newRot","pt":$n[4].Quaternion,"ps":2},{"n":"trans","pt":$n[4].Transform,"ps":3}],"sn":"SetOrientationOnPath","rt":$n[0].Void,"p":[$n[15].PathOptions,$n[12].Tween,$n[4].Quaternion,$n[4].Transform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    }});
